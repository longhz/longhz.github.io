[{"title":"centos7_oracle_12c静默安装（无界面）","url":"/2021/09/06/12c%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85%EF%BC%88%E6%97%A0%E7%95%8C%E9%9D%A2%EF%BC%89/","content":"CentOS 7下Oracle 12C 无图形界面静默安装1、关闭防火墙(可跳过)systemctl stop firewalld.service –关闭防火墙systemctl disable firewalld.service – 禁止防火墙开机启动\n2、关闭selinux(不可跳过)setenforce 0\n编辑文件\nvim /etc/selinux/config\n\n文件中设置\nSELINUX=disabled\n\n\n3、修改host名称（其实可以省略）vim /etc/hosts\n\n在文件末尾加上 自己的ip和 oracleVM\n192.168.217.128 oracleVM\n3、安装必要的依赖包配置yum源cd /etcmv yum.repos.d yum.repos.d.bakmkdir yum.repos.dwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo# 清理缓存yum clean all# 建缓存yum makecache#安装epel源yum -y install epel-release\n\n如果没有外网，可以挂载系统盘，来配置yum源mkdir /mnt/cdrom/mount /dev/cdrom /mnt/cdrom/#配置开机挂载光盘vim /etc/fstab//编辑fastab文件，在文本末行加入以下参数，&#x27;ro&#x27;为只读。/dev/cdrom /mnt/cdrom  iso9660 ro   0 0#更换yum源##清理旧的配置（cp备份或mv移走或者rm删除都行）mv /etc/yum.repos.d/ /etc/yum.repos.d.bakmkdir /etc/yum.repos.dcd /etc/yum.repos.dtouch CentOS-Sources.repo##手动添加新的软件源，指向前一步准备的本地软件仓库vi /etc/yum.repos.d/CentOS-Sources.repo##填写以下内容[CentOS7-Localsource]name=CentOS7baseurl=file:///mnt/cdromenabled=1gpgcheck=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7[CentOS7-Localsource] ## 这个是源的名字，具有唯一性，不能和其他的重复name=CentOS7  ## 相当于注释，对redhat源的描述baseurl=file:///mnt/cdrom  ## 挂载的目录enabled=1 #yum源是否启用 1-启用 0-不启用gpgcheck=0 #安全检测 1-开启 0-不开启# 清理缓存并生成# 清理缓存yum clean all# 建缓存yum makecache\n\n期间可能会出现错误的情况，执行多几次就好了\nrpm -ivh --nodeps --force pdksh-5.2.14-37.el5_8.1.x86_64.rpmrpm -ivh --nodeps --force compat-libstdc++-33-3.2.3-72.el7.x86_64.rpmyum -y install binutils compat-libcap1 compat-libstdc++-33 compat-libstdc++-33*i686 compat-libstdc++-33*.devel compat-libstdc++-33 compat-libstdc++-33*.devel gcc gcc-c++ glibc glibc*.i686 glibc-devel glibc-devel*.i686 ksh libaio libaio*.i686 libaio-devel libaio-devel*.devel libgcc libgcc*.i686 libstdc++ libstdc++*.i686 libstdc++-devel libstdc++-devel*.devel libXi libXi*.i686 libXtst libXtst*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686 elfutils*\n\n安装完后检查是否安装成功，成功是31个包\nrpm -q binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-devel\n\n\n查看和修改系统语言#查看本地语言echo $LANG#修改语言配制文件vi /etc/locale.conf#英文或者中文LANG=en_US.UTF-8#LANG=zh_CN.UTF-8\n\n4、创建用户和用户组创建oinstall和dba组\ngroupadd oinstallgroupadd dbagroupadd oper\n\n创建Oracle用户\n#useradd -g oinstall -G dba oracleuseradd oracle -g oinstall -G dba,oper\n\n设置Oracle用户密码\npasswd oracle\n查看创建结果\nid oracle\n\n\n5、修改内核参数（根据需要修改）编辑打开配置文件\nvim /etc/sysctl.conf\n\n在文件中加上：\nfs.aio-max-nr=1048576fs.file-max=6815744kernel.shmall=2097152kernel.shmmax=2147483647# kernel.shmmax 参数设置为物理内存的一半kernel.shmmni=4096kernel.sem=250 32000 100 128kernel.panic_on_oops=1#当系统发生oops或BUG时,所采取的措施0:继续运行;net.ipv4.ip_local_port_range=9000 65500net.core.rmem_default=262144net.core.rmem_max=4194304net.core.wmem_default=262144net.core.wmem_max=1048576#net.ipv4.conf.all.rp_filter=2#net.ipv4.conf.default.rp_filter=2\n\n\n然后使配置文件生效\nsysctl -p\n\n\n\n付上各个参数说明：fs.aio-max-nr：此参数限制并发未完成的请求，应该设置避免I&#x2F;O子系统故障。fs.file-max：该参数决定了系统中所允许的文件句柄最大数目，文件句柄设置代表linux系统中可以打开的文件的数量。kernel.shmall：该参数控制可以使用的共享内存的总页数。Linux共享内存页大小为4KB,共享内存段的大小都是共享内存页大小的整数倍。一个共享内存段的最大大小是16G，那么需要共享内存页数是16GB&#x2F;4KB&#x3D;16777216KB &#x2F;4KB&#x3D;4194304（页），也就是64Bit系统下16GB物理内存，设置kernel.shmall &#x3D; 4194304才符合要求.kernel.shmmax：是核心参数中最重要的参数之一，用于定义单个共享内存段的最大值。设置应该足够大，设置的过低可能会导致需要创建多个共享内存段，这样可能导致系统性能的下降。至于导致系统下降的主要原因为在实例启动以及ServerProcess创建的时候，多个小的共享内存段可能会导致当时轻微的系统性能的降低(在启动的时候需要去创建多个虚拟地址段，在进程创建的时候要让进程对多个段进行“识别”，会有一些影响)，但是其他时候都不会有影响。官方建议值：32位linux系统：可取最大值为4GB（4294967296bytes）-1byte，即4294967295。建议值为多于内存的一半，所以如果是32为系统，一般可取值为4294967295。64位linux系统：可取的最大值为物理内存值-1byte，建议值为多于物理内存的一半，例如，如果为12GB物理内存，可取1210241024*1024-1&#x3D;12884901887。kernel.shmmni：该参数是共享内存段的最大数量。shmmni缺省值4096，一般肯定是够用了。kernel.sem：以kernel.sem &#x3D; 250 32000 100 128为例：\n250是参数semmsl的值，表示一个信号量集合中能够包含的信号量最大数目。\n32000是参数semmns的值，表示系统内可允许的信号量最大数目。\n100是参数semopm的值，表示单个semopm()调用在一个信号量集合上可以执行的操作数量。\n128是参数semmni的值，表示系统信号量集合总数。\nnet.ipv4.ip_local_port_range：表示应用程序可使用的IPv4端口范围。net.core.rmem_default：表示套接字接收缓冲区大小的缺省值。net.core.rmem_max：表示套接字接收缓冲区大小的最大值。net.core.wmem_default：表示套接字发送缓冲区大小的缺省值。net.core.wmem_max：表示套接字发送缓冲区大小的最大值。\n\n6、修改配置（1）打开并编辑文件\nvim /etc/security/limits.conf\n\n在文件末尾加上：\noracle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536oracle soft stack 10240oracle hard stack 10240\n\n\n为了优化性能，需要添加oracle用户的限制参数\n第1行是设置进程数软限制；第2行是设置进程数硬限制；第3行是设置文件数软限制；第4行是设置文件数硬限制\n\n（2）打开并编辑文件\nvim /etc/pam.d/login\n\n添加以下内容\nsession required /lib64/security/pam_limits.sosession required pam_limits.so\n使配置文件生效\nsource /etc/profile\n（4）创数据库目录\n# 安装包解压目录，随意放mkdir -p /u01/tmp# oracle安装目录mkdir -p /u01/oracle/app/oracle/product/11.2.0mkdir -p /u01/oracle/app/oraInventory# 授权chown -R oracle:oinstall /u01/oracle/app/oracle/chown -R oracle:oinstall /u01/oracle/app/oraInventory/chown -R oracle:oinstall /u01/tmpchmod -R 775 /u01/oracle/app/oracle/\n\n（5）配置Oracle用户\n切换到oracle用户下\nsu - oracle\n\n打开并编辑环境变量文件，配置oracle用户环境变量\nvim ~/.bash_profile\n\n在末尾添加\n# 添加如下内容export TMP=/tmpexport TMPDIR=$TMPexport ORACLE_BASE=/u01/oracle/app/oracleexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1export ORACLE_SID=ora11gexport ORACLE_UNQNAME=$ORACLE_SIDexport ORACLE_TERM=xtermexport PATH=$ORACLE_HOME/bin:$PATHexport NLS_LANG=AMERICAN_AMERICA.ZHS16GBKif [ $USER = &quot;oracle&quot; ]; then    if [ $SHELL = &quot;/bin/ksh&quot; ]; then        ulimit -p 16384        ulimit -n 65536    else        ulimit -u 16384 -n 65536    fifi\n\n使配置生效\nsource ~/.bash_profile\n\n\n\n四、安装部署及配置1、上传Oracle安装包创建一个文件夹\nmkdir /u01/oradb\n\n2、安装解压工具切换到root用户\nsu - root\n\n安装解压工具\nyum install -y unzip zip\n\n3、解压文件切换到oracle用户\nsu - oracle\n\n解压文件\nunzip xxx.zip\n\n等安装文件解压完毕后，要对解压文件授权，防止文件执行权限不足\nchmod -R 775 /u01/tmp/database/\n\n\n4、复制相应的模板为了不影响原来的文件内容（后面文件脚本内容会作修改），将相应的模板复制一份，当然也可以省略这步\ncd /u01/oradbmkdir etc cp  /u01/tmp/database/response/* /u01/oradb/etc/\n\n切换到root用户\nsu - root\n\n设置权限\nchmod 700 /u01/oradb/etc/*.rsp\n\n5、编辑文件内容切换到oracle用户\nsu - oracle\n\n打开编辑db_install.rsp\nvim /u01/oradb/etc/db_install.rsp\n\n找出以下项，并作修改（根据个人实际情况修改，比如我这边的oracle的目录是做过调整的）\noracle.install.option=INSTALL_DB_SWONLY // 安装类型  UNIX_GROUP_NAME=oinstall // 安装组  INVENTORY_LOCATION=/u01/oracle/app/oracle/oraInventory //INVENTORY目录（不填就是默认值）  ORACLE_HOME=/u01/oracle/app/oracle/product/12/db_1  ORACLE_BASE=/u01/oracle/app/oracle  oracle.install.db.InstallEdition=EE 　　　　// 企业版本  oracle.install.db.OSDBA_GROUP=dba  oracle.install.db.OSOPER_GROUP=oinstall  oracle.install.db.OSBACKUPDBA_GROUP=oinstall  oracle.install.db.OSDGDBA_GROUP=oinstall  oracle.install.db.OSKMDBA_GROUP=oinstall  oracle.install.db.OSRACDBA_GROUP=oinstall  oracle.install.db.config.starterdb.type=GENERAL_PURPOSE //数据库类型  oracle.install.db.config.starterdb.globalDBName=orcl  oracle.install.db.config.starterdb.SID=orcl  oracle.install.db.config.starterdb.memoryLimit=81920 //自动管理内存的内存(M)  oracle.install.db.config.starterdb.password.ALL=oracle//设定所有数据库用户使用同一个密码  SECURITY_UPDATES_VIA_MYORACLESUPPORT=false  DECLINE_SECURITY_UPDATES=true\n\n\n6、开始安装执行db_install.rsp文件这里要将修改过的执行文件带入，别写错\ncd /u01/oradb/database\n\n\n./runInstaller -ignoreSysPrereqs -ignorePrereq -waitforcompletion \\-showProgress -silent -responseFile /u01/oradb/etc/db_install.rsp#/home/oracle/database/response/db_install.rsp\n\n在安装快完成的时候会提示要切换到root用户执行两个脚本，这步跟着照做就是\nsu - root\n\n\n/u01/database/oracle/oraInventory/orainstRoot.sh/u01/database/oracle/oracle/product/12/db_1/root.sh\n\n\n\n7、修改oracle用户环境变量切换到oracle用户，打开并编辑用户编辑变量文件\nsu - oracle\n\nvim ~/.bash_profile\n\n按需求将以下内容加上\nexport ORACLE_BASE=/u01/database/oracle/oracleexport ORACLE_SID=orcl export ROACLE_PID=oral12#export NLS_LANG=AMERICAN_AMERICA.AL32UTF8export LD_LIBRARY_PATH=/lib:/usr/libexport ORACLE_HOME=/u01/database/oracle/oracle/product/12/db_1export PATH=:/binexport LANG=&quot;zh_CN.UTF-8&quot;export NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;export NLS_DATE_FORMAT=&#x27;yyyy-mm-dd hh24:mi:ss&#x27;\n\n\n使配置生效\nsource ~/.bash_profile\n\n配置监听\nnetca /silent /responsefile /u01/oradb/etc/netca.rsp\n\n\n启动监听\n$ lsnrctl start\n\n修改静默建库文件\nvim /u01/oradb/etc/dbca.rsp\n\n\n其中文件内容修改如下（根据实际情况修改）\nresponseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v12.2.0  gdbName=orcl  sid=orcl  databaseConfigType=SI  createAsContainerDatabase=true  numberOfPDBs=1  pdbName=orclpdb  templateName=/u01/database/oracle/oracle/product/12/db_1/assistants/dbca/templates/General_Purpose.dbc  emExpressPort=5500  omsPort=0  characterSet=AL32UTF8  listeners=LISTENER  memoryPercentage=40  automaticMemoryManagement=false  totalMemory=0\n\n执行静默建库\ndbca -silent -createDatabase  -responseFile  /u01/oradb/etc/dbca.rsp\n\n执行的口令是上面设定的密码：oracle\n等待安装完成后就可以正常登陆了\n8、登进数据库开启实例\nsqlplus / as sysdba\nSQL&gt;startup\n五、数据库启动与关闭\n概述：只有具备sysdba和sysoper系统特权的用户才能启动和关闭数据库。在启动数据库之前应该启动监听程序，否则就不能利用命令方式来管理数据库，包括启动和关闭数据库。虽然数据库正常运行，但如果没有启动监听程序，客户端就不能连接到数据库。\n1、启动Oracle数据库的完整启动过程包含以下3个步骤：简单地说，就是：启动实例–&gt;加载数据库–&gt;打开数据库.具体说明：1.创建并启动与数据库对应的实例。在启动实例时，将为实例创建一系列后台进程和服务进程，并且在内存中创建SGA区等内存结构。在实例启动的过程中只会使用到初始化参数文件，数据库是否存在对实例的启动没有影响。如果初化参数设置有误，实例将无法启动。2.为实例加载数据库。加载数据库时实例将打开数据库的控制文件，从控制文件中获取数据库名称、数据文件的位置和名称等有关数据库物理结构的信息，为打开数据库做好准备。如果控制文件损坏，则实例将无法加载数据库。在加载数据库阶段，实例并不会打开数据库的物理文件—-数据文件和重做日志文件。3.将数据库设置为打开状态。打开数据库时，实例将打开所有处于联机状态的数据文件和重做日志文件。控制文件中的任何一个数据文件或重做日志文件无法正常打开，数据库都将返回错误信息，这时需要进行数据库恢复。只有将数据库设置为打开状态后，数据库才处于正常状态，这时普通用户才能够访问数据库。在很多情况下，启动数据库时并不是直接完成上述3个步骤，而是逐步完成的，然后执行必要的管理操作，最后才使数据库进入正常运行状态。所以，才有了各种不同的启动模式用于不同的数据库维护操作。因为Oracle数据库启动过程中不同的阶段可以对数据库进行不同的维护操作，对应我们不同的需求，所以就需不同的模式启动数据库。\n各种模式详解：1.NoMount 模式（启动实例不加载数据库）命令：startup nomount讲解：这种启动模式只会创建实例，并不加载数据库，Oracle仅为实例创建各种内存结构和服务进程，不会打开任何数据文件。在NoMount模式下，只能访问那些与SGA区相关的数据字典视图，包括V$PARAMETER、V$SGA、V$PROCESS 和 V$SESSION等，这些视图中的信息都是从SGA区中获取的，与数据库无关。非安装启动，这种方式启动下可执行:重建控制文件、重建数据库、读取init.ora文件，启动instance，即启动SGA和后台进程，这种启动只需要init.ora文件。模式用途：(1)创建新数据库；(2)重建控制文件。\n2.Mount模式（加载数据库但不打开数据库）命令：startup mount讲解：这种启动模式将为实例加载数据库，但保持数据库为关闭状态。因为加载数据库时需要打开数据库控制文件，但数据文件和重做日志文件都都无法进行读写，所以用户还无法对数据库进行操作。 在Mount模式下，只能访问那些与控制文件相关的数据字典视图，包括\n\nV$THREAD、V$CONTROLFILE、V$DATABASE、V$DATAFILE 和 V$LOGFILE等，这些视图都是从控制文件中获取的。\n\n\n模式用途：(1)重命名数据文件；(2)添加、删除或重命名重做日志文件；(3)执行数据库完全恢复操作；(4)改变数据库的归档模式。\n3.Open模式（正常打开数据库）命令：startup [open]讲解：正常按3个步骤启动数据库。模式用途：平时不对数据库做什么维护，像只做应用开发，用这个模式就好了。\n4.强制启动模式命令：startup force用途&amp;讲解：在某些情况下，使用前面的各种模式都无法成功启动数据库时，可以尝试强制启动模式。使用Alter Database语句，还可以在各启动模式间切换。并且，还可以对数据库设置不同的状态用于不同的操作，如受&#x2F;非受限抽状态、只读。\n使用Alter Database语句，在各启动模式间切换。(1)从NoMount模式切换到Mount模式(没有从mount切换到nomount的)：命令：ALTER DATABASE MOUNT;(2)当数据库状态为关闭时，切换到Open模式命令：ALTER DATABASE OPEN;(3)在Open模式下，还可以选择将数据库设置为非受限状态和受限状态。命令：在启动Open模式时，添加restrict关键字：startup restrict设置或取消受限状态：alter system enable\\disable restricted session;讲解：非受限状态，就是我们平时应用程序开发用到的状态。受限状态，当打开的数据库被设置为受限状态时，只有Create Session 和 Restricted Session系统权限 或者 具有SYSDBA 和 SYSPORE 系统权限的用户才能连接到数据库。但进入受限状态后，系统中仍然可能会存在活动的普通用户会话。受限状态用途：(1)执行数据导入或导出操作；(2)暂时拒绝普通用户访问数据库；(3)进行数据库移植或升级操作。(4) 只读状态设置只读命令：alter database open read only;取消只读命令：alter database open read write;用途&amp;讲解：当一个正常打开的数据库被设置为只读状态时，用户只能查询数据，但不能以任何方式对数据库对象进行修改。处于只读状态，可能保证数据文件和重做日志文件中的内容不被修改，但是并不限制那些不会写入数据文件与重做日志文件的操作。\n2、关闭与数据库启动一样，关闭数据库与实例也分为3步：关闭数据库–&gt;实例卸载数据库—&gt;终止实例。详细步骤为：(1)关闭数据库，oracle将重做日志高速缓存中的内容写入重做日志文件，并且将数据库高速缓存中被改动过的数据写入数据文件，然后再关闭所有的数据文件和重做日志文件，这时数据库的控制文件仍然处于打开状态，但是由于数据库处于关闭状态，所以用户无法访问数据库。（2）卸载数据库，关闭数据库后，例程才能被卸载，控制文件再这个时候被关闭，但例程仍然存在 。（3）终止例程，进程终止，分配给例程的内存sga区被回收。\n1.Nomal（正常关闭方式）命令：shutdown nomal讲解：正常方式关闭数据时，Oracle执行如下操作：(1)阻止任何用户建立新的连接。(2)等待当前所有正在连接的用户主动断开连接（此方式下Oracle不会立即断掉当前用户的连接，这些用户仍然操作相关的操作）(3)一旦所有的用户都断开连接，则立即关闭、卸载数据库，并终止实例。（所以，一般以正常方式关闭数据库时，应该通知所有在线的用户尽快断开连接）2.Immediate（立即关闭方式）命令：shutdown immediate讲解：(1)阻止任何用户建立新的连接，同时阻止当前连接的用户开始任何新的事务。(2)Oracle不等待在线用户主动断开连接，强制终止用户的当前事务，将任何未提交的事务回退。（如果存在太多未提交的事务，此方式将会耗费很长时间终止和回退事务）(3)直接关闭、卸载数据库，并终止实例。3.Transactional（事务关闭方式）命令：shutdown transactional讲解：这种方式介于正常关闭方式跟立即关闭方式之间，响应时间会比较快，处理也将比较得当。执行过程如下：(1)阻止任何用户建立新的连接，同时阻止当前连接的用户开始任何新的事务。(2)等待所有未提交的活动事务提交完毕，然后立即断开用户的连接。(3)直接关闭、卸载数据库，并终止实例。4.Abort（终止关闭方式）命令：shutdown abort讲解：这是比较粗暴的一种关闭方式，当前面3种方式都无法关闭时，可以尝试使用终止方式来关闭数据库。但是以这种方式关闭数据库将会丢失一部份数据信息，当重新启动实例并打开数据库时，后台进程SMON会执行实例恢复操作。一般情况下，应当尽量避免使用这种方式来关闭数据库。执行过程如下：(1)阻止任何用户建立新的连接，同时阻止当前连接的用户开始任何新的事务。(2)立即终止当前正在执行的SQL语句。(3)任何未提交的事务均不被退名。(4)直接断开所有用户的连接，关闭、卸载数据库，并终止实例。\n\n六、sqlplus改进（退格不能用的情况下）\n概述：在默认的sqlplus的使用过程中发现是比较难用的，最好的例子就是不能用退格键以及掉出历史命令的上下键，这里介绍退格键的改进，至于掉出历史命令的上下键可参考文末的文章\n\n切换至oracle用户\nsu - oracle\n\n打开并编辑用户环境变量配置文件\nvim ~/.bash_profile\n\n在文件末尾加上以下代码并保存退出\nstty erase ^h\n\n\n使配置文件生效\nsource ~/.bash_profile\n\n此时再进入sqlplus测试发现，退格键已经能用了\n七、navicat远程数据库遇到的问题及解决方案一般数据库是安装在远程服务器上，然后用本机的管理软件去连接，此时需要配置一下在oracle用户下，打开并编辑listener.ora文件（一般在安装目录下）\nvim /u01/database/oracle/oracle/product/12/db_1/network/admin/listener.ora\n\n然后将其中的HOST改为服务器的IP（这里为了保留之前的配置所以直接在文件后面复制了上面的配置然后作修改）\n\n保存退出打开并编辑tnsnames.ora文件\nvim /u01/database/oracle/oracle/product/12/db_1/network/admin/tnsnames.ora\n\n跟上面操作一样，将HOST改为服务器的IP\n保存退出然后重启数据库实例和数据库监听，此时可以用navicat来连接数据库了\n可能会遇到的错误：1、\n\nORA-12170:TNS:连接超时检查步骤及解决方法：（1）从本机ping服务器IP是否能ping通（2）使用tnsping或者telnet测试端口是否通畅（3）服务器防火墙是否已关闭（4）服务器selinux是否已关闭（5）数据库监听是否开启（6）如果是用PL&#x2F;SQL的话，tns配置中，host是否为服务器的IP\n\n2、\n\nORA-28040:No matching authentication protocol错误原因是因为navicat的oci.dll版本不匹配，通常是因为版本过低，即低版本的oci.dll连接高版本的数据\n\n\nLinux7安装 Oracle 11g时，Install Product 86%时出现报错  Error in invoking target ‘agent nmhs’ of makefile\n解决方案在makefile中添加链接libnnz11库的参数修改$ORACLE_HOME/sysman/lib/ins_emagent.mk，将$(MK_EMAGENT_NMECTL)修改为：$(MK_EMAGENT_NMECTL) -lnnz11建议修改前备份原始文件[oracle@ysserver ~]$ cd $ORACLE_HOME/sysman/lib[oracle@ysserver lib]$ cp ins_emagent.mk ins_emagent.mk.bak[oracle@ysserver lib]$ vi ins_emagent.mk进入vi编辑器后  命令模式输入/NMECTL 进行查找，快速定位要修改的行在后面追加参数-lnnz11        第一个是字母l   后面两个是数字1\n","categories":["软件教程"],"tags":["技术","linux","oracle","心得"]},{"title":"关于BI","url":"/2021/03/06/BI%E5%85%A5%E9%97%A8/","content":"关于BI\nBI（Business Intelligence）即商务智能，它是一套完整的解决方案，用来将企业中现有的数据进行有效的整合，快速准确地提供报表并提出决策依据，帮助企业做出明智的业务经营决策。\n\n目标实现基于Mysql或者Oracle数据库，使用Kettle、帆软FineBi实现数据可视化。\n\n比如：\n\n使用Mysql作为数据分析的存储以及查询引擎、以Kettle作为数据处理脚本执行工具、以及帆软FineBi实现数据可视化展示\n\ngraph LRweb页面--&gt;业务数据库-mysql/oracle业务数据库-mysql/oracle--&gt;数据预处理-Kettle--&gt;数据仓库mysql数据仓库mysql--&gt;Bi平台-帆软\n案例架构流程\n&gt; 业务订单数据  - mysql数据库：itcast_shop  - 用于对外支撑业务：下订单、查询订单&gt; 数据预处理-Kettle  - Kettle:过滤、转换、补全&gt; 待分析的数据  - mysql数据库：itcast_shop_bi  - 用于实现数据分析：订单分析&gt; 分析的结果  - mysql实现分析：itcast_shop_bi  - FineBi: 实现可视化报表构建\n","categories":["技术"],"tags":["技术","心得","BI"]},{"title":"ArchLinux-kde和gnome桌面系统基础安装","url":"/2018/03/06/ArchLinux-kde%E5%92%8Cgnome%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85/","content":"ArchLinux安装图文教程一．安装Arch linux前的准备1.下载VMware安装包及Arch Linux镜像https://www.vmware.com/cn/products/workstation-pro.html\n（注意：VMware workstation11、12仅支持64位操作系统，而VMware workstation10同时支持32和64位操作系统）\n2. 打开软件，选择“创建虚拟机”按钮选处理器核心数量为2个\n\n然后一直下一步\n\n点下一步直至完成\n编辑虚拟机设置，选择ISO文件\n\n开启虚拟机\n\n3.默认选中第一个\n二. 现在开始分区\n 输入以下命令：\n# fdisk /dev/sda\n\n\n创建分区表：\n· Command (m for help): 输入 o 并按下 Enter\n然后建立第一个分区：\n1. Command (m for help): 输入 n 并按下 Enter 2. Partition type: Select (default p): 按下 Enter 3. Partition number (1-4, default 1): 按下 Enter 4. First sector (2048-209715199, default 2048): 按下 Enter 5. Last sector, +sectors or +size&#123;K,M,G (2048-209715199....., default 209715199): 输入 +15G 并按下 Enter &#125;\n\n\n \n然后建立第二个分区：\n1. Command (m for help): 输入 n 并按下 Enter 2. Partition type: Select (default p): 按下 Enter 3. Partition number (1-4, default 2): 按下 Enter 4. First sector (31459328-209715199, default 31459328): 按下 Enter 5. Last sector, +sectors or +size&#123;K,M,G (31459328-209715199....., default 209715199): 按下 Enter 现在预览下新的分区表:· Command (m for help): 输入 p 并按下 Enter Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x5698d902Device Boot   Start     End   Blocks  Id  System/dev/sda1      2048   31459327  15728640  83  Linux/dev/sda2    31459328  209715199  89127936  83  Linux&#125;\n\n\n然后向磁盘写入这些改动：\n\n· Command (m for help): 输入 w 并按下 Enter \n\n如果一切顺利无错误的话，fdisk 程序将显示如下信息:\n\nThe partition table has been altered!\nCalling ioctl() to re-read partition table.\nSyncing disks.\n若因 fdisk 遇到错误导致以上操作无法完成，可以用 q 命令来退出。\n（当然你也可以分多个分区，分别挂载&#x2F;boot,&#x2F;home&#x2F;,&#x2F;,&#x2F;var等）\n3、接下来格式化成ext4文件系统\n# mkfs.ext4 /dev/sda1# mkfs.ext4 /dev/sda2\n\n\n\n若您分了一个 swap 区，也不要忘了格式化并启用它（x代表你的那个分区数字）：\n# mkswap /dev/sdaX# swapon /dev/sdaX\n\n\n注意要按照顺序挂载，先挂载根分区到 &#x2F;mnt （你实际所要挂载的分区名当然可能会不同）：\n# mount /dev/sda1 /mnt\n然后挂载 &#x2F;home 分区（以及其它其余单独分区，比如 &#x2F;boot，&#x2F;var，如果您有的话）：\n\n# mkdir /mnt/home# mount /dev/sda2 /mnt/home\n\n\n（如果有其他分区，先创建目录，再挂载）\n（三）安装基本系统\n重申一遍，这里及以后一些步骤必须联网，尤其是运行pacman命令时。关于联网问题请参照archwiki,里面有十分详细的解说。\n先进行网络设置，在上面的livecd中一般会自动联网,但虚拟机如果这里不配置，后面无法下载安装操作\n# ip link\n\n\n找到网络设备，我的是ens33\n# ip link set ens33 up# dhcpcd ens33# systemctl enable dhcpcd@ens33.service \n\n以后系统就会自动联网了\n后面如果遇到重启步骤，还需要配置下\n对于无线还未尝试，可以看archwiki。\nhttps://wiki.archlinux.org/index.php/Installation_guide_(简体中文)\n1、安装前需要编辑文件&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist, 你的系统和软件将从这里的地址下载。将偏好的镜像放到最前面，下面加入了一个比较快的源，当然你可以去网上搜其他比较好的源：\n# nano /etc/pacman.d/mirrorlist#### Arch Linux repository mirrorlist## Sorted by mirror score from mirror status page## Generated on 2012-MM-DD##Server = http://mirror.bjtu.edu.cn/archlinux//os/...\n\n\n如果您愿意，您可以只使用一个镜像并全删光其他行，但为保险，还是留其他几个离您较近的镜像作备用好\n然后敲入：\n# pacman -Syy      刷新列表# pacstrap -i /mnt base   安装基本系统\n\n\n\n若运行 pacstrap 时卡住并出现failed retrieving file ‘core.db’ from mirror… : Connection time-out字样，请检查刚才的源是否正确或去网上搜索其他能用的源。\n\n一直回车这这个界面\n2、生成fstab分区表\n# genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab\n\n\n\n3、下面要 chroot 到新系统开始配置：\n# arch-chroot /mnt /bin/bash\n\n\n\n4、系统本地化，设置本地语言，地点等信息\n# nano /etc/locale.gen\n\n\n去掉#\nen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8\n\n接着执行locale-gen以生成locale讯息：\n# locale-gen\n\n\n（创建 locale.conf 并提交您的本地化选项：\n\n# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf\n\n\n&#x2F;这里先不要设置中文编码，等安装了图形界面再修改，否则会乱码）&#x2F;\n5、设置时区，一般以上海就行：\n# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \n\n6、设置时间\n# hwclock --systohc --utc\n\n\n7、设置个您喜欢的主机名，例如：\n# echo longz &gt; /etc/hostname\n\n\n\n并在 &#x2F;etc&#x2F;hosts 添加同样的主机名：\n# nano /etc/hosts# /etc/hosts: static lookup table for host names#&lt;ip-address&gt; &lt;hostname.domain.org&gt; &lt;hostname&gt;127.0.0.1   localhost.localdomain  localhost 主机名  ::1      localhost.localdomain  localhost# End of file\n\n\n8、设置root密码\n# passwd \n\n输入两次密码:简单点123456\n\n\n9、安装启动引导器grub:\n安装 grub 包，并执行 grub-install 已安装到 MBR:\n# pacman -S grub\n\n\n# grub-install --target=i386-pc --recheck /dev/sda\n\n\n\n# grub-mkconfig -o /boot/grub/grub.cfg\n\n\n\n须根据实际分区自行调整 &#x2F;dev&#x2F;sda, 切勿在块设备后附加数字，\n\n比如 dev&#x2F;sda1 就不对\n\n添加新用户\n# useradd -m -g users -s /bin/bash 用户名\n\n\n（务必添加一个 用户 ，否则后面sddm显示管理器登录的时候无法登录，sddm不会列出root用户） \n为刚才添加的用户设置密码执行：# passwd 用户名 \n\n# nano /etc/sudoers\n\n\n在 root ALL&#x3D;(ALL) ALL 下面添加用户名 ALL=(ALL) ALL \n为你刚才创建的用户 添加sudo权限\n10、卸载分区并重启系统\n离开 chroot 环境：\n# exit\n\n\n重启计算机：\n# reboot\n\n\n好了，一个最基本的字符系统建好了，接下来可以选择安装桌面等图形环境了。\n\n进入系统后首先更新软件包，但先检查下网络，虚拟机尽量再配置下\n\n找到网络设备，我的是ens33\n# ip link set ens33 up# dhcpcd ens33# systemctl enable dhcpcd@ens33.service\n 以后系统就会自动联网了\n（1）安装显卡驱动\n确定显卡型号执行:\n# lspci | grep VGA\n\n\n执行：\n# pacman -S 驱动包:\n官方仓库提供的驱动包: \n\n通用虚拟机———————————-pacman -S xf86-video-vesaintel———————————pacman -S xf86-video-intel \n\n# pacman -S xf86-video-nouveau # Nvidia# pacman -S nouveau-dri# pacman -S xf86-video-ati # Ati\n\nGeforce7+(显卡型号)————————–pacman -S xf86-video-nouveauGeforce6&#x2F;7（显卡型号）————————-pacman -S xf86-video-304xx\n安装声卡驱动键入 \n# pacman -S alsa-utils\n\n\n（2）安装X窗口系统执行：\n# pacman -S xorg\n\n\n安装X窗口系统执行：\n# pacman -S xf86-input-synaptics （触摸板驱动，笔记版可装，台式机就不用了）执行\n# pacman -S ttf-dejavu wqy-microhei\n\n\n安装字体：Dejavu 和 微米黑字体（不安装的话 后面进入桌面环境设置系统语言为简体中文的时候会出现字体显示不全的问题）安装字体：Dejavu 和 微米黑字体\n（3）安装kde-plasma桌面环境安装　Gnome桌面环境的直接跳到第(4)步（kde和gnome桌面环境自带了大部分的驱动 ，安装其他桌面环境可能需要额外配置一些驱动，比如声卡）想安装其他桌面环境 参照官方wiki：官方wiki执行：\n# pacman -S plasma\n\n\n安装plasma执行：\n# pacman -S konsole\n\n\n安装 kde下的控制台终端执行：\n# pacman -S dolphin\n\n\n安装kde下的文件管理器（可以直接执行:\n# pacman -S kde-applications\n\n\n安装kde套件，包含了常用的系统工具）安装完后执行：\n# systemctl enable sddm\n\n\n启用 sddm显示管理器执行：\nsystemctl enable NetworkManager启用网络管理执行:\n# pacman -S plasma-nm\n\n\n安装 网络管理的前端工具（图形界面）执行：\n# reboot\n\n\n重启\n进入系统后界面如下：（4）安装Gnome桌面环境执行：\n# pacman -S gnome\n\n\n安装gnome桌面执行：\n# pacman -S gnome-tweak-tool\n\n\n安装gnome桌面优化工具执行：\n# pacman -S alacarte\n\n\n安装gnome桌面菜单编辑器执行：\n# systemctl enable gdm\n\n\n启用gnome窗口管理器服务执行：\n    # systemctl enable NetworkManager\n启用网络管理器服务执行：\n # reboot\n13.安装完后的工作 （1）添加archlinuxcn源（里面包含了很多中国人常用而官方仓库又没有的软件）\n（2）安装中文输入法执行：\n# pacman -S fcitx-im fcitx-configtool\n\n\n执行：\n# nano /etc/pacman.conf\n\n\n在 &#x2F;etc&#x2F;pacman.conf 文件末尾添加两行：\n[archlinuxcn]SigLevel=NeverServer = https://mirrors.ustc.edu.cn/archlinuxcn/\n\n\n安装输入法引擎 \n\n（官方仓库里的输入法：fcitx-cloudpinyinfcitx-googlepinyinfcitx-libpinyinfcitx-sunpinyin） \n\n执行：\n# nano ~/.xprofile\n\n\n添加一下内容\nexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;\n\n\n执行：\n# pacman -S fcitx-sogoupinyin\n\n\n安装搜狗输入法\n（3）安装网易云音乐\n执行：\n# pacman -S netease-cloud-music\n\n\n安装网易云音乐\n （4）安装yaourt使用aur\n执行：\n# pacman -S yaourt\n\n\n安装yarourt以后可以使用yaourt 安装aur中的软件了 ，yaourt跟pacman使用方法一样安装kde下的文件管理器（5）安装浏览器执行：\n# pacman -S google-chrome\n\n\n安装google浏览器（没法在线观看视频）执行：\n# pacman -S firefox\n\n\n安装火狐浏览器（执行: # pacman -S flashplugin 安装flas插件，否则无法在线观看视频，chrome浏览器不支持flash）\n（6）其他常用软件\n可在官方文档中查找进行查找\n\n（7）桌面美化 \nKde-Plasma桌面：\n\nGnome桌面：\n\n可自行安装一些主题，请自己探索。\n","categories":["软件教程"],"tags":["技术","心得"]},{"title":"虚拟机环境下安装CentOs7系统","url":"/2021/06/11/CentOs%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","content":"1.创建虚拟机环境1.1 虚拟机选择新建，选择（自定义）高级\n1.2 虚拟机硬解选择默认即可\n1.3 虚拟机系统选择稍后安装\n1.4 根据你要安装的系统镜像来选择对应的系统版本\n1.5 选择安装位置和安装文件夹名称\n1.6 选择系统内核，给两个就行\n1.7 内存大小，这里我给了4个G\n1.7 网络环境根据需要选择，如果仅仅是内网，仅主机就行，要连外网选择net，如果不知道配置又需要外网，选择桥接就行（桥接的ip会和本机ip一致）\n1.8 控制器默认选择推荐的\n1.9 磁盘类型选择SCSI\n1.10 创建新的虚拟磁盘\n1.11 磁盘容量看着给，如果需要性能则选择单文件存储\n1.12 编辑虚拟机设置，选择要安装的ISO镜像\n2. 安装Linux_Centos系统2.1 开机后，选择语言\n2.2 选择安装位置\n2.3 选择本地磁盘，选择我要配置分区，点完成\n2.4 根据自己的要求来分配存储空间，swap空间给2G，多余的都给根目录\n2.4.1 Linux swap分区及作用详解\n我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。\n\n使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。\n\n相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。\n\n具体使用多大的 swap 分区，取决于物理内存大小和硬盘的容量。一般来讲，swap 分区容量应大于物理内存大小，建议是内存的两倍，但不超过 2GB。但是，有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。\n2.5 在软件选择的地方点修改最小安装设置，选择带桌面的环境\n2.6 确认选择无误后，点开始安装\n2.7 设置root密码\n在安装过程中可以点设置root密码，设置好后，等待系统安装完成，点重新启动\n\n\n2.8 重启好后，选择接受协议，然后点完成配置\n3. linux相关设置3.1 开始页面选择语言，点前进\n3.2 选择键盘布局和输入方式，默认即可，选择前进\n3.3 隐私，默认开启，推荐关闭，选择前进\n3.4 时区，输入shanghai，选择前进\n3.5 在线账号，选择跳过\n3.6 这里用户名称根据自己需要来填写，我这里主要用于mysql，选择前进\n3.7 设置刚刚用户的密码\n3.8 配置完成，正式进入桌面\n3.9 配置网络\n进入桌面后，比如我们想看下能不能连上外网，发现无法ping通\n\n\n\n输入以下命令查看网络配置，这时候是系统自动配置的网络，我们可以不用管它，可以直接清空\n\ncat /etc/sysconfig/network-scripts/ifcfg-ens33\n\n\n\n查看虚拟机网络，发现net网络的ip地址范围为192.168.217.3~254是我们可以使用的\n\n查看虚拟机的net网络的mac地址\nnano /etc/sysconfig/network-scripts/ifcfg-ens33\n修改网络配置文件 \nDEVICE=ens33HWADDR=00:0C:29:A0:FA:EBTYPE=EthernetUUID=82a26540-5b06-4ad2-b833-ad4ade0def20ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.217.133NETMARK=255.255.255.0GATEWAY=192.168.217.2DNS1=192.168.217.2\n然后重启网络设置\nservice network restart\n\n查看网络信息 ifconfig试试ping下网络，发现正常ping www.baidu.com\n\n# \n至此，Centos的系统安装到此结束，谢谢观看！\n\n\n如果小伙伴们有相关疑问，可以评论栏中留言提出。\n\n","categories":["软件教程"],"tags":["技术","linux","心得"]},{"title":"centos7系统安装mysql8.0完整步骤","url":"/2019/07/06/Centos7%E5%AE%89%E8%A3%85mysql-8.0/","content":"centos7系统安装mysql8.0完整步骤\n官网下载安装包官网地址\n\n选择版本及下载 https://dev.mysql.com/downloads/mysql/\n选择下载 MySQL 的 Linux 系统版本\nSelect Operating System: 选择 Red Hat ，CentOS 是基于红帽的，Select OS Version: 选择 linux 7\n选择要下载的 MySQL 版本\n这里选择 RPM Bundle(x86) 点击 Download 下载\n正式安装通过shell上传到centos7 rpm -qa | grep mariadb 命令查看 mariadb 的安装包\n[root@orc tmp]# rpm -qa | grep mariadbmariadb-libs-5.5.56-2.el7.x86_64\n\n卸载 mariadb\nmariadb 这个是 Linux 系统自带的数据库系统，跟 MySQL 冲突，所以一般先卸载这个没用的数据库。\n# 卸载 mariadb 命令rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps 命令装卸 mariadb# 再次确认是否卸载干净。rpm -qa | grep mariadb\n\n创建MySQL 安装目录安装目录创建在 &#x2F;use&#x2F;local 下\n\n通过 cd /usr/local/ 命令进入根目录下的usr目录下的local目录，这个目录是放一些本地的共享资源的\n\n通过 ll 命令查看一下当前目录下的目录结构\n\n\n创建 MySQL 目录\n#命令 在当前目录下创建一个名为 mysql 的目录mkdir mysql\n\n\n通过 ll 命令查看一下当前目录下的目录结构，刚创建的 mysql 目录有了\n\n通过 cd mysql 命令进入 mysql 目录\n\nftp 协议来把刚下载好的 mysql 安装包传输到 CentOS7 系统中\n\n\n解压 MySQL 安装包#命令解压 tar 包tar -xvf mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar注意，命令中的 mysql-8.0.xx-xxxxxx 需要替换成自己下载下来的版本号为准。\n\n安装及初始化\n注意，MySQL 的安装需要有准确的顺序，上图解压出来的红框的大部分都需要安装，所以安装顺序很重要。\n\n开始安装 MySQL安装顺序：COMMON  –&gt;  LIB  –&gt;  LIB-COMPAT  –&gt;  CLIENT  –&gt; SERVER\n按以上顺序以此安装\n1.安装 mysql-community-common\n# 命令安装 commonrpm -ivh mysql-community-common-8.0.32-1.el7.x86_64.rpm --nodeps --force\n\n2.安装 mysql-community-libs\n# 命令安装 libsrpm -ivh mysql-community-libs-8.0.32-1.el7.x86_64.rpm --nodeps --force# 命令安装 libs-compatrpm -ivh mysql-community-libs-compat-8.0.32-1.el7.x86_64.rpm  --nodeps --force\n\n3.安装mysql-community-client\n# 命令安装 clientrpm -ivh mysql-community-client-8.0.32-1.el7.x86_64.rpm  --nodeps --force\n\n4.安装mysql-community-server\n# 命令安装 serverrpm -ivh mysql-community-server-8.0.32-1.el7.x86_64.rpm  --nodeps --force\n\n安装完成后, 通过 rpm -qa | grep mysql 命令查看 mysql 的安装包\n[root@orc mysql]# rpm -qa | grep mysqlmysql-community-common-8.0.32-1.el7.x86_64mysql-community-libs-compat-8.0.32-1.el7.x86_64mysql-community-client-8.0.32-1.el7.x86_64mysql-community-server-8.0.32-1.el7.x86_64mysql-community-libs-8.0.32-1.el7.x86_64\n\n初始化 MySQL完成对 mysql 数据库的初始化和相关配置mysqld --initialize;chown mysql:mysql /var/lib/mysql -R;systemctl start mysqld.service;systemctl enable mysqld;\n\n查看数据库默认随记密码通过命令查看数据库的密码\ncat /var/log/mysqld.log | grep password\n\n登录 MySQL\n通过敲回车键进入数据库登陆界面\n\nmysql -uroot -p\n\n\n输入刚刚查到的密码，进行数据库的登陆，复制粘贴就行，MySQL 的登陆密码也是不显示的\n\n修改 MySQL 密码\n通过 sql 命令来修改密码 ,注意是在MySQL登录状态下\n\nALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;root&#x27;;\n\n\n通过 exit; 命令退出 MySQL，然后通过新密码再次登陆\n\n授权远程访问\n通过以下 sql 命令，进行远程访问的授权\n\ncreate user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;root&#x27;;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;flush privileges;\n\n修改加密规则部分可视化工具，不支持最新版本 mysql 8.0 加密规则，导致无法链接，可以修改下。\n\n1.通过一下 sql 命令修改加密规则\n2.flush privileges; 命令刷新修该后的权限\n\nALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27; PASSWORD EXPIRE NEVER;flush privileges; \n\n设置密码永不过期mysql8 数据库，密码默认有期限，可以设置成永不过期\n# 修改root密码永不过期，输入命令：# alter user &#x27;root&#x27;@&#x27;localhost&#x27; password expire never;alter user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root123&#x27; password expire never;\n\n防火墙配置关闭防火墙\n通过以下命令，关闭 firewall\n\nsystemctl stop firewalld.service;systemctl disable firewalld.service;systemctl mask firewalld.service;\n\n安装防火墙\n通过 yum -y install iptables-services  命令安装 iptables 防火墙\n\n通过以下命令启动设置防火墙\n\n\nsystemctl enable iptables;systemctl start iptables;\n\n\n通过 vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables 命令编辑防火墙，添加端口\n\n点击 i 键进入插入模式\n\n在相关位置，写入以下内容\n\n\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8090 -j ACCEPT\n\n\n输入 wq 敲回车键保存退出，: 为英文状态下的\n\n通过 systemctl enable iptables.service 命令设置防火墙开机启动\n\n\n验证数据库链接通过 ifconfig 命令查看 ip使用navicat来连接数据库\n在CentOS7下查看并修改MySQL数据存放目录查看数据存放目录# 使用命令SHOW VARIABLES LIKE &#x27;%datadir%&#x27;;# 或者SELECT @@datadir;\n\n得到默认存放目录：/var/lib/mysql\n移动数据停止mysql服务systemctl stop mysqld\n\n新建数据存放目录mkdir -p /u01/mysql/data\n\n复制数据将mysql目录复制到&#x2F;data01&#x2F;mysql&#x2F;data目录下\ncp -a /var/lib/mysql /u01/mysql/data\n\n 给目录添加权限\nchown -R mysql:mysql /u01/mysql/data/mysql chown -R mysql:mysql /u01/mysql/data\n\n修改配置my.cnf打开&#x2F;etc&#x2F;my.cnf文件， 找到[mysqld]关键字，修改datadir和socket的值\n[mysqld]datadir=/u01/mysql/data/mysqlsocket=/u01/mysql/data/mysql/mysql.sock\n\n重启mysql服务systemctl start mysqld\n\n问题错误现象重启后，项目可正常访问数据库，但是使用命令行访问数据库会报错:\nmysql -uroot -p......Can&#x27;t connect to local MySQL server through socket &#x27;/var/lib/mysql&#x27;......\n\n解决修改&#x2F;etc&#x2F;my.cnf， 找到[client]段，添加配置\n\nsocket字段有可能不存在，添加即可。\n\n[client]default-character-set=utf8mb4port=3306socket=/u01/mysql/data/mysql/mysql.sock\n\n","categories":["mysql"],"tags":["心得","mysql"]},{"title":"Centos7安装mysql5.7","url":"/2021/11/02/Centos%E5%AE%89%E8%A3%85mysql5.7/","content":"1、在安装之前，如果你的系统曾经安装过Mariadb，请先卸载：yum remove mariadb*\n\n2、安装依赖yum install -y epel-releaseyum update -yyum install -y cmake gcc-c++ ncurses-devel perl-Data-Dumper boost-doc boost-devel libaio-devel\n\n3、下载解压MySQL源码包cd /opt/\n\n\nwget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz\n\n或者通过以下链接下载上传https://kdy.zhongshenglong.xyz:163/#s/8NA6ajaA\n\ntar -zxf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz mv mysql-5.7.20-linux-glibc2.12-x86_64 mysql\n\n4、配置环境变量vim /etc/profile\n\n\n#添加如下内容export PATH=/opt/mysql/bin:$PATH\n然后source生效\nsource /etc/profile\n\n5、添加用户并授权相关useradd mysqlid mysqlmkdir /u01/data/mysql -pmkdir /var/log/mariadbtouch /var/log/mariadb/mariadb.logchown -R mysql:mysql /opt/mysql/*chown -R mysql:mysql /u01/data/*chown -R mysql:mysql /var/log/mariadb/\n\n其中：\n\n&#x2F;opt&#x2F;mysql&#x2F; 是MySQL软件所在目录。&#x2F;u01&#x2F;data&#x2F;mysql 是将来存放MySQL数据的目录。\n\n6、初始化数据库mysqld --initialize-insecure  --user=mysql --basedir=/opt/mysql --datadir=/u01/data/mysql\n\n上述参数，并不难理解：\n\n–initialize-insecure，表示不安全的初始化。这个参数来自于–initialize参数，在MySQL5.7版本中，在初始化成功后，会生成一个临时密码，相对比较麻烦，所以这里改为–initialize-insecure，初始化成功后，密码为空。\n–user&#x3D;mysql，管理MySQL的用户是mysql。\n–basedir&#x3D;&#x2F;opt&#x2F;mysql，是你MySQL的安装目录。\n–datadir&#x3D;&#x2F;u01&#x2F;data&#x2F;mysql，是管理数据的目录。\n\n7、在初始化完成后，你的MySQL的数据目录，应该有这些文件：\n配置文件vim /etc/my.cnf\n\n\n[mysqld]　user=mysql　basedir=/opt/mysql　datadir=/u01/data/mysql　server_id=6　port=3306　socket=/tmp/mysql.sock　[mysql]　socket=/tmp/mysql.sock　prompt=3306 [\\\\d]&gt;\n\n8、管理MySQL_etc&#x2F;init.dcp /opt/mysql/support-files/mysql.server /etc/init.d/mysqld\n\n9、启动、重启命令service mysqld startservice mysqld restart\n\n\n10、如果设置密码不成功，可绕过密码登录，重新设置/etc/init.d/mysqld stopmysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;\nupdate mysql.user set authentication_string=PASSWORD(&quot;123456&quot;) where user=&#x27;root&#x27;and host=&#x27;localhost&#x27;;flush privileges;/etc/init.d/mysqld restartmysql -uroot -p成功！！\n\n\ncentos8 安装mysql5.7 后，mysql命令登录不成功，报错：mysql: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory。按照百度的方法都不成功，应该和系统版本有关，后来自己想到一个方法：yum install libncurses*，完美解决问题。\n\n","categories":["技术"],"tags":["技术","linux","心得","mysql"]},{"title":"Docker修改容器配置导致启动失败的解决方法","url":"/2022/08/06/Docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"Docker修改容器配置导致启动失败的解决方法我们通常会遇到修改容器内的配置问题，改的是容易。但改完之后容器起不来了，那就可难受了。当然我们也可以重新构建容器，一切都重新来一遍。但这真的是得不偿失，一个小小的配置，弄这么大的动静。还有一种就是把修改容器的配置，然后重启容器。当然之前的配置导致容器是起不来的，我们没有办法进入到容器中去。所以我们就直接将容器内的配置复制到我们的本地，在本地完成修改后再复制到容器，最后重启容器使容器能够正常的运行\n1.查看容器的错误日志docker logs ca8df11e264b -f\n\n容器无法正常启动时，我们是无法直接进入容器的，我们不能确定配置文件的绝对位置，有日志的话我们可以查到配置文件的具体位置\n2.复制配置文件到本地docker container cp ca8df11e264b:/etc/mysql/my.cnf /volume1/docker/mysql/\n\n3. 在本地修改配置4. 将配置再复制到容器docker cp /volume1/docker/mysql/my.cnf ca8df11e264b:/etc/mysql/my.cnf\n\n5. 重启容器docker restart ca8df11e264b\n\n","categories":["技术"],"tags":["技术","心得","docker"]},{"title":"EMOJI表情插入MYSQL数据库异常记录报错以及处理方式","url":"/2022/07/06/EMOJI%E8%A1%A8%E6%83%85%E6%8F%92%E5%85%A5MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E5%B8%B8%E8%AE%B0%E5%BD%95%E6%8A%A5%E9%94%99%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","content":"EMOJI表情插入MYSQL数据库异常记录报错以及处理方式\n这个问题是由于数据库中字符集编码一般我们用utf8，utf8存储一般为2到3字节，但是emoji是四个字节导致插入错误,所以我们要更改字符集为utf8mb4mysql的版本必须为5.5.3以上\n\n1.先登录MYSQL，查看当前数据库的编码格式show variables like &#x27;char%&#x27;;\n\n\n\n\nVariable_name\nValue\n\n\n\ncharacter_set_client\nutf8mb3\n\n\ncharacter_set_connection\nutf8mb3\n\n\ncharacter_set_database\nutf8mb3\n\n\ncharacter_set_filesystem\nbinary\n\n\ncharacter_set_results\nutf8mb3\n\n\ncharacter_set_server\nutf8mb3\n\n\ncharacter_set_system\nutf8\n\n\ncharacter_sets_dir\n&#x2F;usr&#x2F;share&#x2F;mysql-8.0&#x2F;charsets&#x2F;\n\n\n我们看到并不是utf8mb4\n2.在查看排序规则show variables like &#x27;collation_%&#x27;\n\n\n\nVariable_name\nValue\n\n\n\ncollation_connection\nutf8_general_ci\n\n\ncollation_database\nlatin1_swedish_ci\n\n\ncollation_server\nlatin1_swedish_ci\n\n\n也不是,这时候开始修改\n3.修改MYSQL配置文件 MY.CNF找不到可以用以下代码，文件一般在etc/mysql/my.cnf\nmysql --help | grep my.cnf\n加入\n[mysqld] character-set-server=utf8mb4[mysql] default-character-set=utf8mb4\n\n4.重启MYSQLsudo service mysql restart\n\n5.回到第一步看下字符集是否更改否则，再MYSQL里面运行以下设置代码set character_set_client = utf8mb4;set character_set_connection = utf8mb4;set character_set_database = utf8mb4;set character_set_results = utf8mb4;set character_set_server = utf8mb4;\n\n6.再次查看show variables like &#x27;char%&#x27;;\n\n\n\n\n\nVariable_name\nValue\n\n\n\ncharacter_set_client\nutf8mb4\n\n\ncharacter_set_connection\nutf8mb4\n\n\ncharacter_set_database\nutf8mb4\n\n\ncharacter_set_filesystem\nbinary\n\n\ncharacter_set_results\nutf8mb4\n\n\ncharacter_set_server\nutf8mb4\n\n\ncharacter_set_system\nutf8\n\n\ncharacter_sets_dir\n&#x2F;usr&#x2F;share&#x2F;mysql-8.0&#x2F;charsets&#x2F;\n\n\n\n\n\nVariable_name\nValue\n\n\n\ncollation_connection\nutf8mb4_0900_ai_ci\n\n\ncollation_database\nutf8mb4_0900_ai_ci\n\n\ncollation_server\nutf8mb4_0900_ai_ci\n\n\n修改表及字段字符集同样的，对于已经创建的表，修改全局及数据库的字符集并不会影响原表及字段的字符集。原有的 utf8 表可以采用如下方法修改：\n#修改数据库字符集alter database db_new charset utf8mb4;# 修改某字段字符集alter table `tb_name` default character set utf8mb4;# 同时修改表及字段字符集alter table `tb_name` modify col_name varchar(20) character set utf8mb4;# 如果某个库里面表比较多 可以拼接出要执行的批量修改语句alter table `tb_name` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\n查看字符集1、查看数据库支持的字符集：\nselect * from information_schema.character_sets;\n2、查看数据库支持的检验规则：\nselect * from information_schema.collations;\n3、查看表字符集及检验规则：\nshow create table tb_name\nselect * from information_schema.tables where table_name&#x3D;tb_name\nMySQL几种编码格式的区别（utf8、utf8mb4、utf8mb4_general_ci、utf8mb4_unicode_ci 、utf8mb4_0900_ai_ci）存储字符集 utf8 和 utf8mb4\nutf8 是 Mysql 中的一种字符集，只支持最长三个字节的 UTF-8 字符，也就是 Unicode 中的基本多文本平面。要在 Mysql 中保存 4 字节长度的 UTF-8 字符，需要使用 utf8mb4 字符集，但只有 5.5.3 版本以后的才支持。我觉得，为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. 对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR 替代 CHAR。\n\n如果数据库默认字符集不是 utf8mb4，那么可以在创建数据库时指定字符集：\nCREATE DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n查看编码格式\nshow variables like &quot;%char%&quot;;\n\nMySQL 配置文件中字符集相关变量\ncharacter_set_client：客户端请求数据的字符集\ncharacter_set_connection：从客户端接收到数据，然后传输的字符集\ncharacter_set_database：默认数据库的字符集，无论默认数据库如何改变，都是这个字符集；如果没有默认数据库，那就使用 character_set_server 指定的字符集，这个变量建议由系统自己管理，不要人为定义。\ncharacter_set_filesystem：把操作系统上的文件名转化成此字符集，即把 character_set_client 转换 character_set_filesystem， 默认 binary 是不做任何转换的\ncharacter_set_results：结果集的字符集\ncharacter_set_server：数据库服务器的默认字符集\ncharacter_set_system：存储系统元数据的字符集，总是 utf8，不需要设置\n\n排序字符集utf8mb4_unicode_ci 和 utf8mb4_general_ci1、准确性utf8mb4_unicode_ci 是基于标准的 Unicode 来排序和比较，能够在各种语言之间精确排序\nutf8mb4_general_ci 没有实现 Unicode 排序规则，在遇到某些特殊语言或者字符集，排序结果可能不一致。\n但是绝大多数情况下，这些特殊字符的顺序并不需要那么精确。\n2、性能utf8mb4_general_ci 在比较和排序的时候更快\nutf8mb4_unicode_ci 在特殊情况下，Unicode 排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。\n但是在绝大多数情况下，不会发生此类复杂比较。相比选择哪一种 collation，使用者更应该关心字符集与排序规则在 db 里需要统一。\nutf8mb4_0900_ai_ci\n推荐用 utf8mb4_unicode_ci，但是用 utf8mb4_general_ci 也没啥问题。\n\nMySQL 8.0 默认的是 utf8mb4_0900_ai_ci，属于 utf8mb4_unicode_ci 中的一种，具体含义如下：\n\nuft8mb4 表示用 UTF-8 编码方案，每个字符最多占 4 个字节。\n0900 指的是 Unicode 校对算法版本。（Unicode 归类算法是用于比较符合 Unicode 标准要求的两个 Unicode 字符串的方法）。\nai 指的是口音不敏感。也就是说，排序时 e，è，é，ê 和 ë 之间没有区别。\nci 表示不区分大小写。也就是说，排序时 p 和 P 之间没有区别。\n\nutf8mb4 已成为默认字符集，在 MySQL 8.0.1 及更高版本中将 utf8mb4_0900_ai_ci 作为默认排序规则。以前，utf8mb4_general_ci 是默认排序规则。由于 utf8mb4_0900_ai_ci 排序规则现在是默认排序规则，因此默认情况下新表格可以存储基本多语言平面之外的字符。现在可以默认存储表情符号。如果需要重音灵敏度和区分大小写，则可以使用 utf8mb4_0900_as_cs 代替。\nUTF-8 与 UTF-8MB4 的区别UTF-8 （Unicode）\n我们先谈谈UTF-8,最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n\n因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。现代操作系统和大多数编程语言都直接支持Unicode。\n所以在UTF-8编码中，一个英文字符占用一个字节的存储空间，一个中文（含繁体）占用三个字节的存储空间。\n目前基本上可见字符集都只需要三个字节，包含了所有字符，但是目前问题出在了unicode6系列编码上，它们需要4个字节，这部分就是有名的emoji。所以，你只要不是特种编码还是unicode，且不存emoji，保证不出问题。\n另外在此处，我有一点需要补充的是：\nMySQL数据库的 “utf8”并不是真正概念里的 UTF-8，原因上面是一点，还有一点是MySQL中的“utf8”编码只支持最大3字节每字符。真正的大家正在使用的UTF-8编码是应该能支持4字节每个字符。\n但其实MYSQL的开发者，并没有修饰这个bug，而是推出了新的字符集，就是UTF-8MB4字符编码。\nUTF-8MB4\nUTF8MB4：MySQL在5.5.3之后增加了utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。因此可以用来存储emoji表情。\n\n从8.0后，MySQL也将会在某个版本中开始使用UTF-8MB4作为默认的字符编码。\n所以简单说即是：UTF-8MB4才是MySQL中真正的UTF-8编码。\n那么如何让MySQL存储Emoji表情勒。\n如何让MySQL存储Emoji表情我们在创建数据库的时候，就需要选定utf-8mb4字符集，而不是utf-8。\n\n我们在设置字段字符集的时候，也需要设置为utf-8mb4字符集。\n\n这样我在Navicat 中测试是可以的。\n\n但是，我之前在网上查询相关资料的时候，说是需要修改一下my.ini配置文件，\n在[mysqld]下面添加：character_set_server&#x3D;utf8mb4，保存，重启mysql，应该就可以解决了。\n注意：下次再有人问起设置什么样的编码，记得直接推荐设置utf-8mb4哦，这个才是MySQL真正的UTF-8编码哦。一些建议\n看起来修改方法挺简单，不过对于生产环境还是要格外小心。特别是修改字段字符集时，会加锁，阻止写操作，对于大表执行下来也是很慢的，可能对线上业务造成影响。\n如果你的数据库比较小，用以上方法应该问题不大。对于线上环境，若要修改字符集，一定要做好评估，最好可以在业务低峰期停机修改，修改前一定要先备份。若无停机时间，可以考虑先在备库修改，然后再主备切换，不过这样做会更麻烦。\n有条件的话也可以再准备一个空实例，先导入表结构，改成 utf8mb4 字符集后再导入数据。这也是一种方法，不过也可能需要停机切换。\n\n","categories":["技术"],"tags":["技术","心得","mysql"]},{"title":"Mysql使用命令备份和还原数据库","url":"/2022/03/06/Mysql%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"mysql数据库备份命令（mysql数据备份的三种方法）在操作数据过程中，可能会导致数据错误，甚至数据库奔溃，而有效的定时备份能很好地保护数据库。本篇文章主要讲述了几种方法进行 MySQL 定时备份数据库。\n一. mysqldump命令备份数据在MySQL中提供了命令行导出数据库数据以及文件的一种方便的工具mysqldump,我们可以通过命令行直接实现数据库内容的导出dump,首先我们简单了解一下mysqldump命令用法:\nmysqldump -u root -p --databases 数据库1 数据库2 &gt; xxx.sql\n\n二. mysqldump常用操作示例1. 备份全部数据库的数据和结构mysqldump -uroot -p123456 -A &gt; /data/mysqlDump/mydb.sql\n\n2.备份全部数据库的结构（加 -d 参数）mysqldump -uroot -p123456 -A -d &gt; /data/mysqlDump/mydb.sql\n\n3. 备份全部数据库的数据(加 -t 参数)mysqldump -uroot -p123456 -A -t &gt; /data/mysqlDump/mydb.sql\n\n4.备份单个数据库的数据和结构(,数据库名mydb)mysqldump -uroot-p123456 mydb &gt; /data/mysqlDump/mydb.sql\n\n5. 备份单个数据库的结构mysqldump -uroot -p123456 mydb -d &gt; /data/mysqlDump/mydb.sql\n\n6. 备份单个数据库的数据mysqldump -uroot -p123456 mydb -t &gt; /data/mysqlDump/mydb.sql\n\n7. 备份多个表的数据和结构（数据，结构的单独备份方法与上同）mysqldump -uroot -p123456 mydb t1 t2 &gt; /data/mysqlDump/mydb.sql\n\n8. 一次备份多个数据库mysqldump -uroot -p123456 --databases db1 db2 &gt; /data/mysqlDump/mydb.sql\n\n三. 还原 MySQL 备份内容有两种方式还原，第一种是在 MySQL 命令行中，第二种是使用 SHELL 行完成还原\n1. 在系统命令行中，输入如下实现还原：mysql -uroot -p123456 &lt; /data/mysqlDump/mydb.sql\n\n2. 在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原：mysql&gt; source /data/mysqlDump/mydb.sql\n\n在 Linux中，通常使用BASH脚本对需要执行的内容进行编写，加上定时执行命令crontab实现日志自动化生成。\n\n以下代码功能就是针对mysql进行备份，配合crontab，实现备份的内容为近一个月（31天）内的每天的mysql数据库记录。\n\n3.编写BASH维护固定数量备份文件在Linux中，使用vi或者vim编写脚本内容并命名为：mysql_dump_script.sh\n#!/bin/bash#保存备份个数，备份31天数据number=31#备份保存路径backup_dir=/root/mysqlbackup#日期dd=`date +%Y-%m-%d-%H-%M-%S`#备份工具tool=mysqldump#用户名username=root#密码password=TankB214#将要备份的数据库database_name=edoctor#如果文件夹不存在则创建if [ ! -d $backup_dir ];thenmkdir -p $backup_dir;fi#简单写法mysqldump -u root -p123456 users &gt; /root/mysqlbackup/users-$filename.sql$tool -u $username -p$password $database_name &gt; $backup_dir/$database_name-$dd.sql#写创建备份日志echo &quot;create $backup_dir/$database_name-$dd.dupm&quot; &gt;&gt; $backup_dir/log.txt#找出需要删除的备份delfile=`ls -l -crt $backup_dir/*.sql | awk &#x27;&#123;print $9 &#125;&#x27; | head -1`#判断现在的备份数量是否大于$numbercount=`ls -l -crt $backup_dir/*.sql | awk &#x27;&#123;print $9 &#125;&#x27; | wc -l`if [ $count -gt $number ]then#删除最早生成的备份，只保留number数量的备份rm $delfile#写删除文件日志echo &quot;delete $delfile&quot; &gt;&gt; $backup_dir/log.txtfi\n\n如上代码主要含义如下：\n\n1.首先设置各项参数，例如number最多需要备份的数目，备份路径，用户名，密码等。\n2.执行mysqldump命令保存备份文件，并将操作打印至同目录下的log.txt中标记操作日志。\n3.定义需要删除的文件：通过ls命令获取第九列，即文件名列，再通过实现定义操作时间最晚的那个需要删除的文件。\n4.定义备份数量：通过ls命令加上\n统计以sql结尾的文件的行数。\n5.如果文件超出限制大小，就删除最早创建的sql文件\n\n使用crontab定期执行备份脚本在 Linux 中，周期执行的任务一般由cron这个守护进程来处理[ps -ef|grep cron]。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为“crontab”，是“cron table”的简写。\ncron服务cron是一个 Liunx 下 的定时执行工具，可以在无需人工干预的情况下运行作业。\nservice crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //查看服务状态\n\n\ncrontab语法crontab命令用于安装、删除或者列出用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行。每个用户都可以有自己的crontab文件。&#x2F;var&#x2F;spool&#x2F;cron下的crontab文件不可以直接创建或者直接修改。该crontab文件是通过crontab命令创建的。\n在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。\n格式如下：\nminute hour day-of-month month-of-year day-of-week commands\n\n\n合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday)\n除了数字还有几个个特殊的符号就是”“、”&#x2F;“和”-“、”,”，代表所有的取值范围内的数字，”&#x2F;“代表每的意思,”&#x2F;5”表示每5个单位，”-“代表从某个数字到某个数字,”,”分开几个离散的数字。\n-l 在标准输出上显示当前的crontab。\n-r 删除当前的crontab文件。\n-e 使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件。当结束编辑离开时，编辑后的文件将自动安装。\n创建cron脚本第一步：写cron脚本文件,命名为mysqlRollBack.cron。15,30,45,59 * * * * echo &quot;xgmtest.....&quot; &gt;&gt; xgmtest.txt 表示，每隔15分钟，执行打印一次命令第二步：添加定时任务。执行命令 “crontab crontest.cron”。搞定第三步：&quot;crontab -l&quot; 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本\n\n\n注意：这操作是直接替换该用户下的crontab，而不是新增定期执行编写的定时任务脚本（记得先给shell脚本执行权限）0 2 * * * &#x2F;root&#x2F;mysql_backup_script.sh随后使用crontab命令定期指令编写的定时脚本crontabmysqlRollback.cron再通过命令检查定时任务是否已创建：\n\n附 crontab 的使用示例：1. 每天早上6点0 6 * * * echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt #注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。\n\n2. 每两个小时0 */2 * * * echo &quot;Have a break now.&quot; &gt;&gt; /tmp/test.txt\n\n3. 晚上11点到早上8点之间每两个小时和早上八点0 23-7/2，8 * * * echo &quot;Have a good dream&quot; &gt;&gt; /tmp/test.txt\n\n4. 每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点0 11 4 * 1-3 command line\n\n5.1 月 1 日早上 4 点0 4 1 1 * command line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root #如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/\n\n6. 每小时执行&#x2F;etc&#x2F;cron.hourly内的脚本01 * * * * root run-parts /etc/cron.hourly\n\n7. 每天执行&#x2F;etc&#x2F;cron.daily内的脚本02 4 * * * root run-parts /etc/cron.daily\n\n8. 每星期执行&#x2F;etc&#x2F;cron.weekly内的脚本22 4 * * 0 root run-parts /etc/cron.weekly\n\n9. 每月去执行&#x2F;etc&#x2F;cron.monthly内的脚本42 4 1 * * root run-parts /etc/cron.monthly\n\n注意: “run-parts” 这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。\n10. 每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。5，15，25，35，45，55 16，17，18 * * * command\n\n11. 每周一，三，五的下午3：00系统进入维护状态，重新启动系统。00 15 * * 1，3，5 shutdown -r +5\n\n12. 每小时的10分，40分执行用户目录下的innd&#x2F;bbslin这个指令：10，40 * * * * innd/bbslink\n\n13. 每小时的1分执行用户目录下的bin&#x2F;account这个指令：以下是我的测试每分钟的截图效果，其对应代码如下：\n* * * * * /root/mysql_backup_script.sh\n\n效果截图：\n\n其中的log.txt记录备份的操作详细日志：\n————————————————————————————————————————————————————————————————————\ncrontab 定时语句# 每天晚上7点定时备份mysql数据库0 19 * * * . /etc/profile;/bin/bash /u01/mysql/data_dump/bf_data_dump.sh &gt;&gt; /u01/mysql/data_dump/mrbf_log.txt\n\n\nvi bf_data_dump.sh\n\n#/bin/bash#This is mysql backup shell on 2022/8/10#longz 定时备份mysql脚本#BACKUP_DIR=/u01/mysql/data_dump/&#x27;date +%Y-%m-%d&#x27;#保存备份个数，备份31天数据number=7#备份保存路径BACKUP_DIR=/u01/mysql/data_dump#日期dd=$(date +%Y%m%d)dd1=_$(date +%Y%m%d_%H%M%S)##备份工具tool=/usr/bin/mysqldump#将要备份的数据库MYSQL_DB1=itcast_shop_biMYSQL_DB2=kdy_zhongshenglMYSQL_DB3=kodboxMYSQL_DB4=mycMYSQL_DB5=mysqlMYSQL_DB6=pixiv#用户名MYSQL_USER=root#密码MYSQL_PW=*********#端口号MYSQL_PORT=3306#判断用户是否为root，如果不是，自动退出；if [[ $UID -ne 0 ]]; then      echo &quot; This user must be root !!!\t  此用户必须是root用户 !!! &quot;      sleep 2      exit 0fi#判断目录是否存在if [[ ! -d $BACKUP_DIR/$dd ]]; thenmkdir -p $BACKUP_DIR/$ddfi#下面开始备份#简单写法 mysqldump -u root -p123456 users &gt; /root/mysqlbackup/users-$filename.sql$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB1 | gzip &gt; $BACKUP_DIR/$dd/itcast_shop_bi-$dd1.sql.gzecho &quot;itcast_shop_bi_备份完成-$dd1&quot;#写创建备份日志echo &quot;create $BACKUP_DIR/itcast_shop_bi-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB2 | gzip &gt; $BACKUP_DIR/$dd/kdy_zhongshengl-$dd1.sql.gzecho &quot;kdy_zhongshengl_备份完成-$dd1&quot;#写创建备份日志echo &quot;$dd1_create $BACKUP_DIR/kdy_zhongshengl-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB3 | gzip &gt; $BACKUP_DIR/$dd/kodbox_shop_bi-$dd1.sql.gzecho &quot;kodbox_备份完成-$dd1&quot;#写创建备份日志echo &quot;create $BACKUP_DIR/kodbox_shop_bi-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB4 | gzip &gt; $BACKUP_DIR/$dd/myc-$dd1.sql.gzecho &quot;myc_备份完成-$dd1&quot;#写创建备份日志echo &quot;create $BACKUP_DIR/myc-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB5 | gzip &gt; $BACKUP_DIR/$dd/mysql-$dd1.sql.gzecho &quot;mysql_备份完成-$dd1&quot;#写创建备份日志echo &quot;create $BACKUP_DIR/mysql-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt$tool -u$MYSQL_USER -P$MYSQL_PORT -p$MYSQL_PW $MYSQL_DB6 | gzip &gt; $BACKUP_DIR/$dd/pixiv-$dd1.sql.gzecho &quot;pixiv_备份完成-$dd1&quot;#写创建备份日志echo &quot;create $BACKUP_DIR/pixiv-$dd1.dupm&quot; &gt;&gt; $BACKUP_DIR/log.txt\n\n","categories":["技术"],"tags":["技术","linux","心得","mysql"]},{"title":"Mysql相关操作知识","url":"/2021/08/06/Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"Mysql使用时的注意事项\n每一条数据库操作语句都应该以分号；结尾，因为mysql支持换行操作\nmysql数据库对大小写不敏感，大小写皆可，通常关键字使用大写表示\nmysql数据库中库的名称应该以英文字符或者一些符号起始，但是不允许以数字起始\nmysql数据库中库的名称、表的名称、字段的名称都不能使用mysql关键字，比如create、database；如果非要使用，那就要用反引号括起来\n\n基础常用命令本地登录：mysql -uroot -p 密码;--也可以不带密码，之后输入本地登录\n\n远程登录：mysql -h 登录ip -p 端口(通常3306） -uroot -p密码;\n查看表的各个字段的属性，以及自增键\ndesc 表名;\n导出数据库文件，保存mysqldump -u用户 -p 数据库名 &gt; xx.sql;\n\n导入数据库文件mysql -u用户 -p密码  数据库名&lt; xx.sql; --也可以选择登录进去，在选择数据库后，使用source命令导入数据\n\n创建用户ip是指用户登录mysql的电脑ip，可以写%，本地写localhost\ncreate user &#x27;用户名&#x27; @&#x27;ip&#x27; identified by &#x27;密码&#x27;; \n\n用户授权grant 权限(select/insert/updata/all priveleges) on 表/数据库名 to &#x27;用户&#x27;@&#x27;ip&#x27; identified by &#x27;密码&#x27;;\n\n删除用户drop user 用户名@ip ;\n\n\n\n库的操作查看mysql中所有的库：\nshow databases;\n创建库：create database 库名称 default charset utf8;create database if not exists 库名称;## 如果不存在该库，则创建\n删除库：drop database 库名称;\n选择使用数据库use 库名称;\n显示当前使用的数据库：select database();\n\n\n数据类型数值类型MySQL支持所有标准SQL数值数据类型。\n\n这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC),以及近似值数据类型（FLOAT、REAL和DOUBLE PRECISION）。\n\n\n#关键字 INT 是 INTEGER 的同义词，关键字 DEC 是 DECIMAL 的同义词。BIT 数据类型保存位字段值，并且支持MylSAM、MEMORY、InnoDB和BDB表。\n\n作为SQL标准的扩展，Mysql也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。\n\n日期和时间类型\n表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME和YEAR\n\n每个时间类型有一个有效值范围和一个”零”值,当指定不合法的MySQL不能表示的值时使用”零”MySQL支持所有标准SQL数值数据类型。\n\n字符串类型\n字符串类型值 CHAR、VARCHAR、BINARY、VARBINARY、BLOG、TEXT、ENUM和SET\n\n\n\n注意：\n\nchar(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。\nCHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。\nBINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。\nBLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。\n有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。\n\n\n表的操作显示库中所有的表：\nshow tables;\n\n创建表：\ncreate table 表名(列名 数据类型 约束···，列名 数据类型 约束···）engine=innodb default charset=utf8   创建表create table 表名(列名 数据类型 primary key auto_increment,列名 数据类型 约束···）engine=innodb default charset=utf8 创建含主键的表create table 表名(列名 数据类型 primary key,列名 数据类型 constraint fk_外键名 foreign key (列名[,]) references 表名2（列名[,]）···）engine=innodb default charset=utf8  创建含外键的表create table if not exists tb_stu(id int,name varchar(3),age int, birth datetime);\n\n查看表结构：desc tb_stu\n\n删除表：\ndrop table tb_stu;\n\n表中数据的增删改查基础插入数据 insert指定列插入：可以指定单独个一个或几个列信息进程插入，并且前缀列信息\ninsert into tb_stu(id,name) values (1,&quot;韩云溪&quot;);\n全列插入：可以省略前缀的列信息，按照列顺序插入所有列的数据\ninsert into tb_stu values (1,&quot;韩云溪&quot;,21,&quot;2000-03-19 12:00:00&quot;);insert into tb_stu values (2,&quot;夏紫藤&quot;,21,&quot;2000-05-18 11:00:00&quot;);insert into tb_stu values (3,&quot;三三&quot;,17,&quot;2021-06-26 11:43:01&quot;);insert into tb_stu values (4,&quot;四四&quot;,18,&quot;2021-06-26 11:43:01&quot;);\n\n多行插入：insert into tb_name values(val1,val2…),(val1,val2…),…;insert into tb_stu values (3,”三三”,17,now()),(4,”四四”,18,now());\n\n\n查询数据 select查询指定表中所有数据：\nselect * from tb_stu;\n\n指定列查询：\nselect name,birth from tb_stu;\n\n\n排序查询：按照年龄排序查询,默认为asc升序查询，desc为降序查询\nselect * from tb_stu order by age [asc]/desc;\n\n多列排序：在第一列相同的情况下针对第二列进行排序：\nselect * from tb_stu order by age ,id desc;\n\n分页查询：通常搭配排序一起使用\nselect * from tb_stu limit m offset n;--分页查询，每页显示m条数据，偏移到第n条开始显示m条数据（即从第n条起，显示一页）\n\n查询字段为表达式：\nselect name,id+age from tb_stu;--按照name和id+age的值分列查询\n\n查询时，字段别名的使用：\nselect name,id+age [as] total from tb_stu; --给id+age起了个别名叫total，as可以省略\n\n\n去重：\nselect distinct age from tb_stu ;--根据age查询，并对age去重\n\n\n条件查询 where\n按照一定的限制条件进行查询，限制条件通过where子句给出\n\n例如：按照id&gt;1的限制条件进行查询：\nselect * from tb_stu where id&gt;1;\n\n\nwhere子句涉及的运算符：\n\n\n另外还有：&gt; &#x3D; &lt;（大于、等于、小于）可以和NULL进行比较is NULL&#x2F;is not NULL 可以用来判断是否为空\n\nIN的使用：\n\n判断查询的数据是否是给予的多个选项之一\n\n例如：\nselect * from tb_stu where name in(&quot;韩云溪&quot;,&quot;夏紫藤&quot;);--查询名字为韩云溪或夏紫藤的项，符合则显示，不符合则忽略\n\n\nbetween A and B 的使用：查询范围介于AB两者之间项\nselect * from tb_stu where id between 1 and 3; --查询id介于1和3之间的项\n\n\nLIKE 模糊匹配的使用：查询一个数据看起来像某个条件\nselect * from tb_stu where name like &#x27;韩%&#x27;;--查询表中姓名以韩开头的项，%为通配符\n\n逻辑运算符的使用：与and、 或or、 非not\nselect * from tb_stu where age&gt;17 and age&lt;22;--查询表中年龄大于17并且小于22的项\n\n\n连表操作\nselect * from 表1 left join 表2 on 表1.列名=表2.列名;  左连接select * from 表1 right join 表2 on 表1.列名=表2.列名;  右连接select * from 表1 inner join 表2 on 表1.列名=表2.列名;  内连接\n\n注意:如果超过3个表联合操作，如果其中两个表操作时已经改变了表结构，应该将这两个表操作的结果作为一个临时表再与第三个表联合操作。\n\n临时表\n(select * from 表名)as e\n\n\n修改数据：update\nupdate tb_name set fields1=val1,fields2=val2 where condition;--尤其注意不要忘了where限制条件，否则整张表的该列数据都会更改\n\n删除数据：Delete和Truncate\ndelete from tb_name where condition;--尤其注意不要忘了where限制条件，否则整张表的数据都会被删除--清除表(如果有自增id，id 不会重新开始)truncate table 表名;--清除表(如果有自增id，id 会重新开始)\n\n修改表结构alter table 表名 auto_increment=value; 设置自增键起始值；alter table 表名 drop 列名; 删除列alter table 表名 add 列名 数据类型 约束; 增加列alter table 表名 change 旧列名 新列名 数据类型; 修改字段类型alter table 表名 modify 列名 数据类型; 修改数据类型alter table 旧表名 rename 新表名; 修改表名alter table 表名 drop primary key; 删除表中主键alter table 表名 add 列名 数据类型 primary key;添加主键alter table 表名 add primary key(列名); 设置主键alter table 表名 add column 列名 数据类型 after 列名; 在某一列后添加主键\n\nmysql进阶外键外键适用于一对多，一对一，多对多三种情况\n一对多\n\n典型案例员工与部门，一个部门对应于多个员工，一个员工对应于一个部分，所以要在员工表中设置部门id列，并设置为外键，与部门表id关联。\n\n一对一\n\n案例博客园用户与博客，不是每个用户都写博客，写博客的用户与拥有的博客地址一一对应，所以在博客用户表user中设置blog_id，设置成外键和唯一索引，与博客表blog中id关联\n\ncreate table user(id int not null auto_increment primary key,name char(10), blog_id int,unique uq1(blog_id),constraint fk_user_blog foreign key(blog_id) references blog(id) ) engine=innodb default charset=utf8;\n\n多对多\n\n典型案例电脑与用户，一个用户可以使用多台电脑，一台电脑对应多个用户，多对多，此时一般选择新建一个表contact，在其中设置两个外键，同时关联用户表id与电脑表id\n\ncreate table contact( id int not null auto_increment primary key,user_id int,computer_id int,unique uq2(user_id,computer_id),constraint fk_user foreign key(user_id) references user(id),constraint fk_user foreign key(computer_id) references computer(id) ) engine=innodb default charset=utf8;\n\n可以看情况决定要不要把两个外键弄成联合唯一索引。\n\n自增查看表的创建信息show create table 表名 ;\n\n对于自增键，我们可以设置它的初始值以及与自增步长\nalter table auto_increment=value; --设置自增初始值\n\n对于自增步长有两种类型：第一种：基于会话级别(只对本次登录有效)\nshow session variables like &quot;auto_incre%&quot;;   -- 查看步长set session auto_increment_increment=value;  --改变步长set session auto_increment_offest=value;  --设置起始值(不常用，因为有之前的alter)\n\n第二种：基于全局级别(对所有会话都有用)\nset global auto_increment_increment=value; --设置全局步长\n\npymysql\npymysql 是python第三方模块，主要用于python与mysql交互。\n\npymysql 方法:connect(host=,user=,passwd=,database=) 连接数据库cursor() 建立游标execute(sql)执行sql语句fetchone()从查询结果中取出一条数据fetchmany(num)从查询结果中取出num条数据fetchall()从查询结果中取出所有数据commit() 改变(updata，insert，drop)数据库内容专用,execute sql语句后必须commit才能真正改变数据库close()注意最后有两个close,游标要关闭，连接也要关闭\n\nsql注入\nsql注入 就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。\n\n实例如下：\n\n假设我们输入用户名和密码，然后登录数据库，在数据库中查找用户和密码是否存在，存在即登录成功，否则登录失败\n\n\n\n程序如上，一开始我们输入数据库存在的用户和密码，自然能够登录成功\n\n\n\n输入错误用户和密码，也能成功\n\n\n追究其原有，原因出在sql语句字符串拼接上\n拼接的字符串为 &#x27;&#x27; or 1=1 -- &#x27;&#x27; and passwd=&#x27;123&#x27;,有1=1，当然成立\n\n解决办法：\n\n将要拼接的内容放入execute括号中，由其自己拼接\n\n视图\n视图是一种虚拟存在的表，本身不包含数据，作为一个select语句保存在数据库中。通俗的讲视图代表的是一条select语句产生的结果集。\n\ncreate view 视图名称 as select语句; --创建视图 \n\n\n视图单独不能插入，修改数据，因为视图是虚拟的。但可以修改select语句，改变视图结果集。\nalter view 视图名称 as sql语句; --修改结果集drop view 视图名称; --删除视图\n\n索引\n定义:索引（Index）是帮助MYSQL高效获取数据的数据结构\n\n索引的作用:\n约束，加速查找\n\n索引种类\n普通索引: 加速查找\n主键索引: 加速查找；约束(主键不能为空，不能重复)\n唯一索引: 加速查找；约束(索引不能重复）\n组合索引: 多列组成一个索引(联合主键索引，联合唯一索引，联合普通索引)\n\ncreate index 索引名 on 表名(列名[,列名]);创建[联合]普通索引create table 表名(列名 数据类型···index 索引名(列名[,列名])); 创建表时创建[联合]普通索引create unique index 索引名 on 表名(列名);创建唯一索引create table 表名(列名 数据类型···unique 索引名(列名)); 创建表时创建唯一索引create unique index 索引名 on 表名(列名,列名);创建联合唯一索引create table 表名(列名 数据类型···unique 索引名(列名,列名)); 创建表时创建联合唯一索引drop index 索引名 on 表名; 删除索引\n\n索引结构\n索引一般有两种结构:哈希索引和BTree索引\n\n哈希索引\n哈希索引会产生一张索引表，把数据通过算法换算成哈希值，索引表存储这些哈希值，并在表中保存指向数据的指针，值得注意的是索引表存储哈希值时打乱了原有的存储顺序。哈希索引查找一条数据时特别快速，优于BTree索引，但因为打乱了原有的数据顺序，不支持范围查找与排序功能。\n\nBTree索引MYSQL普遍采用B+Tree结构\n\nB+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。BTree索引查找单条数据的速度不如哈希索引，但是更加适用于范围查找与排序，所以用的最为广泛，引擎innodb与MyIsam都使用了BTree索引。\n\n\n索引是不是越多越好？\n不是的，索引越多，占据的物理空间越大；索引只是加快了查询速度，而减缓了插入和修改速度。\n\n事务\n定义:在MYSQL中，事务其实是一个最小的不可分割的工作单元，事务能保证一个业务的完整性。\n\n场景:在开发中，有多条语句可能会有同时成功的要求，如果只有一部分成功，则全部失败，回滚到原来的状态。\nmysql中如何控制事务通过\nselect @@autocommit; --语句查询自动提交是否开启，1表示开启，0表示没有开启--当查询结果为1时，自动提交开启，执行sql语句(insert into ，alter),--系统默认提交确认，在物理表生效--当查询结果为0时，自动提交关闭，执行sql语句，--系统会等待用户手动提交确认(commit;)--否则可以撤回修改,回滚为原状态(rollback;）\n\n开启事务一般@@autocommit我们默认开启，否则每次都需手动提交太麻烦，但当我们想开启一个事务时应该怎么做？\n\n我们可以通过 begin或start transaction 开启一个事务，最后以commit;或rollback;结束一个事务。\n\n事务的四大特性(ACID)\nA 原子性:事务是最小的不可分割的工作单元C 一致性:在一个事务中，事务前后数据的完整性必须保持一致，sql语句要么全部成功，要么失败，回滚到原状态。如银行转账，总的钱数不变I 隔离性:不同事务之间具有隔离性D 持久性:事务一旦结束，就不可以返回，不可以rollback \n\nmysql事务四大隔离级别\n读未提交（read uncommitted）\n不可重复读（read committed）\n可重复读（repeatable read）\n串行化（serializable）\n\nmysql事务隔离级别默认是可重复读(repeatable-read）\nselect @@ global.tx_isolation; --mysql(5.x版本)查看隔离级别set [global/session] transaction isolation level 隔离级别; --设置隔离级别\n\n四种隔离级别导致的问题：\n\n\n脏读：事务1读到了事务2未提交的数据，如果事务2rollback，这些数据便是脏数据\n不可重复读：事务1对同一数据重复读，但是另一个事务不断修改这些数据，造成事务1每次读到的数据不一样\n幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户在新开启的事务中发现表中还有没有修改的数据行，就好象发生了幻觉一样(用户1开启事务查看数据，然后同时有用户2开启事务对数据修改并提交，用户1在当前事务没有发现数据改变，结束事务，然后在新开启的事务中发现了新修改的数据，这像幻觉）\n\n\n注意:不可重复读侧重修改，幻读侧重插入和删除\n幻读试验：设置隔离级别\n开启一个事务，查询数据\n\n重新打开一个窗口登录，开启事务插入数据，并commit\n\n先前的事务查询数据，看不到新增语句，解决了不可重复读问题\n\n关闭先前事务，重新查询，查到新增数据，出现幻读\n\nmysql重要知识点innodb与MyIsam的区别InnoDB支持事务，而MyISAM不支持事务;InnoDB支持行级锁，而MyISAM支持表级锁;InnoDB支持MVCC(多版本并发控制), 而MyISAM不支持;InnoDB支持外键，而MyISAM不支持;InnoDB不支持全文索引，而MyISAM支持;\n\n\n内连接，左连接，右连接的区别内连接：返回两表指定列名相同的数据，如果没有返回空。\nselect * from 表1 inner join 表2 on 表1.列名=表2.列名;  --内连接\n\n\n左连接:左边数据全显示，右边表只显示符合条件的数据，如果右边没有相符数据或满足的数据少于左边数据行，以null代替(记录不足的地方以null代替)\nselect * from 表1 left join 表2 on 表1.列名=表2.列名;  --左连接\n\n\n右连接:与左连接相反\nselect * from 表1 right join 表2 on 表1.列名=表2.列名;  --右连接\n\n\ndrop,delete与truncate的区别\ndrop 直接删掉表\ntruncate 删除表中数据，再插入时自增长id又从1开始\ndelete 删除表中数据，可以加where字句,delete删除整个表数据时，再插入自增id不会从1开始\n\n为什么用BTree做索引结构\n哈希:虽然单词查询快，但是没有顺序，不适合范围查询\n二叉树：树的高度不均匀，不能自平衡，查找效率与树的高度有关，IO代价高\n红黑树：树的高度随数据量而变，IO代价高(数据量过大时，树的深度越高，IO读写越频繁)\nBtree:数据很大时，不可能放在内存，所以放在磁盘上，BTree 每层节点数多，层数少，减少了IO读写次数，查询结果更加稳定\n\n主键 外键\n主键:数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个表只能有一个主键，且主键的取值不能缺失，即不能为空值(Null)。\n外键:在一个表中存在的另一个表的主键称此表的外键。\n\nvarchar与char区别\nchar是一种固定长度的类型，varchar则是一种可变长度的类型char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度varchar(50)中50表示最多有50个字符varchar节省空间，查询速度没有char速度快\n\n行级锁和表级锁\n表级: 直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许行级: 仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。\n\n","categories":["技术"],"tags":["技术","linux","心得","mysql"]},{"title":"ORACLE-11G-EM-配置命令及问题处理","url":"/2020/06/06/ORACLE-11G-EM-%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/","content":"oracle11g for linux web管理首先确保oracle安装成功,并启动oracle服务\nORACLE用户下利用sqlplus登陆oracle数据库后台\nsqlplus sys/123456 as sysdba\n\n\n1.修改DBSNMP密码：重新配置DBCONSOLE，需要输入DBSNMP密码，但任何密码都会显示错误，需要预先修改。\nalter user dbsnmp identified by 123456;\n\n2.删除早期DBCONSOLE创建的用户：drop role MGMT_USER;drop user MGMT_VIEW cascade;drop user sysman cascade;\n\n3.删除早期DBCONSOLE创建的对象：drop PUBLIC SYNONYM MGMT_TARGET_BLACKOUTS;drop public synonym SETEMVIEWUSERCONTEXT;drop public synonym MGMT_AVAILABILITY;drop public synonym MGMT_CURRENT_AVAILABILITY;drop public synonym MGMT_SEVERITY_OBJ\n\n4.重新创建DBCONSOLE(果是在windows下，要先到注册表删除DBCONSOLE的服务，重启电脑)：emca -config dbcontrol db -repos create或者emca -config dbcontrol db -repos recreate\n根据提示，先输入SID，再输入Y继续；\n输入端口1521，输入SYS密码，输入DBSNMP密码，输入SYSMAN 密码，输入Y继续\n漫长等待后,完成。\n检查em状态emctl status dbconsole## 开启emctl start dbconsole## 关闭emctl stop dbconsole\n\n\n登陆web管理本机输入: https://localhost:1158/em/console/aboutApplication\n其他机器可访问: https://&quot;IP&quot;:1158/em/console/aboutApplication\n如图:\n遇到的问题## 提示 Environment variable ORACLE_UNQNAME not defined. Please set ORACLE_UNQNAME to database unique name.修改unqnameset oracle_unqname=zftang;或者vi ~/.bash_profileexport ORACLE_UNQNAME=$ORACLE_SID----## 提示 严重: 监听程序未启动或数据库服务未注册到该监听程序。启动该监听程序并注册数据库服务, 然后重新运行 EM Configuration Assistant。## 开启emctl start dbconsoleset ORACLE_HOSTNAME=localhost\n\nEM配置的一些命令创建一个EM资料库\nemca -repos create\n\n重建一个EM资料库emca -repos recreate ——–这个很主要，一般第一次不成功创建的时候，以后再创建都用这个命令就好了删除一个EM资料库\nemca -repos drop\n\n配置数据库的 Database Control\nemca -config dbcontrol db\n\n删除数据库的 Database Control配置\nemca -deconfig dbcontrol db\n\n重新配置db control的端口，默认端口在1158\nemca -reconfig portsemca -reconfig ports -dbcontrol_http_port 1158emca -reconfig ports -agent_port 3940\n\n先设置ORACLE_SID环境变量后,启动EM console服务 \nemctl start dbconsole\n\n先设置ORACLE_SID环境变量后,停止EM console服务\nemctl stop dbconsole\n\n先设置ORACLE_SID环境变量后,查看EM console服务的状态\nemctl status dbconsole\n\n配置dbconsole的步骤\nemca -repos createemca -config dbcontrol dbemctl start dbconsole\n\n重新配置dbconsole的步骤\nemca -repos dropemca -repos createemca -config dbcontrol db\n","categories":["技术"],"tags":["技术","linux","心得"]},{"title":"Oracle Rman 自动备份与恢复","url":"/2021/11/06/Oracle-Rman-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","content":"Oracle环境：Oracle 11gR2配置步骤：\n一、配置rman自动备份：1、打开归档模式并修改归档路径：\n具体步骤参考以下链接：关于Oracle归档模式\n\n归档模式配置结果如下：\n2、创建本地rman备份存储目录：mkdir /rmanbakcd /rmanbakmkdir datafilemkdir controlfilemkdir logchown -R oracle:oinstall datafilechown -R oracle:oinstall controlfilechown -R oracle:oinstall log\n\n3、配置rman备份参数：rman配置[oracle@ora11g]$ rman target/RMAN&gt; show all;--如果配置不对，输入以下命令变更状态CONFIGURE CONTROLFILE AUTOBACKUP ON;CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO &#x27;/rmanbak/controlfile/%F&#x27;;\n\n备份数据文件RMAN&gt; backup database format &#x27;/rmanbak/datafile/data_%U.dbf&#x27;;\n\n备份控制文件RMAN&gt; backup current controlfile format &#x27;/rmanbak/controlfile/control_%f.dbf&#x27;;\n\n\n\n完备脚本(待调整)\n#!/bin/bashexport ORACLE_SID=ora11gexport ORACLE_BASE=/oracle/app/oracleexport ORACLE_HOME=/oracle/app/oracle/product/11.2.0/db_1$ORACLE_HOME/bin/rman target / &lt;&lt; EOFrun&#123;allocate channel c1 type disk;allocate channel c2 type disk;allocate channel c3 type disk;allocate channel c4 type disk;allocate channel c5 type disk;crosscheck archivelog all;backup as compressed backupset database format &#x27;/rmanbak/datafile/full_dbbackup_%T_%d_%U&#x27;;sql &#x27;alter system archive log current&#x27;;backup as compressed backupset filesperset 10 format &#x27;/rmanbak/datafile/Arch_%d_%T_%s.bak&#x27; archivelog all;delete noprompt obsolete;release channel c1;release channel c2;release channel c3;release channel c4;release channel c5;&#125;EOF\n\n\n\n备份参数文件（数据迁移到新服务器中）源库查看参数文件路径SQL&gt; show parameter spfile;--查看可得到路径：/oracle/app/oracle/product/11.2.0/db_1/dbs/spfileora11g.ora\n\n确认目标库是否有源库参数文件的路径，没有则需创建cd /oracle/app/oracle/product/11.2.0/db_1/dbs#关闭目标库sqlplus / as sysdbaSQL&gt; shutdown immediate\n关于参数文件\ninit.ora （只要这个参数文件在，下面两个就在，这三个文件是一致的）spfileora11g.ora （二进制，需要用命令修改）pfile.ora （文本，直接修改）\n\n如果要数据库迁移到另一个服务器上的数据库中，需要目标库中删除init.ora 和 spfileora11g.ora 这俩参数文件然后cp 源库中的这俩文件到目标库中\n--删除目标库中的参数文件rm init.ora spfileora11g.ora--拷贝源库参数文件到目标库中scp /oracle/app/oracle/product/11.2.0/db_1/dbs/init.ora 目标ip://oracle/app/oracle/product/11.2.0/db_1/dbsscp /oracle/app/oracle/product/11.2.0/db_1/dbs/spfileora11g.ora 目标ip://oracle/app/oracle/product/11.2.0/db_1/dbs\n\n查看下目标库中有没有cat spfileora11g.ora里这三个参数目录，如果没有查询到，需要在目标库中新建\n--审计目录*.audit_file_dest=&#x27;/oracle/app/oracle/admin/ora11g/adump&#x27;--控制文件目录*.control_files=&#x27;/oradata/ora11g/coCC&quot;)&quot;ntrol01.ctl&#x27;,&#x27;/oradata/ora11g/control02.ctl&#x27;--安装文件目录*.diagnostic_dest=&#x27;/oracle/app/oracle&#x27;--删除目标库中的数据文件及目录cd $ORACLE_BASE类似于这个文件目录 /oradata/ora11g\n\n\n修改目标库的 .bash_profile 文件和源库的一致\narchive log list; 查看归档目录--删除目标库中的归档文件然后从源库的归档目录中 复制 到目标库的归档目录中cd rmanback/datafile复制到目标库中\n\n备份恢复sqlplus / as sysdba启动到nomount状态，确认参数文件里目录是否都存在startup nomount;--RMAN恢复控制文件oracle$ rman target/RMAN&gt; restore controlfiles from &#x27;/rmanback/datafile/要恢复的控制文件.dbf&#x27;--rman中启动数据库状态到mount状态RMAN&gt; sql &#x27;alter database mount&#x27;;RMAN&gt; restore database;\n查看下快速恢复区&#x2F;审计目录&#x2F;数据文件目录，这三个目录有没有，没有一定要创建下\nRMAN&gt; crosscheck archivelog all; --校验检查控制文件和实际物理文件的区别\n\n如果归档文件校验有问题，将有问题的文件注册下如果报错，那么要手动的将截止日期作为结束点，需要手动下操作就行，归档就结束了\n\nORACLE开库RMAN&gt; sql &#x27;alter database open RESETLOGS&#x27;恢复后再确认下select status from v$instance;select table_name from user_tables;\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"Oracle11g搭建ogg","url":"/2022/04/06/Oracle11g%E6%90%AD%E5%BB%BAogg/","content":"Oracle11g搭建ogg（简单的单向复制）1.环境介绍\n主要介绍OGG的安装部署，下面是实验环境介绍。\n\n实验规划：\n\n\n\n项目\n源环境\n目标环境\n\n\n\n操作系统\nRed Hat Linux Server release 6.6\nRed Hat Linux Server release 6.6\n\n\n主机名\nora11g-1\nora11g-2\n\n\nIP地址\n192.168.65.139\n192.168.65.140\n\n\n数据库及版本\nORACLE_11204\nORACLE_11204\n\n\n数据库字符集\nAMERICAN_AMERICA.ZHS16GBK\nAMERICAN_AMERICA.ZHS16GBK\n\n\nORACLE_SID\norcl\norcl\n\n\nGoldenGate用户\nogg\nogg\n\n\nGoldenGate版本\n112103\n112103\n\n\n2.实验步骤：创建OGG操作系统用户\n两台服务器都需要创建ogg操作系统用户(此步骤非必须，也可以使用Oracle用户安装)。\n\nuseradd -u 1003 -g oinstall -G dba oggecho &quot;ogg&quot; | passwd --stdin ogg\n\n修改OGG操作系统用户环境变量ogg1:#创建OGG安装目录mkdir /u01/oracle/oggchown -R ogg.oinstall /u01/oracle/ogg#切换至ogg用户su - ogg#配置环境变量vim .bash_profile# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then        . ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/.local/bin:$HOME/binexport ORACLE_BASE=/u01/oracle/appexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATHexport ORACLE_SID=orclexport PATH=$ORACLE_HOME/bin:$ORACLE_HOME/jdk/bin:$PATH:/u01/oracle/ogg/alias sqlplus=&quot;rlwrap sqlplus&quot;alias ggsci=&quot;rlwrap ggsci&quot;#关于rlwrap需要单独下载安装包先下载安装包 https://github.com/hanslub42/rlwrapwget https://github.91chi.fun//https://github.com//hanslub42/rlwrap/releases/download/v0.45.2/rlwrap-0.45.2.zip解压： unzip rlwrap-0.45.2.zipcd rlwrap-0.45.2#安装rlwrap：./configuremake install如果make没有，那么需要安装下面的安装readline包，安装镜像中提供了readline安装包yum install -y readline*\n运行下面的命令使变量生效:\nsource .bash_profile\n\nogg2:#创建OGG安装目录mkdir /u01/oracle/oggchown -R ogg.oinstall /u01/oracle/ogg#切换至ogg用户su - ogg#配置环境变量vim .bash_profile# .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then        . ~/.bashrcfi# User specific environment and startup programsPATH=$PATH:$HOME/.local/bin:$HOME/binexport ORACLE_BASE=/u01/oracle/appexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATHexport ORACLE_SID=orclexport PATH=$ORACLE_HOME/bin:$ORACLE_HOME/jdk/bin:$PATH:/u01/oracle/ogg/alias sqlplus=&quot;/usr/bin/rlwrap sqlplus&quot;alias ggsci=&quot;/usr/bin/rlwrap ggsci&quot;alias sqlplus=&quot;rlwrap sqlplus&quot;alias ggsci=&quot;rlwrap ggsci&quot;\n运行下面的命令使变量生效:\nsource .bash_profile\n\n上传OGG安装介质将OGG安装文件上传到两台服务器的OGG操作系统用户的&#x2F;u01&#x2F;oracle&#x2F;ogg&#x2F;\ncd /u01/oracle/ogg/scp V34339-01.zip 192.168.65.140:/u01/oracle/ogg/unzip V34339-01.zipunzip V34339-01.ziprm -rf O*chown ogg:oinstall  fbo_ggs_Linux_x64_ora11g_64bit.tarsu - oggcd /u01/oracle/ogg/tar -xvf fbo_ggs_Linux_x64_ora11g_64bit.tar\n将fbo_ggs_Linux_x64_ora11g_64bit.tar解包到&#x2F;u01&#x2F;oracle&#x2F;ogg目录(源和目标端都需要操作)\n登录OGG测试[ogg@ora11g-1 ogg]$ ./ggsciOracle GoldenGate Command Interpreter for OracleVersion 11.2.1.0.3 14400833 OGGCORE_11.2.1.0.3_PLATFORMS_120823.1258_FBOLinux, x64, 64bit (optimized), Oracle 11g on Aug 23 2012 20:20:21Copyright (C) 1995, 2012, Oracle and/or its affiliates. All rights reserved.GGSCI (ora11g-1) 1&gt; \n如果LD_LIBRARY_PATH变量设置正确，会像上面演示一样正确进入命令行，如果提示找不到so文件，就需要 查看LD_LIBRARY_PATH变量是否正确设置。\n建立OGG表空间(两个库都做)ORACLE建议使用单独的表空间存放OGG数据，表空间大小50M就可以，但是最好设置数据文件的自动扩展。\nsu - oraclemkdir -pv /u01/oracle/app/oradata/orcl/oggsqlplus / as sysdbacreate tablespace tsp_ogg datafile &#x27;/u01/oracle/app/oradata/orcl/ogg/ogg01.dbf&#x27; size 100M autoextend on;\n\n创建OGG用户并授权(两个库都做)create user ogg identified by ogg default tablespace tsp_ogg;#OGG用户需要以下权限，也有人为了省事，直接给OGG用户DBA权限。如果直接给了DBA权限也要执行一下下面grant connect,resource to ogg;grant select any dictionary,select any table to ogg;grant alter any table to ogg;grant flashback any table to ogg;grant execute on dbms_flashback to ogg;grant execute on utl_file to ogg;grant create table,create sequence to ogg;grant insert any table to ogg;grant update any table to ogg;grant delete any table to ogg;\n不同的需求，OGG用户需要的权限也不一样，上面的权限基本可以支持大多数情况的数据复制，如上面的权限不足，需根据实际需求授权。\n必须开归档，打开数据库的附加日志和force logselect NAME,OPEN_MODE,FORCE_LOGGING,SUPPLEMENTAL_LOG_DATA_MIN from v$database;NAME      OPEN_MODE            FOR SUPPLEME——— ——————– — ——–ORCL   READ WRITE           NO  NO\n上面显示数据库的附加日志和force log都没有开启，使用下面的命令开启。（两个库都执行）\nalter database force logging;alter database add SUPPLEMENTAL log data;\n\n开启下面的参数要不然运行支持DDL脚本的时候会报错，（两个库都执行）\nalter system set enable_goldengate_replication=true scope=both;select NAME,OPEN_MODE,FORCE_LOGGING,SUPPLEMENTAL_LOG_DATA_MIN from v$database;NAME      OPEN_MODE            FOR SUPPLEME——— ——————– — ——–ORCL   READ WRITE           YES YES\n\n运行OGG支持DDL脚本\n如果要让OGG支持DDL操作，还需要额外运行几个脚本，这些脚本是OGG带的而不是ORACLE带的，在OGG的安装目录都可以找到，如果在OGG的安装目录登录数据库，可以直接@加脚本的名字\n\n源端与目标端都需要运行，如下：\nsu - oggcd /u01/oracle/ogg/sqlplus / as sysdba@marker_setup.sqlogg@ddl_setup.sqlogg@role_setup.sqlogg@ddl_enable.sql\n如果没有在OGG的安装目录登录数据库，需要指定脚本的位置，比如我的OGG安装目录为&#x2F;u01&#x2F;oracle&#x2F;ogg。\nsqlplus / as sysdba@/u01/oracle/ogg/marker_setup.sql@/u01/oracle/ogg/ddl_setup.sql@/u01/oracle/ogg/role_setup.sql@/u01/oracle/ogg/ddl_enable.sql\n\n创建OGG的管理目录\n在正式配置OGG之前，首先需要创建OGG的管理目录，源端和目标端都需要创建，登录OGG，只需要执行create subdirs命令就可以了。\n\n源端 和 目标端 都要执行：\nggsci----GGSCI (ora11g-1) 1&gt; create subdirsCreating subdirectories under current directory /u01/oracle/oggParameter files                /u01/oracle/ogg/dirprm: already existsReport files                   /u01/oracle/ogg/dirrpt: createdCheckpoint files               /u01/oracle/ogg/dirchk: createdProcess status files           /u01/oracle/ogg/dirpcs: createdSQL script files               /u01/oracle/ogg/dirsql: createdDatabase definitions files     /u01/oracle/ogg/dirdef: createdExtract data files             /u01/oracle/ogg/dirdat: createdTemporary files                /u01/oracle/ogg/dirtmp: createdStdout files                   /u01/oracle/ogg/dirout: created----\nogg管理目录的用途dirprm  存放ogg各参数的配置信息dirrpt  存放进程报告文件dirchk  存放检查点文件dirpcs  存放进程状态文件dirsql  存放SQL脚本文件dirdef  存放DEFGEN工具生成的数据定义文件dirdat  存放Trail文件,也就是Capture进程捕获的日志文件dirtmp  当事务需要的内存超过已分配内存时，默认存储在这个目录\nOGG复制流程之前所做的只是准备工作，现在就可以正式配置OGG了，在配置OGG之前，先看下OGG的复制流程\n\nOGG和其他传统复制软件一样1.通过源端捕获&#x2F;挖掘ORACLE的日志信息，2.目标端根据源端传送过来的日志信息进行重塑，实现源端-目标端数据同步。3.只有commit之后的日志信息才会被Capture进程捕获，未提交的事务OGG不会捕获。\n\n建立测试表源端：源端基于SCOTT用户的EMP和DEPT表建立EMP_OGG和DEPT_OGG测试表，包含数据。\n# alter user scott account unlock identified by tiger;创建测试用户及数据create user scott identified by tiger;grant connect,resource to scott;conn scott/tiger--创建表create table emp_ogg (EMPNO  number,name varchar2(20));insert into emp_ogg  values(1,&#x27;lijiaman&#x27;);insert into emp_ogg  values(2,&#x27;xiaoming&#x27;);insert into emp_ogg  values(3,&#x27;xiaohua&#x27;);create table dept_ogg (DEPTNO  number,name varchar2(20));insert into dept_ogg values(1,&#x27;lijiaman1&#x27;);insert into dept_ogg values(2,&#x27;xiaoming1&#x27;);insert into dept_ogg values(3,&#x27;xiaohua1&#x27;);\n\n目标端：目标端基于SCOTT用户的EMP和DEPT表建立EMP_OGG和DEPT_OGG测试表，不包含数据。\ncreate user scott identified by tiger;grant connect,resource to scott;conn scott/tiger--创建表create table emp_ogg (EMPNO  number,name varchar2(20));create table dept_ogg (DEPTNO  number,name varchar2(20));\n\n源端和目标端分别在EMP_OGG和DEPT_OGG测试表上建立主键(或唯一键)。源端和目标端：\nalter table EMP_OGG add constraint PK_EMPNO_OGG primary key (EMPNO);alter table DEPT_OGG add constraint PK_DEPTNO_OGG primary key (DEPTNO);\n\n端添加表级TRANDATA添加表级的trandata可以理解为需要将哪些用户的哪些表和目标库同步，其实也是添加表级的supplemental log，但是只有上文打开的minimal supplemental log后，这个才生效。OGG用户从OGG登录源端数据库。\n源端：cd &#x2F;u01&#x2F;oracle&#x2F;ogg 执行ggsci的时候要注意路径要在&#x2F;u01&#x2F;oracle&#x2F;ogg下，要不然会报错\nGGSCI (ora11g-1) 1&gt; DBLOGIN USERID ogg, PASSWORD oggSuccessfully logged into database.\n源端添加表级TRANDATA，本案例使用EMP_OGG和DEPT_OGG表。\nGGSCI (ora11g-1) 2&gt; add trandata scott.emp_oggLogging of supplemental redo data enabled for table SCOTT.EMP_OGG.GGSCI (ora11g-1) 3&gt; add trandata scott.dept_oggLogging of supplemental redo data enabled for table SCOTT.DEPT_OGG.\n成功添加表级TRANDATA后，可以通过INFO命令查看哪些表被添加了TRANDATA.\nGGSCI (ora11g-1) 4&gt; INFO TRANDATA scott.*Logging of supplemental redo log data is enabled for table SCOTT.DEPT_OGG.Columns supplementally logged for table SCOTT.DEPT_OGG: DEPTNO.Logging of supplemental redo log data is enabled for table SCOTT.EMP_OGG.Columns supplementally logged for table SCOTT.EMP_OGG: EMPNO.\n\n配置MGR管理进程源端：\nGGSCI (ora11g-1) 5&gt; EDIT PARAMS MGR#加入以下两行内容PORT 7809PURGEOLDEXTRACTS /u01/oracle/ogg/dirdat, USECHECKPOINTS\n\n目标端：\nGGSCI (ora11g-2) 1&gt; EDIT PARAMS MGR#加入以下两行内容PORT 7809PURGEOLDEXTRACTS /u01/oracle/ogg/dirdat, USECHECKPOINTS\n\n参数说明：PORT 7809：OGG管理进程监控端口。PURGEOLDEXTRACTS：清除不需要的trail文件。&#x2F;u01&#x2F;oracle&#x2F;ogg&#x2F;dirdat：trail文件存放位置。USECHECKPOINTS：使用检查点队列。\n\n配置完MGR管理进程后，就可以启动MGR管理进程(源端和目标端都需要启动)。\nGGSCI (ora11g-1) 6&gt; START MGRManager started.\n\n可以通过INFO命令查看进程的状态（最好每次启动时在两端都查看下）。\nGGSCI (ora11g-1) 7&gt; INFO MGRManager is running (IP port ora11g-1.7809).\n\n配置初始化数据进程\n由于在创建测试表的时候，源端的测试表有数据，而目标端的测试表只有结构，没有数据，所以需要初始化目标端的数据，所谓初始化，就是让目标端的数据和源端的数据在这个时间点是一模一样的，所以初始化工作并不需要一定使用OGG，也可以使用EXP、EXPDP、SQLLOAD等其他工具，本文主要介绍如何使用OGG进行数据初始化\n\n下面在源端配置捕获进程EINI_1\nGGSCI (ora11g-1) 9&gt; ADD EXTRACT EINI_1, SOURCEISTABLEEXTRACT added.\n\n查看EINI_1进程状态\nGGSCI (ora11g-1) 10&gt; INFO EXTRACT *, TASKSEXTRACT    EINI_1    Initialized   2022-07-11 21:13   Status STOPPEDCheckpoint Lag       Not AvailableLog Read Checkpoint  Not Available                     First Record         Record 0Task                 SOURCEISTABLE\n\n由于只是添加了捕获进程EINI_1，还没有进行配置和启动这个进程，所以现在的状态是STOPPED状态。\n\n源端编辑捕获进程EINI_1\nGGSCI (ora11g-1) 10&gt; EDIT PARAMS EINI_1#加入以下内容EXTRACT EINI_1SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)USERID ogg, PASSWORD oggRMTHOST 192.168.65.140, MGRPORT 7809RMTTASK REPLICAT, GROUP RINI_1TABLE scott.EMP_OGG;TABLE scott.DEPT_OGG;\n\n\n参数介绍：EXTRACT EINI_1：说明这是EXTRACT进程，名字是EINI_1SETENV：环境变量，一定要设置和数据库字符集一样，否则可能会乱码USERID：数据库OGG用户PASSWORD：数据库用户OGG的密码RMTHOST：目标端地址，如果在&#x2F;etc&#x2F;hosts文件里已经设置解析，可以写主机名MGRPORT：目标端MGR管理进程监听的端口RMTTASK REPLICAT：目标端REPLICAT应用进程的组和名字TABLE：源端要初始化数据的表的名字 编辑好捕获进程EINI_1后，还需要在目标端配置REPLICAT应用进程，名字要和源端的捕获进程EINI_1里面RMTTASK REPLICAT参数配置的一样， 也就是还需要在目标端配置RMTTASKREPLICAT RINI_1。\n\n配置目标端REPLICAT进程目标端：\nGGSCI (ora11g-2) 5&gt; EDIT PARAMS RINI_1#加入以下内容REPLICAT RINI_1SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)ASSUMETARGETDEFSUSERID ogg, PASSWORD oggDISCARDFILE /u01/oracle/ogg/dirrpt/RINIaa.dsc, PURGEMAP scott.*, TARGET scott.*;\n\n参数介绍：REPLICAT RINI_1：说明这是REPLICAT应用进程，名字叫RINI_1SETENV：语言变量，同捕获进程EINI_1ASSUMETARGETDEFS：告诉OGG目标端和源端需要同步的表的结构完全一致，不需要OGG去检查表的结构，包括表名、字段名、字段类型、字段长度等，如果目标端和源端同步的表的结构不一样，需要使用SOURCEDEFS参数，详见OGG官方文档。USERID、PASSWORD：同捕获进程EINI_1DISCARDFILE：错误信息存放位置及命名规则MAP：源端捕获的表的名字 TARGET：目标端同步的表的名字，可以不在同一SCHEMA。\n\n初始化数据在目标服务器执行下面语句：\nGGSCI (ora11g-2) 6&gt; ADD REPLICAT RINI_1,SPECIALRUNREPLICAT added.GGSCI (ora11g-2) 7&gt; INFO REPLICAT RINI_1 DETAILREPLICAT   RINI_1    Initialized   2022-07-11 21:22   Status STOPPEDCheckpoint Lag       00:00:00 (updated 00:00:13 ago)Log Read Checkpoint  Not AvailableTask                 SPECIALRUN  Extract Source                          Begin             End               Not Available                           * Initialized *   First Record    Current directory    /u01/oracle/oggReport file          /u01/oracle/ogg/dirrpt/RINI_1.rpt (does not yet exist)Parameter file       /u01/oracle/ogg/dirprm/rini_1.prmCheckpoint file      /u01/oracle/ogg/dirchk/RINI_1.cprProcess file         /u01/oracle/ogg/dirpcs/RINI_1.pcrStdout file          /u01/oracle/ogg/dirout/RINI_1.outError log            /u01/oracle/ogg/ggserr.log\n\n配置好目标端的应用进程RINI_1后，就可以启动源端的捕获进程进行捕获数据了。GGSCI (ora11g-1) 1&gt; START EXTRACT EINI_1Sending START request to MANAGER ...EXTRACT EINI_1 starting\n\n启动源端的捕获进程EINI_1后，正常情况下(如果配置没问题)，源端的数据已经传送到目标端了，可以通过VIEW命令查看源端捕获进程EINI_1的工作状态。\nGGSCI (ora11g-1) 11&gt; VIEW REPORT EINI_1#在最后部分会看到Output to RINI_1:From Table SCOTT.EMP_OGG:       #                   inserts:         3       #                   updates:         0       #                   deletes:         0       #                  discards:         0From Table SCOTT.DEPT_OGG:       #                   inserts:         3       #                   updates:         0       #                   deletes:         0       #                  discards:         0REDO Log Statistics  Bytes parsed                    0  Bytes output                  538\n\n如果配置正确，会看到上面的日志，日志会告诉你在目标端SCOTT.EMP_OGG表INSERT了3条记录，SCOTT.DEPT_OGG表INSERT了3条记录。如果在上面日志的最后部分出现ERROR，就需要去检查OGG的安装目录下的ggserr.log日志，这个日志相当于数据库的告警日志。\n验证初始化数据登录目标端数据库，查看初始化是否成功\nsqlplus / as sysdbaconn scott/tigerSQL&gt; select * from emp_ogg;     EMPNO NAME---------- --------------------\t 1 lijiaman\t 2 xiaoming\t 3 xiaohuaSQL&gt; select * from dept_ogg;    DEPTNO NAME---------- --------------------\t 1 lijiaman1\t 2 xiaoming1\t 3 xiaohua1\n可以看到初始化是正确的。初始化之后，上文提到的初始化进程（EINI_1、RINI_1）自动停止，因为通常情况下初始化数据工作只会做一次。可以通过INFO命令查看进程的状态。\n源端：\nGGSCI (ora11g-1) 5&gt; INFO EXTRACT EINI_1EXTRACT    EINI_1    Last Started 2022-07-11 21:38   Status STOPPEDCheckpoint Lag       Not AvailableLog Read Checkpoint  Table SCOTT.DEPT_OGG                     2022-07-11 21:38:21  Record 3Task                 SOURCEISTABLE\n\n目标端：\nGGSCI (ora11g-2) 1&gt; INFO REPLICAT RINI_1REPLICAT   RINI_1    Initialized   2022-07-11 21:22   Status STOPPEDCheckpoint Lag       00:00:00 (updated 00:23:20 ago)Log Read Checkpoint  Not AvailableTask                 SPECIALRUN\n\n源端和目标端配置OGG的检查点此步骤不是必须的，但是为了让OGG网络中断、服务器宕机、掉电等在突发情况也能正确断点续传，ORACLE建议配置OGG的检查点队列。\n源端和目标端都需配置。globals一定要是大写\nGGSCI&gt; EDIT PARAMS ./GLOBALS#加入以下信息CHECKPOINTTABLE ogg.ggschkpt\n这就告诉OGG检查点存放到OGG用户下的GGSCHKPT表中，但是还需要使用OGG用户登录数据库，创建检查点表，此时需要退出OGG，重新登录，否则可能会遇到下面的错误:\nGGSCI (ora11g-1) 7&gt; ADD CHECKPOINTTABLEERROR: Not logged into database, use DBLOGIN.或者ERROR: Missing checkpoint table specification.\n\n退出OGG，重新登录，并使用OGG用户登录数据库，源端和目标端都需要执行。\nGGSCI&gt; exitggsciGGSCI&gt; DBLOGIN userid ogg,PASSWORD oggSuccessfully logged into database.\n只需要执行ADD CHECKPOINTTABLE命令，OGG会自动在ORACLE的OGG用户下创建检查点，源端和目标端都需要执行。\nGGSCI (ora11g-1) 2&gt; ADD CHECKPOINTTABLENo checkpoint table specified, using GLOBALS specification (ogg.ggschkpt)...Successfully created checkpoint table ogg.ggschkpt.\n此时用OGG登录数据库，就可以看到OGG创建的检查点表。\n[ogg@ora11g-1 ogg]$ sqlplus ogg/oggSQL*Plus: Release 11.2.0.4.0 Production on Mon Jul 11 21:52:31 2022Copyright (c) 1982, 2013, Oracle.  All rights reserved.Connected to:Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; select * from tab;TNAME\t\t\t       TABTYPE\tCLUSTERID------------------------------ ------- ----------GGSCHKPT\t\t       TABLEGGSCHKPT_LOX\t\t       TABLE\n\n\n源端配置捕获进程现在已经可以配置数据同步了，下面在源端配置捕获进程。\nGGSCI (ora11g-1) 10&gt; EDIT PARAMS EORA_1#加入以下内容EXTRACT EORA_1SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)USERID ogg, PASSWORD oggEXTTRAIL /u01/oracle/ogg/dirdat/aaTABLE scott.EMP_OGG;TABLE scott.DEPT_OGG;\n参数介绍：以上参数基本都在上文提过，这里不在重复，说下EXTTRAIL参数，EXTTRAIL参数是TRAIL队列文件存放的路径和命名格式，TRAIL文件可以理解为存放捕获进程捕获的日志文件。此时还需要将捕获进程EORA_1添加到OGG。\nGGSCI (ora11g-1) 11&gt; ADD EXTRACT EORA_1, TRANLOG, BEGIN NOWEXTRACT added.GGSCI (ora11g-1) 12&gt; ADD EXTTRAIL /u01/oracle/ogg/dirdat/aa, EXTRACT EORA_1, MEGABYTES 5EXTTRAIL added.\n\n上面的两个命令告诉OGG，捕获进程从启动起开始捕获，捕获数据保存到TRAIL文件，及TRAIL文件的路径、命名格式，单个TRAIL文件最大大小。\n现在就可以启动源端捕获进程EORA_1了。\nGGSCI (ora11g-1) 13&gt; START EXTRACT EORA_1Sending START request to MANAGER …EXTRACT EORA_1 starting\n使用INFO命令查看EORA_1进程是否是RUNNING状态。\nGGSCI (ora11g-1) 14&gt; INFO EXTRACT EORA_1EXTRACT    EORA_1    Last Started 2021-07-01 22:30   Status RUNNINGCheckpoint Lag       00:00:00 (updated 00:00:07 ago)Log Read Checkpoint  Oracle Redo Logs                     2021-07-01 22:30:38  Seqno 17, RBA 35049472                     SCN 0.246224 (246224)\n\n\n源端配置PUMP传输进程此步骤也是非必须的，如果不配置传输进程，OGG会通过EXTRACT进程传输TRAIL队列文件，但是和检查点队列一样，为了保证断点续传ORACLE建议配置PUMP传输进程。\n新增抽取进程PORA_1，基于日志方式，立即生效\nGGSCI&gt; ADD EXTRACT PORA_1,TRANLOG,BEGIN NOW\n生成并编辑同名配置文件\nGGSCI (ora11g-1) 15&gt; EDIT PARAMS PORA_1\n\n加入以下内容\nEXTRACT PORA_1USERID ogg,PASSWORD oggSETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)RMTHOST 192.168.65.140, MGRPORT 7809RMTTRAIL /u01/oracle/ogg/dirdat/paDYNAMICRESOLUTIONGETTRUNCATESTABLE scott.EMP_OGG;TABLE scott.DEPT_OGG;\n参数说明\nEXTRACT PORA_1                       #抽取进程名USERID ogg,PASSWORD ogg              #连接本机DB的帐号密码SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)RMTHOST 192.168.65.140, MGRPORT 7809   #目标数据库服务器地址和GG服务端口号RMTTRAIL /u01/oracle/ogg/dirdat/pa               #远程队列的位置（下一步建的东西）DYNAMICRESOLUTION\t\t\t\t\t  #优化参数，动态分析表结构GETTRUNCATES\t\t\t\t\t\t  #抓取truncate数据TABLE scott.EMP_OGG;                  #需要抽取的表，可以使用通配符TABLE scott.DEPT_OGG;\n\n添加PUMP进程PORA_1到OGG，并指定本地的TRAIL文件。\nGGSCI (ora11g-1) 16&gt; ADD EXTRACT PORA_1, EXTTRAILSOURCE /u01/oracle/ogg/dirdat/aaEXTRACT added.\n\n为PUMP进程PORA_1指定将本地TRAIL文件传输到目标端后保存成目标端TRAIL文件的名字。\nGGSCI (ora11g-1) 18&gt; ADD RMTTRAIL /u01/oracle/ogg/dirdat/pa, EXTRACT PORA_1, MEGABYTES 5RMTTRAIL added.\n下面就可以启动PUMP进程PORA_1了，启动后看下PORA_1的状态。\nGGSCI (ora11g-1) 19&gt; START EXTRACT PORA_1Sending START request to MANAGER …EXTRACT PORA_1 starting\n查看状态\nGGSCI (ora11g-1) 20&gt; INFO EXTRACT PORA_1EXTRACT    PORA_1    Last Started 2021-07-01 22:34   Status RUNNINGCheckpoint Lag       00:03:22 (updated 00:00:04 ago)Log Read Checkpoint  Oracle Redo Logs                     2021-07-01 22:31:38  Seqno 17, RBA 35050000                     SCN 0.0 (0)\n\n目标数据库端添加复制应用进程（replicat process）在目标端GoldenGate命令行中配置复制进程：–新增复制进程，使用对应的队列pa，即刻开始，使用文件检查点\nGGSCI (ora11g-2)&gt;  ADD REPLICAT RORA_1 EXTTRAIL /u01/oracle/ogg/dirdat/pa,BEGIN NOW,NODBCHECKPOINT\n配置复制进程参数\nGGSCI (ora11g-2)&gt;  EDIT PARAMS RORA_1 REPLICAT RORA_1SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)USERID ogg, PASSWORD oggreperror default,discard HANDLECOLLISIONSASSUMETARGETDEFSgettruncatesDISCARDFILE /u01/oracle/ogg/dirrpt/RORA_aa.DSC,append,megabytes 100MAP scott.emp_ogg, TARGET scott.emp_ogg;MAP scott.dept_ogg, TARGET scott.dept_ogg;\n参数说明\nREPLICAT RORA_1                         #复制进程名SETENV (NLS_LANG=AMERICAN_AMERICA.ZHS16GBK)USERID ogg, PASSWORD ogg                #目标数据库的帐号密码reperror default,discard                #如果复制数据出错则忽略HANDLECOLLISIONSASSUMETARGETDEFS                        #两台数据库数据结构一致则使用此参数gettruncates                            #复制truncate操作    DISCARDFILE /u01/oracle/ogg/dirrpt/RORA_aa.DSC,append,megabytes 100 #错误信息写入XXXX文件，追加模式，最大100mMAP scott.emp_ogg, TARGET scott.emp_ogg; #映射关系，注意target前必须留一个空格MAP scott.dept_ogg, TARGET scott.dept_ogg;\n\n开启复制进程：\nGGSCI (ora11g-2) 6&gt; START RORA_1Sending START request to MANAGER ...REPLICAT RORA_1 startingGGSCI (ora11g-2) 7&gt; INFO RORA_1REPLICAT   RORA_1    Last Started 2021-07-01 22:45   Status RUNNINGCheckpoint Lag       00:00:00 (updated 00:00:02 ago)Log Read Checkpoint  File /u01/oracle/ogg/dirdat/pa000000                     2021-07-01 22:44:44.000000  RBA 1012\n\n至此，一个最简单的同步配置完成，对于源数据库相应表的insert，update，delete和truncate操作都将通过日志捕获并同步到目标数据库。\n\n验证OGG复制\n成功配置并启动以上进程后，就可以验证OGG数据同步了，最简单的测试就是修改源库同步的表的数据，测试需要测试DML和DDL\n\nogg 运维命令-管理进程命令INFO MANAGER                返回有关管理器端口和进程id的信息。START MANAGER              开启管理进程STATUS MANAGER            返回管理进程状态STOP MANAGER               停止管理进程--采集进程命令ADD EXTRACT                  添加一个采集组ALTER EXTRACT                更改采集组的属性CLEANUP EXTRACT          删除采集组的运行历史记录DELETE EXTRACT              删除采集组。INFO EXTRACT                 返回有关采集组的信息。KILL EXTRACT                   强制终止采集组。LAG EXTRACT                   返回有关采集延迟的信息。REGISTER EXTRACT          向Oracle数据库注册采集组START EXTRACT               启动采集组STATS EXTRACT               返回处理采集的统计信息。STATUS EXTRACT            返回采集组的状态STOP EXTRACT               停止采集组。FORCEAPPEND               允许data pump在现有的初始加载文件上添加新的跟踪文件UNREGISTER EXTRACT   从Oracle数据库注销采集组。--Replicat 进程命令ADD REPLICAT                添加一个复制组ALTER REPLICAT              更改复制组的属性。CLEANUP REPLICAT        删除复制组的运行历史。DELETE REPLICAT           删除一个复制组。INFO REPLICAT              返回关于复制组的信息。KILL REPLICAT               强制终止一个复制组。LAG REPLICAT               返回关于复制延迟的信息。REGISTER REPLICAT       向Oracle数据库注册一个复制组。START REPLICAT             启动一个复制组。STATS REPLICAT             返回处理一个复制组的统计信息。STATUS REPLICAT           返回一个复制组的状态。STOP REPLICAT              停止复制组。-- ER 命令INFO ER *             返回有关指定的通配符组的信息。KILL ER *               强制终止指定的通配符组。LAG ER *               返回有关指定通配符组的滞后信息START ER *           启动指定的通配符组。STATS ER *            返回处理指定通配符的统计信息组。STATUS ER *          返回指定的通配符组的状态。STOP ER *             停止指定的通配符组。--trail 文件相关命令ADD EXTTRAIL             添加到Oracle GoldenGate配置的本地跟踪。ADD RMTTRAIL           添加到Oracle GoldenGate配置的远程跟踪。ALTER EXTTRAIL          更改本地路径的属性。ALTER RMTTRAIL        更改远程跟踪的属性DELETE EXTTRAIL       从Oracle GoldenGate配置中移除本地踪迹。DELETE RMTTRAIL     从Oracle GoldenGate配置中删除远程跟踪。INFO EXTTRAIL         返回关于本地路径的信息。INFO RMTTRAIL        返回关于远程跟踪的信息。--编辑配置相关EDIT PARAMS                在默认文本编辑器中打开参数文件SET EDITOR                  设置用于编辑参数文件的默认文本编辑器程序。VIEW PARAMS             在屏幕上以只读模式显示参数文件的内容。INFO PARAM                 返回参数定义信息。--检查点相关命令Command                     DescriptionADD CHECKPOINTTABLE         创建一个检查点CLEANUP CHECKPOINTTABLE     删除不再需要的检查点记录。DELETE CHECKPOINTTABLE      删除检查点INFO CHECKPOINTTABLE        返回关于检查点的信息。--系统命令INFO ALL                    显示系统上所有Oracle GoldenGate进程的状态和延迟。                   OBEY                         处理包含Oracle GoldenGate命令列表的文件。SHELL                        在GGSCI接口中执行shell命令。SHOW                       显示Oracle GoldenGate环境的属性。VERSIONS                 显示有关操作系统和数据库的信息。VIEW GGSEVT          显示Oracle GoldenGate错误日志(ggserr.logfile)。VIEW REPORT           显示由Extract或Replicat生成的进程报告或丢弃文件。\n","categories":["技术"],"tags":["技术","linux","oracle","心得","ogg"]},{"title":"Oracle数据库迁移的几种方式","url":"/2021/02/06/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","content":"Oracle数据库迁移的几种方式\n我们常常需要对数据进行迁移，迁移到更性能配置更高级的主机OS上、迁移到远程的机房、迁移到不同的平台下，以下介绍ORACLE的几种数据库迁移方案：\n\n一、exp&#x2F;imp逻辑备份与恢复：它是最常用最简单的方法，一般是基于应用的owner级做导出导入。\n操作方法为：\n在新库建立好owner和表空间，停老库的应用，在老库执行：\n$ exp user/pwd owner=XXX file=exp_xxx.dmp log=exp_xxx.log buffer=6000000\n\n导入dmp文件到新库，在新库执行如下命令：\n$ imp user/pwdfromuser=XXX touser=XXX file=exp_xxx.dmp log=imp_xxx.log ignore=y\n\n优缺点：优点是可以跨平台使用;缺点是停机时间长，停机时间为从exp到网络传输到新库，再加上imp的时间。\n\n迁移实例，列如：\n\n\n检查Linux上数据库实例的编译格式\n\nSQL&gt; select userenv(&#x27;language&#x27;) from dual;USERENV(&#x27;LANGUAGE&#x27;)----------------------------------------------------AMERICAN_AMERICA.ZHS16GBK --牢记这个编码格式\n\n设置windows的环境变量\n\nNLS_LANG=AMERICAN_AMERICA.ZHS16GBK\n\n\n导出windows数据库中的数据库文件\n\nd:\\app\\administrator\\product\\11.2.0\\client_1\\BIN\\exp.exe test/pwd@orcl direct=n &quot;file=D:\\db_20200918.dmp&quot; &quot;log=D:\\db_20200918.exp&quot;\n\n通过工具将dmp文件上传到Linux上\n\n设置Linux的环境变量\n\n\nexport NLS_LANG=AMERICAN_AMERICA.ZHS16GBK\n\n\n在Linux上创建相关用户及表空间\n\n--创建表空间create tablespace TESTDBdatafile &#x27;/u01/app/oracle/oradata/TESTDB.DBF&#x27;size 100Mreuseautoextend onnext 100Mmaxsize unlimitedonlinenologgingsegment space management autodefault nocompress; --创建用户create user  test identified by &quot;pwd&quot; ;grant connect, resource,dba to test ;grant create any sequence to test ;GRANT SELECT ANY TABLE TO test ;GRANT UPDATE ANY TABLE TO test ;alter user test  DEFAULT TABLESPACE TESTDB;\n\n\n导入dmp文件\n\n imp userid=test/pwd@orcl full=y ignore=y file=&#x27;/dmp/db_20200918.dmp&#x27; log=&#x27;/dmp/db_20200918.imp&#x27;\n二、Storage存储迁移：这种情况下，数据文件、控制文件、日志文件、spfile都在存储上(一般情况下是裸设备)，我们可以直接把存储挂到新机器上，然后在新机器上启动数据库。\n操作方法：\n\n将老库的pfile(因为里面有指向裸设备的spfile链接)，tnsnames.ora，listener.ora，密码文件传到新库的对应位置。将存储切至新机，或者用文件拷贝或dd的方式复制数据文件，启动数据库。\n\n优缺点：优点是该迁移方式非常简单，主要的工作是主机工程师的工作，dba只需配合即可，停机时间为停库、切存储、起库的时间；缺点是要求新老库都是同一平台，是相同的数据库版本。\n三、利用data guard迁移：用dg我们不仅可以用来做容灾，物理的dg我们还可以作为迁移的方式。关于DG的操作方式，详情点击 &#x3D;&gt; DG搭建\n","categories":["技术"],"tags":["技术","linux","oracle","心得","数据迁移"]},{"title":"Oracle12c跨平台迁移之linux至windows","url":"/2022/09/06/Oracle12c%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%81%E7%A7%BB%E4%B9%8Blinux%E8%87%B3windows/","content":"\n需求为迁移centos 7.2 linux的oracle12.2数据库至windows server 2016操作系统上，并做好数据备份。虽然个人不建议数据库跑在windows下，但由于业主方懂linux系统的人员有限，故此整理文档如下，供后期参考。\n\n1.环境检查及准备\n检查linux系统的使用空间\n准备等量的windows系统环境\n书写rman下的0级备份脚本\n制定迁移计划和停机时间\n\n由于linux系统空间已接近使用完毕且无法新增硬盘，考虑不影响正式环境的情况下，采用挂载windows共享目录的方式进行存储原有oracle数据库的相关备份文件。\n#挂载共享目录脚本mount -t cifs -o \\username=administrator,\\password=password,rw,uid=500,gid=501,\\dir_mode=0777,file_mode=0777 //windows的IP地址/共享目录 /mnt/backup/#uid和gid分别为oracle用户的用户ID和所属组的ID号。\n\n2.全备linux上的oracle数据库#rman全量0备份脚本rman log=&#x27;/mnt/backup/rman/db_rman0.log&#x27; append &lt;&lt;EOFconnect target /;run&#123;allocate channel ch1  device type disk;allocate channel ch2  device type disk;allocate channel ch3  device type disk;sql &#x27;alter system checkpoint&#x27;;sql &#x27;alter system switch logfile&#x27;;sql &#x27;alter system archive log current&#x27; ;CONFIGURE SNAPSHOT CONTROLFILE NAME TO &#x27;/mnt/backup/rman/ctl_bakup.ctl&#x27;;backup incremental level 0 filesperset 10 tag &#x27;db0&#x27; format &#x27;/mnt/backup/rman/db0_%d_%T_%s&#x27; database include current controlfile plus archivelog filesperset 10 format &#x27;/mnt/backup/rman/arc0_%d_%T_%s&#x27;;backup format &#x27;/mnt/backup/rman/ctl_%U.%T&#x27; current controlfile;backup spfile format &#x27;/mnt/backup/rman/spfile_%d_%s_%T&#x27;;crosscheck backup of database;      crosscheck archivelog all;crosscheck backup of controlfile;release channel ch1;release channel ch2;release channel ch3;&#125;EXIT;EOF#分别备份oracle数据库的控制文件、数据文件、归档日志和参数文件。\n\n3.迁移相关备份文件至目标服务器\n压缩传输、直接拷贝、网络传输备份文件至目标服务器。目标服务器安装JDK环境并下载oracle12c安装文件。\n\n\nJdk8u231下载路径：点击链接下载jdk8u231软件\nOracle12c下载路径：点击链接下载Oracle12c软件\n\n4.目标服务器安装oracle软件这里需要先安装数据库软件和配置监听，不需要建库。\n\n5.目标服务器创建相关目录#新建目录md D:\\u01\\app\\oracle\\cd D:\\u01\\app\\oracle\\md admin\\alov2 oradata\\alov2 archivelog cd D:\\u01\\app\\oracle\\admin\\alov2md adump bdump cdump dpdump udump pfile#新建密码文件orapwd file=D:\\app\\admin\\virtual\\product\\12.2.0\\dbhome_1\\dbs\\orapwalov2 password=’Shbus12#$’#新建监听sidoradim -new -sid alov2\n\n注册表新增sid字符串值\n6.修改参数文件并启动数据库#参数文件信息D:\\test.oraalov2.__data_transfer_cache_size=0alov2.__db_cache_size=8858370048alov2.__inmemory_ext_roarea=0alov2.__inmemory_ext_rwarea=0alov2.__java_pool_size=268435456alov2.__large_pool_size=1409286144alov2.__oracle_base=&#x27;D:\\app\\admin\\virtual&#x27;#ORACLE_BASE set from environmentalov2.__pga_aggregate_target=4429185024alov2.__sga_target=21474836480alov2.__shared_io_pool_size=536870912alov2.__shared_pool_size=8053063680alov2.__streams_pool_size=134217728*._bloom_filter_enabled=TRUE*._datafile_open_errors_crash_instance=FALSE*._datafile_write_errors_crash_instance=FALSE*._drop_stat_segment=1*._enable_NUMA_optimization=FALSE*._ges_direct_free_res_type=&#x27;CTARAHDXBB&#x27;*._index_partition_large_extents=&#x27;FALSE&#x27;*._keep_remote_column_size=TRUE*._optimizer_adaptive_cursor_sharing=FALSE*._optimizer_ads_use_result_cache=FALSE*._optimizer_aggr_groupby_elim=FALSE*._optimizer_dsdir_usage_control=0*._optimizer_extended_cursor_sharing=&#x27;NONE&#x27;*._optimizer_extended_cursor_sharing_rel=&#x27;NONE&#x27;*._optimizer_null_aware_antijoin=TRUE*._optimizer_reduce_groupby_key=FALSE*._optimizer_unnest_scalar_sq=FALSE*._optimizer_use_feedback=FALSE*._partition_large_extents=&#x27;FALSE&#x27;*._PX_use_large_pool=TRUE*._report_capture_cycle_time=0*._sql_plan_directive_mgmt_control=0*._undo_autotune=FALSE*._upgrade_capture_noops=FALSE*._upgrade_optim=FALSE*._use_adaptive_log_file_sync=&#x27;FALSE&#x27;*.audit_file_dest=&#x27;D:\\u01\\app\\oracle\\admin\\alov2\\adump&#x27;*.audit_trail=&#x27;NONE&#x27;*.compatible=&#x27;12.2.0&#x27;*.control_files=&#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\control01.ctl&#x27;,&#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\control02.ctl&#x27;,&#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\control03.ctl&#x27;*.db_block_size=8192*.db_name=&#x27;alov2&#x27;*.deferred_segment_creation=FALSE*.diagnostic_dest=&#x27;D:\\app\\admin\\virtual&#x27;*.disk_asynch_io=TRUE*.dispatchers=&#x27;(PROTOCOL=TCP) (SERVICE=alov2XDB)&#x27;*.event=&#x27;28401 trace name context forever,level 1&#x27;,&#x27;10949 trace name context forever,level 1&#x27;*.filesystemio_options=&#x27;SETALL&#x27;*.inmemory_size=2147483648*.log_archive_dest_1=&#x27;LOCATION=D:\\u01\\app\\oracle\\archivelog\\&#x27;*.nls_language=&#x27;AMERICAN&#x27;*.nls_territory=&#x27;AMERICA&#x27;*.open_cursors=300*.parallel_force_local=TRUE*.pga_aggregate_limit=0*.pga_aggregate_target=4164m*.processes=3200*.remote_login_passwordfile=&#x27;EXCLUSIVE&#x27;*.resource_limit=TRUE*.resource_manager_plan=&#x27;force:&#x27;*.sga_max_size=21474836480*.sga_target=21474836480*.undo_tablespace=&#x27;UNDOTBS1&#x27;\n\n还原备份的控制文件并以mount的方式启动数据库#配置恢复监听文件并在sql窗口下执行startup nomount pfile=&#x27;D:\\test.ora&#x27;;#rman窗口下执行配置数据库的DBIDset DBID=原DBID;#rman恢复控制文件，也可通过备份的控制文件直接拷贝恢复。restore controlfile from &#x27;D:\\share\\rman\\ctl_ALOV2_5876_20191028_1&#x27;;alter database mount;\n\n7.恢复数据库并重新定义文件目录#rman窗口下执行catalog start with &#x27;D:\\share\\rman&#x27;;list backupset;run&#123;allocate channel c1 type disk;allocate channel c2 type disk;allocate channel c3 type disk;set newname for datafile 1 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\system01.dbf&#x27;;set newname for datafile 2 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\undotbs01.dbf&#x27;;set newname for datafile 3 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\sysaux01.dbf&#x27;;set newname for datafile 4 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\users01.dbf&#x27;;set newname for datafile 5 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\TANG01.dbf&#x27;;set newname for datafile 6 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\TANG02.dbf&#x27;;set newname for datafile 7 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\ALODB_DATA01.dbf&#x27;;set newname for datafile 8 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\FOLLOWUP01.dbf&#x27;;set newname for datafile 9 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\FOLLOWUP02.dbf&#x27;;set newname for datafile 10 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\ALODB_DATA02.dbf&#x27;;set newname for datafile 11 to &#x27;D:\\u01\\app\\oracle\\oradata\\alov2\\ALODB_DATA03.dbf&#x27;;restore database;switch datafile all;release channel c1;release channel c2;release channel c3;&#125;recover database preview;list backup;recover database until scn scnid;alter database open resetlogs;#sql窗口下执行创建spfile参数文件create spfile from pfile=’D:\\test.ora’;\n\n8.配置windows下的oracle开机自启\n\n\n\n9.配置windows下的oracle数据库的自动备份#修复归档日志路径之清理无用备份信息：execute sys.dbms_backup_restore.resetCfileSection(11);#重新指定归档日志的存储路径：catalog start with &#x27;D:\\u01\\app\\oracle\\archivelog&#x27;;#制定备份计划：周三和周日全备其余增备\n\n0级全量备份脚本rmanbaklevel0.batrem ******Oracle backup start******@echo off::设置时间变量set &quot;Ymd=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%&quot;::删除一周前的备份数据forfiles /p &quot;E:\\backup\\rmandb&quot; /m db0* -d -7 /c &quot;cmd /c del /f @path&quot;forfiles /p &quot;E:\\backup\\rmanlog&quot; /m arc0* -d -7 /c &quot;cmd /c del /f @path&quot;::执行备份操作rman target / CMDFILE &#x27;D:\\app\\admin\\virtual\\cmdfile\\rmanbaklevel0.txt&#x27; LOG &#x27;E:\\backup\\baklogs\\rman_baklevel0_%Ymd%.log&#x27;@echo onrem ******Oracle backup end******\n\n\n0级全量备份文件rmanbaklevel0.txtrun&#123;allocate channel ch1  device type disk;allocate channel ch2  device type disk;allocate channel ch3  device type disk;crosscheck archivelog all;delete expired archivelog all;sql &#x27;alter system checkpoint&#x27;;sql &#x27;alter system switch logfile&#x27;;sql &#x27;alter system archive log current&#x27; ;backup incremental level 0 filesperset 10 tag &#x27;db0&#x27; format &#x27;E:\\backup\\rmandb\\db0_%d_%T_%s&#x27; database include current controlfile plus archivelog filesperset 10 format &#x27;E:\\backup\\rmanlog\\arc0_%d_%T_%s&#x27;;backup format &#x27;E:\\backup\\rmanbak\\ctl_%U.%T&#x27; current controlfile;backup spfile format &#x27;E:\\backup\\rmanbak\\spfile_%d_%s_%T&#x27;;crosscheck backup of database;      crosscheck archivelog all;crosscheck backup of controlfile;delete force noprompt archivelog all completed before &#x27;sysdate-7&#x27;;release channel ch1;release channel ch2;release channel ch3;&#125;exit\n\n\n1级增量备份脚本rmanbaklevel1.batrem ******Oracle backup start******@echo off::设置时间变量set &quot;Ymd=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%&quot;::删除一周前的备份数据forfiles /p &quot;E:\\backup\\rmandb&quot; /m db1* -d -7 /c &quot;cmd /c del /f @path&quot;forfiles /p &quot;E:\\backup\\rmanlog&quot; /m arc1* -d -7 /c &quot;cmd /c del /f @path&quot;::执行备份操作rman target / CMDFILE &#x27;D:\\app\\admin\\virtual\\cmdfile\\rmanbaklevel1.txt&#x27; LOG &#x27;E:\\backup\\baklogs\\rman_baklevel1_%Ymd%.log&#x27;@echo onrem ******Oracle backup end******\n\n1级增量备份文件rmanbaklevel1.txtrun&#123;allocate channel ch1  device type disk;allocate channel ch2  device type disk;allocate channel ch3  device type disk;crosscheck archivelog all;delete expired archivelog all;sql &#x27;alter system checkpoint&#x27;;sql &#x27;alter system switch logfile&#x27;;sql &#x27;alter system archive log current&#x27; ;backup incremental level 1 filesperset 3 tag &#x27;db1&#x27; format &#x27;E:\\backup\\rmandb\\db1_%d_%T_%s&#x27; database include current controlfile plus archivelog filesperset 3 format &#x27;E:\\backup\\rmanlog\\arc1_%d_%T_%s&#x27;;backup format &#x27;E:\\backup\\rmanbak\\ctl_%U.%T&#x27; current controlfile;backup spfile format &#x27;E:\\backup\\rmanbak\\spfile_%d_%s_%T&#x27;;crosscheck backup of database;      crosscheck archivelog all;crosscheck backup of controlfile;delete force noprompt archivelog all completed before &#x27;sysdate-7&#x27;;release channel ch1;release channel ch2;release channel ch3;&#125;exit\n\n总结\n综上，整个迁移过程执行完毕，稍微有点复杂，建议多试验几次即可。当然还有其它的迁移方式，个人认为此种方案相对较为便捷。\n\n","categories":["技术"],"tags":["技术","linux","心得","数据迁移"]},{"title":"Oracle相关操作知识","url":"/2020/09/06/Oracle%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86/","content":"ORACLE 基础ORACLE 数据库具有以下特点：\n支持多用户、大事务量的事务处理数据安全性和完整性控制支持分布式数据处理可移植性\n\nORACLE 体系结构\n数据库\n实例\n数据文件(dbf)\n表空间\n用户\n\n在这里插入图片描述\n创建表空间create tablespace waterbossdatafile &#x27;+DATA/prod/datafile/spacse_name.dbf&#x27;size 100mautoextend onnext 10m--waterboss 为表空间名称--datafile 用于设置物理文件名称--size 用于设置表空间的初始大小--autoextend on 用于设置自动增长，如果存储量超---过初始大小，则开始自动扩容--next 用于设置扩容的空间大小\n\noracle迁移表空间数据文件迁移非关键数据表空间数据文件方案：\nalter tablespace BATRISKTS offline;--cp 原数据文件  新路径/数据文件alter tablespace BATRISKTS rename datafile &#x27;原数据文件&#x27; to &#x27;新数据文件&#x27;;alter tablespace BATRISKTS online;\n\n\n删除表空间：Drop tablespace 表空间名 including contents and datafiles;(所有数据及文件)例子：Drop tablespace epoint including contents and datafiles;查询所有表空间：SELECT * FROM dba_tablespaces;\n\n\n\n创建用户create user wateruseridentified by itcastdefault tablespace waterboss--wateruser 为创建的用户名--identified by 用于设置用户的密码--default tablesapce 用于指定默认表空间名称\n\n\n默认系统账号：\n\nSYS:拥有SYSDBA权限，可以关闭启动oracle，只能以SYSDBA或SYSPOPER登录SYSTEM:DBA权限，只能以Normal登录，管理数据库\n\n\noracle的别名需小心使用，因为有顺序，有时候无法引用。\n\n顺序：from  join  on  where group by  having  select  order by  limit\n\n\n\n用户赋权grant dba to wateruser\n\n\n用户与权限：\n\nOracle角色权限分类：Connect：只能登录，无法操作Resource：可以在自己的模式下操作对象DBA:拥有全部权限，只有DBA才可以创建数据库结构\n\n\n表的创建、修改与删除\nOracle创建表时，约束索引需要单独创建，不能和表一起创建。\n\n创建表CREATE TABLE 表名称(字段名 类型(长度) primary key,字段名 类型(长度),.......);\n\n数据类型：\n字符型\n\n\nCHAR : 固定长度的字符类型，最多存储 2000 个字节VARCHAR2 :可变长度的字符类型，最多存储 4000 个字节LONG : 大文本类型。最大可以存储 2 个 G\n\n\n数值型\n\n\nNUMBER : 数值类型例如：NUMBER(5) 最大可以存的数为 99999NUMBER(5,2) 最大可以存的数为 999.99\n\n\n日期型\n\n\nDATE：日期时间型，精确到秒TIMESTAMP：精确到秒的小数点后 9 位\n\n\n二进制型（大数据类型）\n\n\nCLOB : 存储字符,最大可以存 4 个 GBLOB：存储图像、声音、视频等二进制数据,最多可以存 4 个 G\n\n修改表1.增加字段\nALTER TABLE 表名称 ADD(列名 1 类型 [DEFAULT 默认值]，列名 1 类型 [DEFAULT 默认值]…)\n\n\n2.修改字段\nALTER TABLE 表名称 MODIFY(列名 1 类型 [DEFAULT 默认值]，列名 1 类型 [DEFAULT 默认值]…)\n\n\n3.修改字段名\nALTER TABLE 表名称 RENAME COLUMN 原列名 TO 新列名\n\n\n4.删除字段名\nALTER TABLE T_OWNERS DROP COLUMN REMARK\n\n\n5.删除表\ndrop table 表名称\n\n\n数据增删改INSERT INTO 表名[(列名 1，列名 2，…)]VALUES(值 1，值2，…) ；UPDATE 表名 SET 列名 1=值 1，列名 2=值 2，…WHERE 修改条件；DELETE FROM 表名 WHERE 删除条件;TRUNCATE TABLE 表名称；---- 清空表数据\n\n比较 truncat 与 delete 实现数据删除？delete 删除的数据可以 rollbackdelete 删除可能产生碎片，并且不释放空间truncate 是先摧毁表结构，再重构表结构\n\n触发器：要素：1.事件类型(增删改) 2.触发事件：事件类型前后(before,after)3.触发对象：表中的每一条记录(行),即整张表作用:保证数据一致，基于某个表的变动在其他表记录，计算列的值或更新时间戳\n\n语法(mysql):Create trigger 触发器名 &#123;before|after &#123;insert|update|delete&#125; on 表名 for each row  begin  触发器执行的sql语句  end;&#125;触发器名称：64个字符(t或者tri开头)&#123;before|after&#125;：触发器执行的时间，事件发生前后&#123;insert|update|delete&#125;：触发的事件是什么表名：触发器属于那个表for each row：触发器的执行间隙，for each row子句通知触发器，每行执行一次动作Sql语句：事件触发时需要执行的sql语句New:表示将要或已经插入的数据或将要已经被修改的数据Old:被修改之前的数据或被删除之前的数据另外old是只读的，而new可以在触发器中使用set赋值且不会触发触发器，造成循环调用。\n插入操作：(插入的数据的行的字段改为大写)Create trigger tri_customer_state before insert on customers for each row beginSet new.cust.state=Upper(new.cust.state) end\n\n更新操作：(如果更新了，则记录在日志)Create trigger tri_custname_updateafter update on customers for each row beginIf new.cust_name != old.cust_name(数据修改了)  then  insert into cust_log  values(old.cust_name,new.cust_name,now());  end if;  end\n\n序列(oracle):mysql实现自增：\ncreate table a(id int not null auto_increment,....primary key(id));\n\noracle序列语法Oracle提供sequence对象，由系统提供自增长的序列号\nCreate sequence 序列名 [increment by n] [start with n] [maxvalue/minvalue n|nomaxvalue][cycle | nocycle] [cache n | nocache];1.increment by :定义序列的步长,不写则为1，为负则递减2.start with：序列的初始值，默认13.maxvalue/minvalue：定义序列能产生的最大最小值，默认nomaxvalue则无限制4.cycle | nocycle：表示序列生成到限制值是否循环，循环(cycle)则从最小序列开始5.cache n | nocache:定义存放序列的内存大小，默认20，nocache则不进行内存缓存，内存缓冲可以改善序列的性能\n创建序列：Create sequence seq_test increment by 1 minvalue 1 start with 1 maxvalue 9999 cache 50;获取序列当前值:select seq_test.currval from dual;(dual虚拟表)获取序列的下一个值:select seq_test.nextval from dual;\n\nOricle实现自增:创建序列：CREATE SEQUENCE Tab_UserInfo_Sequence START WITH 1 MINVALUE 1 MAXVALUE 999999999 INCREMENT BY 1 cache 20;创建使用自增序列的表：CREATE TABLE UserInfo(id number(10) NOT NULL,username varchar2(15) NOT NULL,password varchar2(15) NOT NULL,CONSTRAINTS PF_UserInfo PRIMARY key(id));使用触发器对表实现自增：CREATE TRIGGER Tig_UserInfo_insert BEFORE INSERT ON UserInfo FOR EACH ROW when(NEW.id IS null)BEGIN   SELECT Tab_UserInfo_Sequence.nextval INTO:NEW.id FROM dual;END\n\n关于事务\n事务：访问或更新数据库数据项的一个程序执行单元，关系型数据库中表现为一条或是一组SQL语句\n\n特性：①要么什么都做，要么什么都不做；②一个事务的执行与其他事务互不影响③一旦事务提交数据就具有持久性，其他程序或是故障部队其产生任何影响\n\n\n事务提交：commitcommit;（表示程序全部完成不出现任何故障）\n\n\n回滚数据：rollbackrollback; 回滚在没commit之前可以回滚程序到初始保存状态\n\n\n如何设置事务的保存点savepoint(sp1);--保存点后面的所有数据在执行回滚后都将失效，而在它之前的都将保留\n\n如何回滚到指定的保存点rollback to sp1;\n\n\n数据导出与导入整库导出与导入整库导出命令exp system/itcast full=y 或者 exp system/itcast file=文件名 full=y\n\n\n整库导入命令imp system/itcast full=y or imp system/itcast full=y file=water.dmp\n\n\n\n按用户导出与导入按用户导出exp system/itcast owner=wateruser file=wateruser.dmp\n\n\n按用户导入imp system/itcast file=wateruser.dmp fromuser=wateruser\n\n\n按表导出与导入按表导出exp wateruser/itcast file=a.dmp tables=t_account,a_area\n\n按表导入imp wateruser/itcast file=a.dmp tables=t_account,a_are\n\nORACLE 查询单表查询简单条件查询精确查询 select * from T_OWNERS where watermeter=‘30408’模糊查询 select * from t_owners where name like ‘%刘%’and 运算符 select * from t_owners where name like ‘%刘%’ and housenumber like ‘%5%’or 运算符 select * from t_owners where name like ‘%刘%’ or housenumber like ‘%5%’and 与 or 运算符混合使用 select * from t_owners where (name like ‘%刘%’ or housenumber like ‘%5%’) and addressid=3范围查询 select * from T_ACCOUNT where usenum&gt;=10000 and usenum&lt;=20000空值查询 select * from T_PRICETABLE t where maxnum is null\n\n\n去掉重复记录select distinct addressid from T_OWNERS\n\n\n排序查询升序排序 select * from T_ACCOUNT order by usenum降序排序 select * from T_ACCOUNT order by usenum desc\n\n\n基于伪列的查询ROWID 具体某一行数据的物理地址 select rowID,t.* from T_AREA tROWNUM 每一行的行号,查询后才会标注 select rownum,t.* from T_OWNERTYPE t\n\n\n聚合统计聚合函数\nsum* select sum(usenum) from t_account where year=‘2012’avg* select avg(usenum) from T_ACCOUNT where year=‘2012’max* select max(usenum) from T_ACCOUNT where year=‘2012’select* min(usenum) from T_ACCOUNT where year=‘2012’count* select count(*) from T_OWNERS t where ownertypeid=1分组聚合 Group by* select areaid,sum(money) from t_account group by areaid分组后条件查询 having* select areaid,sum(money) from t_account group by areaid having sum(money)&gt;169000\n\n\n连接查询多表内连接查询\n查询显示业主编号，业主名称，业主类型名称\n\nselect o.id 业主编号,o.name 业主名称,ot.name 业主类型from T_OWNERS o,T_OWNERTYPE otwhere o.ownertypeid=ot.id\n\n\n\n查询显示业主编号，业主名称、地址和业主类型\n\n select o.id 业主编号,o.name 业主名称,ad.name 地址, ot.name 业主类型 from T_OWNERS o,T_OWNERTYPE ot,T_ADDRESS ad where o.ownertypeid=ot.id and o.addressid=ad.id\n\n查询显示业主编号、业主名称、地址、所属区域、业主分类\n\n  select o.id 业主编号,o.name 业主名称,ar.name 区域, ad.name 地址, ot.name 业主类型  from T_OWNERS o ,T_OWNERTYPE ot,T_ADDRESS ad,T_AREA arwhere o.ownertypeid=ot.id and o.addressid=ad.id and ad.areaid=ar.id\n\n查询显示业主编号、业主名称、地址、所属区域、收费员、业主分类\n\nselect ow.id 业主编号,ow.name 业主名称,ad.name 地址,ar.name 所属区域,op.name 收费员, ot.name 业主类型from T_OWNERS ow,T_OWNERTYPE ot,T_ADDRESS ad ,T_AREA ar,T_OPERATOR opwhere ow.ownertypeid=ot.id and ow.addressid=ad.idand ad.areaid=ar.id and ad.operatorid=op.id\n\n\n左外连接查询\n查询业主的账务记录，显示业主编号、名称、年、月、金额。如果此业主没有账务记录也要列出姓名 SQL1999标准:\n\nSELECT ow.id,ow.name,ac.year ,ac.month,ac.moneyFROM T_OWNERS ow left join T_ACCOUNT acon ow.id=ac.owneruuid\n\n视图的创建与查询：Create view view_user as select id,name,age from user;(创建视图)Select * from view_user;(查询视图)\n\n\nOracle数据类型：Number(p,s):1-22字节，p表示有效数字的位数(38)，s表示精度，正则约束小数位数，负则约束整数小数点左边几位位数四舍五入。都不指定，则都取最大值。p默认为38，如果只指定p那s默认为0。Integer:1-22字节，存储整数(有小数则四舍五入)Char(n): 固定长度，0-2000字节(字符串类型)Varchar2(N):可变长，0-4000字节Date:7字节(日期类型)，可精确到秒Timestasmp：7字节,可精确到纳秒(9位)Blob：(大字段类型)，最大32TB,存储非结构化二进制数据Clob：4GB,存储大文本数据\n\nJDBC 连接 ORACLE&#x2F;&#x2F;加载驱动\nstatic&#123;    try &#123;        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);    Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);     catch (ClassNotFoundException e) &#123;        e.printStackTrace();    e.printStackTrace();    &#125;&#125;// 获取数据库连接public static java.sql.Connection getConnection() throwsSQLException&#123;    return java.sql.DriverManager.getConnection(&quot;jdbc:oracle:thin:@192.168.80.10:1521:orcl&quot;,&quot;wateruser&quot;, &quot;itcast&quot;);&#125;&#125;\n\n\nJDBC 驱动为：oracle.jdbc.OracleDriver\n\n\n连接字符串( 瘦连接 )：jdbc:oracle:thin:@服务器的 IP:1521:orcl\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"Oracle的体系结构","url":"/2021/05/06/Oracle%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"oracle 体系结构参数文件 spfile控制文件 control file数据文件 data file日志文件 redo log归档文件 archive log\n\n\n\noracle启动的时候会先读取spfile信息，根据spfile参数文件生成实例&#x3D;申请内存 + 启动一堆进程,且记录了控制文件control file的路径control file控制文件中记录了datafile文件路径data file 存储了相关的表的数据信息redo log记录了datafile数据的变化过程\n\n关于参数文件 spfilesql命令中输入以下命令，可查看到spfile的文件路径\nshow parameter spfile;\n\n关于控制文件 control filesql命令中输入以下命令，可查看到control file的文件路径\nselect * from v$controlfile;\nlinux命令中也可以看到,有两个控制文件control01.ctl和control02.ctl\n\nstrings control01.ctl\n\n\n关于数据文件 data file，sql命令中输入以下命令，可查看到data file的文件路径\nselect * from dba_data_files;\n关于日志文件 redosql命令中输入以下命令，可查看到redo的文件路径和状态\nselect * from v$logfile;\n关于实例名称show parameter instanceshow parameter instance_name\n\n数据库启动后，查看ipcs -m可以看到给oracle分配的共享内存\n查看oracle的进程\n\nps -ef | grep ora_\n\n数据文件\n\n数据文件会格式化为一个一个数据块 block (2k,4k,8k,16k,32k)\n\n block 默认8k\n内存的组成shared pool 减少硬解析buffer cache 减少物理读redo log buffer 缓存DML对数据块所做的操作\n\nlarge pool stream pool java pool\n\n关于shared poolselect * from v$sga_dynamic_components;\n\nshared pool是干啥的？\n\n作用是划分sql比如v$sql视图中可以看到所有执行的sql语句\n\n查看sql的执行计划select * from table(dbms_xplan.display_cursor(&#x27;这个是v视图中的sql_id&#x27;,0));\n创建和查看索引create index 索引名称 on 表名(列名);select * from all_indexes where table_name=&#x27;表名&#x27;;\n体系结构-进程结构server process\n","categories":["技术"],"tags":["技术","oracle","心得"]},{"title":"RAC、DG和OGG的区别","url":"/2022/06/06/RAC%E3%80%81DG%E5%92%8COGG%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"在Oracle中，RAC、DG和OGG的区别有哪些？什么是高可用？\n高可用（High Availability，HA）也可以称为高可用性或高可用环境。HA是分布式系统架构设计中必须考虑的因素之一。HA通常是指通过设计来减少系统不能提供服务的时间。假设系统一直能够提供服务，那么这时就可以称系统的可用性是100%。如果系统每运行100个时间单位，会有1个时间单位无法提供服务，那么可以称系统的可用性是99%。\n\n单点是系统高可用的最大的风险和敌人，应该尽量在系统设计的过程中避免单点。在方法论上\n\n高可用保证的原则是“集群化”，或者叫“冗余”。只有一个单点，挂了服务会受影响；如果有冗余备份，那么挂了还有其它备份能够继续提供服务。\n\n\nRAC提供了实例级别的冗余DG提供了数据存储级别的冗余。\n\n\n若要保证系统高可用，则架构设计的核心准则是：冗余。\n> 有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。\n\n\n\n\n\nOracle Failsafe、DG（Data Guard）、RAC和OGG均为Oracle公司提供的高可靠性（HA）解决方案，但是这几种方案之间却存在着很大区别，下面分别讲解：\nFailsafe和RAC的区别1、操作系统\nFailsafe系统局限于Windows平台，必须配合MSCS（microsoft cluster server）使用，而RAC最早是在UNIX平台推出的，目前已扩展至Linux和Windows平台，通过OSD（operating system dependent）与系统交互。对于高端的RAC应用，UNIX依然是首选的平台。\n\n2、系统结构\nFailsafe采用的是Share Nothing结构，即采用若干台服务器组成集群，共同连接到一个共享磁盘系统，在同一时刻，只有一台服务器能够访问共享磁盘，能够对外提供服务。\n\n只要当此服务器失效时，才有另一台接管共享磁盘。\n\nRAC则是采用Share Everything结构，组成集群的每一台服务器都可以访问共享磁盘，都能对外提供服务。\n\n也就是说Failsafe只能利用一台服务器资源，RAC可以并行利用多台服务器资源。\n3、运行机理\n组成Failsafe集群的每台SERVER有独立的IP，整个集群又有一个IP，另外还为Failsafe Group分配一个单独的IP（后两个IP为虚拟IP，对于客户来说，只需知道集群IP，就可以透明访问数据库）。\n\n工作期间，只有一台服务器（preferred或owner或manager）对外提供服务，其余服务器（operator）成待命状，当前者失效时，另一服务器就会接管前者，包括Failsafe Group IP与Cluster IP，同时Failsafe会启动上面的Database Service，LISTENER和其它服务。客户只要重新连接即可，不需要做任何改动。\n\n对于RAC组成的集群，每台服务器都分别有自已的IP，INSTANCE等，可以单独对外提供服务，只不过它们都是操作位于共享磁盘上的同一个数据库。当某台服务器失效后，用户只要修改网络配置（例如，TNSNAMES.ORA），即可重新连接到仍在正常运行的服务器上，再和TAF结合使用时，甚至网络也可配置成透明的。\n\n4、集群容量\nFailsafe通常为两台，RAC在一些平台上能扩展至更多台服务器。\n\n5、分区Failsafe数据库所在的磁盘必须是NTFS格式的，RAC则相对灵活，裸设备、ASM等都可以。\n\n综上所述，Failsafe比较适合一个可靠性要求很高，应用相对较小，对高性能要求相对不高的系统，而RAC则更适合可靠性、扩展性、性能要求都相对较高的较大型的应用。\n\nRAC和OPS区别\nRAC是OPS（Oracle Parallel Server）的后继版本，继承了OPS的概念，但是RAC是全新的，Cache机制和OPS完全不同。RAC解决了OPS中两个节点同时写同一个BLOCK引起的冲突问题。从产品上来说RAC和OPS是完全不同的产品，但是也可以认为是相同产品的不同版本。\n\nRAC、DG和OGG的区别\nRAC和DG是高可用体系中的常用的两种工具，每个工具既可以独立应用，也可以相互配合使用。但是它们各自的侧重点不同，适用场景也不同。\n\nRAC是本地的高可用集群\n每个节点用来分担不同或相同的应用，以解决运算效率低下、单点故障这样的问题，它是几台硬件相同或不相同的服务器加一个共享存储来构成的。RAC的强项在于解决单点故障和负载均衡，所以，RAC方案常用于7*24的核心系统，但RAC方案中的数据只有一份，尽管可以通过RAID等机制避免存储故障，但是数据本身是没有冗余的，因此需要加强备份。\n\nDG是Oracle的远程复制技术\n它有物理和逻辑之分，但是总的来说，它需要在异地有一套独立的系统，是一种异地容灾的解决方案。DG通过冗余数据的方式来提供数据保护，通过日志同步机制保证冗余数据和主库之间的同步，这种同步可以是实时、延时、同步或异步等多种形式。DG常用于异地容灾和小企业的高可用性方案，可以在备库上执行只读地查询操作，从而分散主库的性能压力。\n\nOGG软件是一种基于日志的结构化数据复制备份软件\n它通过解析源数据库在线日志或归档日志获得数据的增量变化，再将这些变化应用到目标数据库，从而实现源数据库与目标数据库的同步。OGG可以实现一对一、广播（一对多）、聚合（多对一）、双向复制、层叠、点对点、级联等多种灵活的拓扑结构，可以实现只复制某几个表的功能。\n\n\nOracle高可用性产品比较见下表：\n\n","categories":["技术"],"tags":["技术","linux","心得"]},{"title":"RHEL6上Oracle11gR2 grid安装后无法启动的解决","url":"/2021/06/08/RHEL6%E4%B8%8AOracle11gR2-grid%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3/","content":"RHEL6上Oracle11gR2 grid安装后无法启动的解决前言\n在安装部署Oracle11GR2 11.2.0.1版本的RAC集群时，RAC集群无法自启动，是一个BUG，认真查找mos资料，总结出以下解决方案，大家的支持，是我持续创作的动力\n\n1.现象[root@rac1 root]# more /etc/oracle/scls_scr/rac1/root/ohasdstr\n\n\n\n原因：重启系统后，ohasd服务依然没有启动，更不用说启动CRS了。这是因为从RHEL6开始，&#x2F;etc&#x2F;inittab文件内容变了，只有默认的启动等级。而Oracle 11.2.0.1仍是按照以前的习惯把启动命令写在&#x2F;etc&#x2F;inittab文件中，造成ohasd服务不能自动启动。\n\n2.解决的办法2.1 注释掉&#x2F;etc&#x2F;inittab文件的以下内容#h1:35:respawn:/etc/init.d/init.ohasd run &gt;/dev/null 2&gt;&amp;1 &lt;/dev/null\nvi /etc/init/init-oracle.conf\n\n##添加如下内容（此文件刚开始不存在）#start oracle\nstart on runlevel [0123456]stop on runlevel [016]respawnexec /etc/init.d/init.ohasd run &gt;/dev/null 2&gt;&amp;1\n\n保存退出，重启系统即可\n3.集群启停find / -name crsctlcd /u01/app/11.2.0/grid/bin\n\n\n停止集群服务一节点\n\n[root@rac1 bin]# ./crsctl stop crs\n\n二节点\n[root@rac2 bin]# ./crsctl stop crs\n\n\n\n启动集群服务一节点\n\n[root@rac1 bin]# ./crsctl stop crs\n\n二节点\n[root@rac2 bin]# ./crsctl stop crs\n\n注：一般启动不用，服务器会自动拉起集群\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"React新手进阶学习(一)","url":"/2023/07/13/React%E6%96%B0%E6%89%8B%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","content":"React新手进阶学习(一)\n官方的学习文档地址 (用于构建 Web 和原生交互界面的库) : https://react.docschina.org/\n\n安装\n推荐 Next.js React 框架\n\n​\tNext.js 是一个全栈式的 React 框架。\n​\t它用途广泛，可以让你创建任意规模的 React 应用——可以是静态博客，也可以是复杂的动态应用。\n​\t要创建一个新的 Next.js 项目，请在你的终端运行（需要先安装npm install -g npx）:\nnpx create-next-app\n\n\n\nReadme (前言)计数器​\t命令式编程(给他一个命令就执行一个命令)： js, jquery\n​\t声明式编程： React, Vue\n两者的区别是什么？命令式编程和声明式编程是两种不同的编程范式。\n\n命令式编程需要明确指定程序的每一个步骤和控制流程，关注具体的实现细节和算法。\n声明式编程只需描述要实现的目标，不需要详细指定步骤和顺序，关注问题的描述和抽象。\n在命令式编程中，处理更低级的细节，控制数据的状态和变化；在声明式编程中，关注问题的描述和抽象。\n声明式编程更可读、可维护，代码更接近自然语言；命令式编程可能需要更多注释和解释。\n声明式编程更具可复用性，可以定义通用规则和函数；命令式编程更依赖具体的状态和操作。\n声明式编程更容易进行并行处理和优化，编译器或运行时系统可以更好地进行优化；命令式编程中的优化和并行化可能较具挑战性。\n不同的编程语言和框架可以结合两种编程范式的特点，并根据需求和个人偏好进行选择。\n\n第一个组件\n组件 是 React 的核心概念之一。它们是构建用户界面（UI）的基础，是你开始 React 之旅的最佳起点！\n\n摘要​\t你第一次体验 React！让我们先记住一些关键点,带着这些来进行深入学习。\n在本章节中，你将学到：\n\n什么是组件?\n\nReact 允许你创建组件，应用程序为可复用 UI 元素。\n\n\n组件在 React 应用中扮演的角色\n\n在 React 应用程序中，每一个 UI 模块都是一个组件。\n\n\n如何编写你的第一个 React 组件\n\nReact 是常规的 JavaScript 函数，除了：\n它们的名字总是以大写字母开头。\n它们返回 JSX 标签。\n\n\n\n\n\n\n什么是组件？\nReact 组件是一段可以 使用标签进行扩展 的 JavaScript 函数。\n\n​\t示例:\nApp.js\n## 创建一个App.js,拷贝下方的代码export default function Profile() &#123;  return (    &lt;img        src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;       alt=&quot;Katherine Johnson&quot;    &gt;  )&#125;\n\n解析说明注意事项(非常重要)\nReact 组件是常规的 JavaScript 函数，但 组件的名称必须以大写字母开头，否则它们将无法运行！\n\n导出组件​\texport default 前缀是一种 JavaScript 标准语法（非 React 的特性）。它允许你标签一个文件中的主要函数以便你以后可以从其他文件引入它。\n定义函数​\t使用 function Profile() &#123; &#125; 定义名为 Profile 的 JavaScript 函数。\n添加标签​\t这个组件返回一个带有 src 和 alt 属性的 &lt;img /&gt; 标签。&lt;img /&gt; 写得像 HTML，但实际上是 JavaScript！这种语法被称为 JSX，它允许你在 JavaScript 中嵌入使用标签。\n返回语句可以全写在一行上，如下面组件中所示：\nreturn &lt;img   src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;  alt=&quot;Katherine Johnson&quot; &gt;;\n\n​\t但是，如果你的标签和 return 关键字不在同一行，则必须把它包裹在一对括号中，没有括号包裹的话，任何在 return 下一行的代码都 将被忽略\n如下所示：\n# 包裹必须用 &lt;&gt; &lt;/&gt;或者 &lt;div&gt; &lt;/div&gt;return (  &lt;div&gt;    &lt;img   src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;  alt=&quot;Katherine Johnson&quot; &gt;  &lt;/div&gt;);\n\n\n\n\n\n使用组件​\t现在你已经定义了 Profile 组件，你可以在其他组件中使用它。\n​\t例如，你可以导出一个内部使用了多个 Profile 组件的 Gallery 组件：\nApp.js\nfunction Profile() &#123;  return (    &lt;img        src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;       alt=&quot;Katherine Johnson&quot;    &gt;  );&#125;export default function Gallery() &#123;  return (    &lt;section&gt;      &lt;h1&gt;了不起的科学家&lt;/h1&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;    &lt;/section&gt;  );&#125;\n\n\n解析上方的代码注意下面两者的区别：\n\n&lt;section&gt; 是小写的，所以 React 知道我们指的是 HTML 标签。\n&lt;Profile /&gt; 以大写 P 开头，所以 React 知道我们想要使用名为 Profile 的组件。\n\n然而 Profile 包含更多的 HTML：&lt;img /&gt;。这是浏览器最后所看到的：\n&lt;section&gt;  &lt;h1&gt;了不起的科学家&lt;/h1&gt;  &lt;img   src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;  alt=&quot;Katherine Johnson&quot; &gt;  &lt;img   src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;  alt=&quot;Katherine Johnson&quot; &gt;  &lt;img   src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;  alt=&quot;Katherine Johnson&quot; &gt;&lt;/section&gt;\n\n\n\n嵌套和组织组件\n组件是常规的 JavaScript 函数，所以你可以将多个组件保存在同一份文件中。当组件相对较小或彼此紧密相关时，这是一种省事的处理方式。如果这个文件变得臃肿，你也可以随时将 Profile 移动到单独的文件中。\n\n​\t因为 Profile 组件在 Gallery 组件中渲染——甚至好几次！——我们可以认为 Gallery 是一个 父组件，将每个 Profile 渲染为一个“孩子”。\n​\t这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。\n注意事项​\t组件可以渲染其他组件，但是 请不要嵌套他们的定义,例如:\nexport default function Gallery() &#123;  // 🔴 永远不要在组件中定义组件  function Profile() &#123;    // ...  &#125;  // ...&#125;\n\n​\t上面这段代码 非常慢，并且会导致 bug 产生。因此，你应该在顶层定义每个组件, 当子组件需要使用父组件的数据时，你需要 通过 props 的形式进行传递，而不是嵌套定义。：\nexport default function Gallery() &#123;  // ...&#125;// ✅ 在顶层声明组件function Profile() &#123;  // ...&#125;\n\n\n\n\n\n组件的导入与导出组件的神奇之处在于它们的可重用性：\n\n你可以创建一个由其他组件构成的组件。\n但当你嵌套了越来越多的组件时，则需要将它们拆分成不同的文件。\n这样可以使得查找文件更加容易，并且能在更多地方复用这些组件。\n\n摘要在本章节中，你将学到：\n\n何为根组件\n如何导入和导出一个组件\n默认导出 和 具名导出 区别是什么\n何时和如何使用默认和具名导入导出\n如何在一个文件里导出多个组件\n\n\n根组件文件​\t在 你的第一个组件 中，你创建了一个 Profile 组件，并且渲染在 Gallery 组件里。\n​\t在下方的示例中,所有组件目前都定义在根组件 App.js 文件中，在 Create React App 中，你的应用应在 src/App.js 文件中定义。具体还需根据项目配置决定，有些根组件可能会声明在其他文件中。如果你使用的框架基于文件进行路由，如 Next.js，那你每个页面的根组件都会不一样。\nfunction Profile() &#123;  return (    &lt;img        src=&quot;https://i.imgur.com/MK3eW3As.jpg&quot;       alt=&quot;Katherine Johnson&quot;    &gt;  );&#125;export default function Gallery() &#123;  return (    &lt;section&gt;      &lt;h1&gt;了不起的科学家们&lt;/h1&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;    &lt;/section&gt;  );&#125;\n\n\n导出和导入一个组件​\t如果将来需要在首页添加关于科学书籍的列表，亦或者需要将所有的资料信息移动到其他文件。这时将 Gallery 组件和 Profile 组件移出根组件文件会更加合理。这会使组件更加模块化，并且可在其他文件中复用。你可以根据以下三个步骤对组件进行拆分：\n\n创建 一个新的 JS 文件来存放该组件。\n导出 该文件中的函数组件（可以使用 默认导出 或 具名导出）\n在需要使用该组件的文件中 导入（可以根据相应的导出方式使用 默认导入 或 具体名称导入）。\n\n​\t这里将 Profile 组件和 Gallery 组件，从 App.js 文件中移动到了 Gallery.js 文件中 :\n## 创建 Gallery.js , 复制以下代码function Profile() &#123;  return (    &lt;img        src=&quot;https://i.imgur.com/QIrZWGIs.jpg&quot;       alt=&quot;Alan L. Hart&quot;    &gt;  );&#125;export default function Gallery() &#123;  return (    &lt;section&gt;      &lt;h1&gt;了不起的科学家们&lt;/h1&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;    &lt;/section&gt;  );&#125;\n\n​\t修改后，即可在 App.js 中导入 Gallery.js 中的 Gallery 组件:\nimport Gallery from &#x27;./Gallery.js&#x27;;export default function App() &#123;  return (    &lt;Gallery /&gt;  );&#125;\n\n\n注意事项​\t该示例中需要注意的是，如何将组件拆分成两个文件：\n\nGallery.js:\n\n定义了 Profile 组件，该组件仅在该文件内使用，没有被导出。\n使用 默认导出 的方式，将 Gallery 组件导出\n\n\nApp.js:\n\n使用 默认导入 的方式，从 Gallery.js 中导入 Gallery 组件。\n使用 默认导出 的方式，将根组件 App 导出。\n\n\n\n引入过程中，你可能会遇到一些文件并未添加 .js 文件后缀，如下所示：\nimport Gallery from &#x27;./Gallery&#x27;;\n\n无论是 &#39;./Gallery.js&#39; 还是 &#39;./Gallery&#39;，在 React 里都能正常使用，只是前者更符合 原生 ES 模块。\n默认导出 vs 具名导出​\t这是 JavaScript 里两个主要用来导出值的方式：默认导出和具名导出。到目前为止，我们的示例中只用到了默认导出。但你可以在一个文件中，选择使用其中一种，或者两种都使用。一个文件里有且仅有一个 *默认* 导出，但是可以有任意多个 *具名* 导出。\n​\t组件的导出方式决定了其导入方式。当你用默认导入的方式，导入具名导出的组件时，就会报错。如下表格可以帮你更好地理解它们：\n\n\n\n语法\n导出语句\n导入语句\n\n\n\n默认\nexport default function Button() &#123;&#125;\nimport Button from &#39;./Button.js&#39;;\n\n\n具名\nexport function Button() &#123;&#125;\nimport &#123; Button &#125; from &#39;./Button.js&#39;;\n\n\n​\t当使用默认导入时，你可以在 import 语句后面进行任意命名。比如 import Banana from &#39;./Button.js&#39;，如此你能获得与默认导出一致的内容。相反，对于具名导入，导入和导出的名字必须一致。这也是为什么称其为 具名 导入的原因！\n​\t通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。 无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。我们不建议创建未命名的组件，比如 export default () =&gt; &#123;&#125;，因为这样会使得调试变得异常困难。\n从同一文件中导出和导入多个组件​\t如果你只想展示一个 Profile 组，而不展示整个图集。你也可以导出 Profile 组件。但 Gallery.js 中已包含 默认 导出，此时，你不能定义 两个 默认导出。但你可以将其在新文件中进行默认导出，或者将 Profile 进行 具名 导出。同一文件中，有且仅有一个默认导出，但可以有多个具名导出！\n\n注意:\n​\t为了减少在默认导出和具名导出之间的混淆，一些团队会选择只使用一种风格（默认或者具名），或者禁止在单个文件内混合使用。这因人而异，选择最适合你的即可！\n\n首先，用具名导出的方式，将 Profile 组件从 Gallery.js 导出（不使用 default 关键字）：\nexport function Profile() &#123;  // ...&#125;\n\n接着，用具名导入的方式，从 Gallery.js 文件中 导入 Profile 组件（用大括号）:\nimport &#123; Profile &#125; from &#x27;./Gallery.js&#x27;;\n\n最后，在 App 组件里 渲染 &lt;Profile /&gt;：\nexport default function App() &#123;  return &lt;Profile /&gt;;&#125;\n\n现在，Gallery.js 包含两个导出：一个是默认导出的 Gallery，另一个是具名导出的 Profile。App.js 中均导入了这两个组件。尝试将 &lt;Profile /&gt; 改成 &lt;Gallery /&gt;，回到示例中：\nAPP.js\nimport Gallery from &#x27;./Gallery.js&#x27;;import &#123; Profile &#125; from &#x27;./Gallery.js&#x27;;export default function App() &#123;  return (    &lt;Profile /&gt;  );&#125;\n\nGallery.js\nexport function Profile() &#123;  return (    &lt;img        src=&quot;https://i.imgur.com/QIrZWGIs.jpg&quot;       alt=&quot;Alan L. Hart&quot;    &gt;  );&#125;export default function Gallery() &#123;  return (    &lt;section&gt;      &lt;h1&gt;了不起的科学家们&lt;/h1&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;      &lt;Profile /&gt;    &lt;/section&gt;  );&#125;\n\n\n\n示例中混合使用了默认导出和具名导出：\n\nGallery.js:\n\n使用 具名导出 的方式，将 Profile 组件导出，并取名为 Profile。\n使用 默认导出 的方式，将 Gallery 组件导出。\n\n\nApp.js:\n\n使用 具名导入 的方式，从 Gallery.js 中导入 Profile 组件，并取名为 Profile。\n使用 默认导入 的方式，从 Gallery.js 中导入 Gallery 组件。\n使用 默认导出 的方式，将根组件 App 导出。\n\n\n\n使用 JSX 书写标签语言​\tJSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。虽然还有其它方式可以编写组件，但大部分 React 开发者更喜欢 JSX 的简洁性，并且在大部分代码库中使用它。\n摘要 你将会学习到:\n\n为什么 React 将标签和渲染逻辑耦合在一起?\n\n由于渲染逻辑和标签是紧密相关的，所以 React 将它们存放在一个组件中。\n\n\nJSX 与 HTML 有什么区别?\n\nJSX 类似 HTML，不过有一些区别。如果需要的话可以使用 转化器 将 HTML 转化为 JSX。\n\n\n如何通过 JSX 展示信息\n\n错误提示通常会指引你将标签修改为正确的格式。\n\n\n\n\nJSX: 将标签引入 JavaScript​\t网页是构建在 HTML、CSS 和 JavaScript 之上的。多年以来，web 开发者都是将网页内容存放在 HTML 中，样式放在 CSS 中，而逻辑则放在 JavaScript 中 —— 通常是在不同的文件中！页面的内容通过标签语言描述并存放在 HTML 文件中，而逻辑则单独存放在 JavaScript 文件中。\n​\t但随着 Web 的交互性越来越强，逻辑越来越决定页面中的内容。JavaScript 负责 HTML 的内容！这也是为什么 在 React 中，渲染逻辑和标签共同存在于同一个地方——组件。\n​\t将一个按钮的渲染逻辑和标签放在一起可以确保它们在每次编辑时都能保持互相同步。反之，彼此无关的细节是互相隔离的，例如按钮的标签和侧边栏的标签。这样我们在修改其中任意一个组件时会更安全。\n​\t每个 React 组件都是一个 JavaScript 函数，它会返回一些标签，React 会将这些标签渲染到浏览器上。React 组件使用一种被称为 JSX 的语法扩展来描述这些标签。JSX 看起来和 HTML 很像，但它的语法更加严格并且可以动态展示信息。了解这些区别最好的方式就是将一些 HTML 标签转化为 JSX 标签。\n\n注意:\n​\tJSX and React 是相互独立的 东西。但它们经常一起使用，但你 可以 单独使用它们中的任意一个，JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库。\n\n将 HTML 转化为 JSX​\t假设你现在有一些（完全有效的）HTML 标签：\n&lt;h1&gt;海蒂·拉玛的代办事项&lt;/h1&gt;&lt;img     src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;    alt=&quot;Hedy Lamarr&quot;   class=&quot;photo&quot;&gt;&lt;ul&gt;    &lt;li&gt;发明一种新式交通信号灯    &lt;li&gt;排练一个电影场景    &lt;li&gt;改进频谱技术&lt;/ul&gt;\n\n​\t而现在想要把这些标签迁移到组件中：\nexport default function TodoList() &#123;  return (    // ???  )&#125;\n\n​\t如果直接复制到组件中，并不能正常工作：\n​\tApp.js\nexport default function TodoList() &#123;  return (    // 这不起作用！    &lt;h1&gt;海蒂·拉玛的代办事项&lt;/h1&gt;    &lt;img         src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;        alt=&quot;Hedy Lamarr&quot;       class=&quot;photo&quot;    &gt;    &lt;ul&gt;      &lt;li&gt;发明一种新式交通信号灯      &lt;li&gt;排练一个电影场景      &lt;li&gt;改进频谱技术    &lt;/ul&gt;  );&#125;\n\n​\t这是因为 JSX 语法更加严格并且相比 HTML 有更多的规则！\n\n注意大部分情况下，React 在屏幕上显示的错误提示就能帮你找到问题所在，如果在编写过程中遇到问题就参考一下提示吧。\n\nJSX 规则​\t只能返回一个根元素 \n​\t如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来。\n​\t例如，你可以使用一个 div 标签 ：\n&lt;div&gt;  &lt;h1&gt;海蒂·拉玛的代办事项&lt;/h1&gt;    &lt;img       src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;      alt=&quot;Hedy Lamarr&quot;     class=&quot;photo&quot;  &gt;  &lt;ul&gt;    ...  &lt;/ul&gt;&lt;/div&gt;\n\n​\t如果你不想在标签中增加一个额外的 div 标签，可以用 &lt;&gt; 和 &lt;&#x2F;&gt; 元素来代替：\n&lt;&gt;  &lt;h1&gt;海蒂·拉玛的代办事项&lt;/h1&gt;    &lt;img       src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;      alt=&quot;Hedy Lamarr&quot;     class=&quot;photo&quot;  &gt;    &lt;ul&gt;    ...  &lt;/ul&gt;&lt;/&gt;\n\n​\t这个空标签被称作 Fragment. React Fragment 允许你将子元素分组，而不会在 HTML 结构中添加额外节点。\n为什么多个 JSX 标签需要被一个父元素包裹？​\tJSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。\n标签必须闭合​\tJSX 要求标签必须正确闭合。像 &lt;img&gt; 这样的自闭合标签必须书写成 &lt;img /&gt;，而像 &lt;li&gt;oranges 这样只有开始标签的元素必须带有闭合标签，需要改为 &lt;li&gt;oranges&lt;/li&gt;。\n海蒂·拉玛的照片和代办事项的标签经修改后变为：\n&lt;&gt;  &lt;img       src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;      alt=&quot;Hedy Lamarr&quot;     class=&quot;photo&quot;   &gt;     &lt;ul&gt;      &lt;li&gt;发明一种新式交通信号灯&lt;/li&gt;      &lt;li&gt;排练一个电影场景&lt;/li&gt;      &lt;li&gt;改进频谱技术&lt;/li&gt;  &lt;/ul&gt;  &lt;/&gt;\n\n\n\n使用驼峰式命名法给 所有 大部分属性命名！​\tJSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。\n​\t这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 strokeWidth 代替 stroke-width。由于 class 是一个保留字，所以在 React 中需要用 className 来代替。这也是 DOM 属性中的命名:\n&lt;img     src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;    alt=&quot;Hedy Lamarr&quot;   className=&quot;photo&quot;&gt;\n\n​\t你可以 在 React DOM 元素中找到所有对应的属性。如果你在编写属性时发生了错误，不用担心 —— React 会在 浏览器控制台 中打印一条可能的更正信息。\n\n注意\n​\t由于历史原因，aria-* 和 data-* 属性是以带 - 符号的 HTML 格式书写的。\n\n高级提示：使用 JSX 转化器​\t将现有的 HMTL 中的所有属性转化 JSX 的格式是很繁琐的。我们建议使用 转化器 将 HTML 和 SVG 标签转化为 JSX。这种转化器在实践中非常有用。但我们依然有必要去了解这种转化过程中发生了什么，这样你就可以编写自己的 JSX 了。\n这是最终的结果：\nexport default function TodoList() &#123;  return (    &lt;&gt;          &lt;h1&gt;海蒂·拉玛的代办事项&lt;/h1&gt;            &lt;img           src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;          alt=&quot;Hedy Lamarr&quot;         className=&quot;photo&quot;       &gt;            &lt;ul&gt;        &lt;li&gt;发明一种新式交通信号灯&lt;/li&gt;        &lt;li&gt;排练一个电影场景&lt;/li&gt;        &lt;li&gt;改进频谱技术&lt;/li&gt;      &lt;/ul&gt;          &lt;/&gt;   );&#125;\n\n\n在 JSX 中通过大括号使用 JavaScript​\tJSX 允许你在 JavaScript 中编写类似 HTML 的标签，从而使渲染的逻辑和内容可以写在一起。有时候，你可能想要在标签中添加一些 JavaScript 逻辑或者引用动态的属性。这种情况下，你可以在 JSX 的大括号内来编写 JavaScript。\n摘要 你将会学习并了解:\n\n如何使用引号传递字符串\n\nJSX 引号内的值会作为字符串传递给属性。\n\n\n在 JSX 的大括号内引用 JavaScript 变量\n\n大括号让你可以将 JavaScript 的逻辑和变量带入到标签中。\n\n\n在 JSX 的大括号内调用 JavaScript 函数\n\n它们会在 JSX 标签中的内容区域或紧随属性的 = 后起作用。\n\n\n在 JSX 的大括号内使用 JavaScript 对象\n\n&#123;&#123;` 和 `&#125;&#125; 并不是什么特殊的语法：它只是包在 JSX 大括号内的 JavaScript 对象。\n\n\n\n\n使用引号传递字符串 当你想把一个字符串属性传递给 JSX 时，把它放到单引号或双引号中：\nApp.js\nexport default function Avatar() &#123;  return (    &lt;img       className=&quot;avatar&quot;       src=&quot;https://i.imgur.com/7vQD0fPs.jpg&quot;       alt=&quot;Gregorio Y. Zara&quot;    &gt;  );&#125;\n\n​\t这里的 &quot;https://i.imgur.com/7vQD0fPs.jpg&quot; 和 &quot;Gregorio Y. Zara&quot; 就是被作为字符串传递的。\n​\t但是如果你想要动态地指定 src 或 alt 的值呢？你可以 用 &#123; 和 &#125; 替代 &quot; 和 &quot; 以使用 JavaScript 变量 ：\nApp.js\nexport default function Avatar() &#123;  const avatar = &#x27;https://i.imgur.com/7vQD0fPs.jpg&#x27;;  const description = &#x27;Gregorio Y. Zara&#x27;;  return (    &lt;img      className=&quot;avatar&quot;      src=&#123;avatar&#125;      alt=&#123;description&#125;    /&gt;  );&#125;\n\n​\t请注意 className=&quot;avatar&quot; 和 src=&#123;avatar&#125; 之间的区别，className=&quot;avatar&quot; 指定了一个就叫 &quot;avatar&quot; 的使图片在样式上变圆的 CSS 类名，而 src=&#123;avatar&#125; 这种写法会去读取 JavaScript 中 avatar 这个变量的值。这是因为大括号可以使你直接在标签中使用 JavaScript！\n使用大括号：一扇进入 JavaScript 世界的窗户​\tJSX 是一种编写 JavaScript 的特殊方式。这为在大括号 &#123; &#125; 中使用 JavaScript 带来了可能。下面的示例中声明了科学家的名字，name，然后在 &lt;h1&gt; 后的大括号内嵌入它：\nApp.js\nexport default function TodoList() &#123;  const name = &#x27;Gregorio Y. Zara&#x27;;  return (    &lt;h1&gt;&#123;name&#125;&#x27;s To Do List&lt;/h1&gt;  );&#125;\n\n​\t试着将 name 的值从 &#39;Gregorio Y. Zara&#39; 更改成 &#39;Hedy Lamarr&#39;。看看这个 To Do List 的标题将如何变化？\n大括号内的任何 JavaScript 表达式都能正常运行，包括像 formatDate() 这样的函数调用：\nApp.js\nconst today = new Date();function formatDate(date) &#123;  return new Intl.DateTimeFormat(    &#x27;zh-CN&#x27;,    &#123; weekday: &#x27;long&#x27; &#125;  ).format(date);&#125;export default function TodoList() &#123;  return (    &lt;h1&gt;To Do List for &#123;formatDate(today)&#125;&lt;/h1&gt;  );&#125;\n\n\n\n可以在哪使用大括号​\t\n\n在 JSX 中，只能在以下两种场景中使用大括号：\n\n用作 JSX 标签内的文本：&lt;h1&gt;&#123;name&#125;&#39;s To Do List&lt;/h1&gt; 是有效的，但是 &lt;&#123;tag&#125;&gt;Gregorio Y. Zara&#39;s To Do List&lt;/&#123;tag&#125;&gt; 无效。\n用作紧跟在 = 符号后的 属性：src=&#123;avatar&#125; 会读取 avatar 变量，但是 src=&quot;&#123;avatar&#125;&quot; 只会传一个字符串 &#123;avatar&#125;。\n\n\n使用 “双大括号”：JSX 中的 CSS 和 对象​\t除了字符串、数字和其它 JavaScript 表达式，你甚至可以在 JSX 中传递对象。对象也用大括号表示，例如 &#123; name: &quot;Hedy Lamarr&quot;, inventions: 5 &#125;。因此，为了能在 JSX 中传递，你必须用另一对额外的大括号包裹对象：person=&#123;&#123; name: \"Hedy Lamarr\", inventions: 5 &#125;&#125;。\n​\t你可能在 JSX 的内联 CSS 样式中就已经见过这种写法了。React 不要求你使用内联样式（使用 CSS 类就能满足大部分情况）。但是当你需要内联样式的时候，你可以给 style 属性传递一个对象：\n​\t\nApp.js\nexport default function TodoList() &#123;  return (    &lt;ul style=&#123;&#123;      backgroundColor: &#x27;black&#x27;,      color: &#x27;pink&#x27;    &#125;&#125;&gt;      &lt;li&gt;Improve the videophone&lt;/li&gt;      &lt;li&gt;Prepare aeronautics lectures&lt;/li&gt;      &lt;li&gt;Work on the alcohol-fuelled engine&lt;/li&gt;    &lt;/ul&gt;  );&#125;\n\n\n​\t试着更改一下 backgroundColor 和 color 的值。\n​\t当你写成这样时，你可以很清楚地看到大括号里包着的对象：\n&lt;ul style=&#123;  &#123;    backgroundColor: &#x27;black&#x27;,    color: &#x27;pink&#x27;  &#125;&#125;&gt;\n\n\n\n​\t所以当你下次在 JSX 中看到 &#123;&#123;` 和 `&#125;&#125;时，就知道它只不过是包在大括号里的一个对象罢了！\n\n注意​\t内联 style 属性 使用驼峰命名法编写。例如，HTML &lt;ul style=&quot;background-color: black&quot;&gt; 在你的组件里应该写成 &lt;ul style=&#123;&#123; backgroundColor: 'black' &#125;&#125;&gt;。\n\nJavaScript 对象和大括号的更多可能​\t你可以将多个表达式合并到一个对象中，在 JSX 的大括号内分别使用它们：\nApp.js\nconst person = &#123;  name: &#x27;Gregorio Y. Zara&#x27;,  theme: &#123;    backgroundColor: &#x27;black&#x27;,    color: &#x27;pink&#x27;  &#125;&#125;;export default function TodoList() &#123;  return (    &lt;div style=&#123;person.theme&#125;&gt;      &lt;h1&gt;&#123;person.name&#125;&#x27;s Todos&lt;/h1&gt;      &lt;img         className=&quot;avatar&quot;         src=&quot;https://i.imgur.com/7vQD0fPs.jpg&quot;         alt=&quot;Gregorio Y. Zara&quot;      &gt;      &lt;ul&gt;        &lt;li&gt;Improve the videophone&lt;/li&gt;        &lt;li&gt;Prepare aeronautics lectures&lt;/li&gt;        &lt;li&gt;Work on the alcohol-fuelled engine&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  );&#125;\n\n\n​\t在这个示例中，person JavaScript 对象包含 name 中存储的字符串和 theme 对象：\nconst person = &#123;  name: &#x27;Gregorio Y. Zara&#x27;,  theme: &#123;    backgroundColor: &#x27;black&#x27;,    color: &#x27;pink&#x27;  &#125;&#125;;\n\n​\t该组件可以这样使用来自 person 的值：\n&lt;div style=&#123;person.theme&#125;&gt;  &lt;h1&gt;&#123;person.name&#125;&#x27;s Todos&lt;/h1&gt;\n\n​\tJSX 是一种模板语言的最小实现，因为它允许你通过 JavaScript 来组织数据和逻辑。\n将 Props 传递给组件​\tReact 组件使用 props 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它。Props 可能会让你想起 HTML 属性，但你可以通过它们传递任何 JavaScript 值，包括对象、数组和函数。\n摘要 你将会学习并了解:\n\n如何向组件传递 props\n\n要传递 props，请将它们添加到 JSX，就像使用 HTML 属性一样。\n\n\n如何从组件读取 props\n\n要读取 props，请使用 function Avatar(&#123; person, size &#125;) 解构语法。\n\n\n如何为 props 指定默认值\n\n你可以指定一个默认值，如 size = 100，用于缺少值或值为 undefined 的 props 。\n\n\n如何给组件传递 JSX\n\n你可以使用 &lt;Avatar &#123;...props&#125; /&gt; JSX 展开语法转发所有 props，但不要过度使用它！\n像 &lt;Card&gt;&lt;Avatar /&gt;&lt;/Card&gt; 这样的嵌套 JSX，将被视为 Card 组件的 children prop。\n\n\nProps 如何随时间变化\n\nProps 是只读的时间快照：每次渲染都会收到新版本的 props。\n你不能改变 props。当你需要交互性时，你可以设置 state。\n\n\n\n\n熟悉的 props​\tProps 是你传递给 JSX 标签的信息。例如，className、src、alt、width 和 height 便是一些可以传递给 &lt;img&gt; 的 props：\nApp.js\nfunction Avatar() &#123;  return (    &lt;img       className=&quot;avatar&quot;       src=&quot;https://i.imgur.com/1bX5QH6.jpg&quot;       alt=&quot;Lin Lanying&quot;      width=&#123;100&#125;      height=&#123;100&#125;    &gt;  );&#125;export default function Profile() &#123;  return (    &lt;Avatar /&gt;  );&#125;\n\n​\t你可以传递给 img 标签的 props 是预定义的（ReactDOM 符合 HTML 标准）。但是你可以将任何 props 传递给 你自己的 组件，例如 Avatar 标签 ，以便自定义它们。 就像这样！\n向组件传递 props​\t在这段代码中， Profile 组件没有向它的子组件 Avatar 传递任何 props ：\nexport default function Profile() &#123;  return (    &lt;Avatar /&gt;  );&#125;\n\n​\t你可以分两步给 Avatar 一些 props。\n步骤 1: 将 props 传递给子组件​\t首先，将一些 props 传递给 Avatar。例如，让我们传递两个 props：person（一个对象）和 size（一个数字）：\nexport default function Profile() &#123;  return (    &lt;Avatar      person=&#123;&#123; name: &#x27;Lin Lanying&#x27;, imageId: &#x27;1bX5QH6&#x27; &#125;&#125;      size=&#123;100&#125;    /&gt;  );&#125;\n\n\n注意​\t如果 person&#x3D; 后面的双花括号让你感到困惑，请记住，在 JSX 花括号中，它们只是一个对象。\n\n​\t现在，你可以在 Avatar 组件中读取这些 props 了。\n步骤 2: 在子组件中读取 props​\t你可以通过在 function Avatar 之后直接列出它们的名字 person, size 来读取这些 props。这些 props 在 (&#123; 和 &#125;) 之间，并由逗号分隔。这样，你可以在 Avatar 的代码中使用它们，就像使用变量一样。\nfunction Avatar(&#123; person, size &#125;) &#123;  // 在这里 person 和 size 是可访问的&#125;\n\n​\t向使用 person 和 size props 渲染的 Avatar 添加一些逻辑，你就完成了。\n​\t现在你可以配置 Avatar ，通过不同的 props，使它能以多种不同的方式进行渲染。尝试变换值吧！\nutils.js\nexport function getImageUrl(person, size = &#x27;s&#x27;) &#123;  return (    &#x27;https://i.imgur.com/&#x27; +    person.imageId +    size +    &#x27;.jpg&#x27;  );&#125;\n\nApp.js\nimport &#123; getImageUrl &#125; from &#x27;./utils.js&#x27;;function Avatar(&#123; person, size &#125;) &#123;  return (    &lt;img      className=&quot;avatar&quot;      src=&#123;getImageUrl(person)&#125;      alt=&#123;person.name&#125;      width=&#123;size&#125;      height=&#123;size&#125;    /&gt;  );&#125;export default function Profile() &#123;  return (    &lt;div&gt;      &lt;Avatar        size=&#123;100&#125;        person=&#123;&#123;           name: &#x27;Katsuko Saruhashi&#x27;,           imageId: &#x27;YfeOqp2&#x27;        &#125;&#125;      /&gt;      &lt;Avatar        size=&#123;80&#125;        person=&#123;&#123;          name: &#x27;Aklilu Lemma&#x27;,           imageId: &#x27;OKS67lh&#x27;        &#125;&#125;      /&gt;      &lt;Avatar        size=&#123;50&#125;        person=&#123;&#123;           name: &#x27;Lin Lanying&#x27;,          imageId: &#x27;1bX5QH6&#x27;        &#125;&#125;      /&gt;    &lt;/div&gt;  );&#125;\n\n\n​\tProps 使你独立思考父组件和子组件。 例如，你可以改变 Profile 中的 person 或 size props，而无需考虑 Avatar 如何使用它们。 同样，你可以改变 Avatar 使用这些 props 的方式，不必考虑 Profile。\n​\t你可以将 props 想象成可以调整的“旋钮”。它们的作用与函数的参数相同 —— 事实上，props 正是 组件的唯一参数！ React 组件函数接受一个参数，一个 props 对象：\nfunction Avatar(props) &#123;  let person = props.person;  let size = props.size;  // ...&#125;\n\n​\t通常你不需要整个 props 对象，所以可以将它解构为单独的 props。\n\n注意​\t在声明 props 时， 不要忘记 ( 和 ) 之间的一对花括号 &#123; 和 &#125;  ：\nfunction Avatar(&#123; person, size &#125;) &#123;  // ...&#125;\n\n​\t这种语法被称为 “解构”，等价于于从函数参数中读取属性：\nfunction Avatar(props) &#123;  let person = props.person;  let size = props.size;  // ...&#125;\n\n给 prop 指定一个默认值​\t如果你想在没有指定值的情况下给 prop 一个默认值，你可以通过在参数后面写 = 和默认值来进行解构：\nfunction Avatar(&#123; person, size = 100 &#125;) &#123;  // ...&#125;\n\n​\t现在， 如果 &lt;Avatar person=&#123;...&#125; /&gt; 渲染时没有 size prop，  size 将被赋值为 100。\n​\t默认值仅在缺少 size prop 或 size=&#123;undefined&#125; 时生效。 但是如果你传递了 size=&#123;null&#125; 或 size=&#123;0&#125;，默认值将 不 被使用。\n使用 JSX 展开语法传递 props​\t有时候，传递 props 会变得非常重复：\nfunction Profile(&#123; person, size, isSepia, thickBorder &#125;) &#123;  return (    &lt;div className=&quot;card&quot;&gt;      &lt;Avatar        person=&#123;person&#125;        size=&#123;size&#125;        isSepia=&#123;isSepia&#125;        thickBorder=&#123;thickBorder&#125;      /&gt;    &lt;/div&gt;  );&#125;\n\n​\t重复代码没有错（它可以更清晰）。但有时你可能会重视简洁。一些组件将它们所有的 props 转发给子组件，正如 Profile 转给 Avatar 那样。因为这些组件不直接使用他们本身的任何 props，所以使用更简洁的“展开”语法是有意义的：\nfunction Profile(props) &#123;  return (    &lt;div className=&quot;card&quot;&gt;      &lt;Avatar &#123;...props&#125; /&gt;    &lt;/div&gt;  );&#125;\n\n​\t这会将 Profile 的所有 props 转发到 Avatar，而不列出每个名字。\n​\t请克制地使用展开语法。 如果你在所有其他组件中都使用它，那就有问题了。 通常，它表示你应该拆分组件，并将子组件作为 JSX 传递。 接下来会详细介绍！\n将 JSX 作为子组件传递​\t嵌套浏览器内置标签是很常见的：\n&lt;div&gt;  &lt;img /&gt;&lt;/div&gt;\n\n​\t有时你会希望以相同的方式嵌套自己的组件：\n&lt;Card&gt;  &lt;Avatar /&gt;&lt;/Card&gt;\n\n​\t当您将内容嵌套在 JSX 标签中时，父组件将在名为 children 的 prop 中接收到该内容。例如，下面的 Card 组件将接收一个被设为 &lt;Avatar /&gt; 的 children prop 并将其包裹在 div 中渲染：\nutils.js\nexport function getImageUrl(person, size = &#x27;s&#x27;) &#123;  return (    &#x27;https://i.imgur.com/&#x27; +    person.imageId +    size +    &#x27;.jpg&#x27;  );&#125;\n\nAvatar.js\nimport &#123; getImageUrl &#125; from &#x27;./utils.js&#x27;;export default function Avatar(&#123; person, size &#125;) &#123;  return (    &lt;img      className=&quot;avatar&quot;      src=&#123;getImageUrl(person)&#125;      alt=&#123;person.name&#125;      width=&#123;size&#125;      height=&#123;size&#125;    /&gt;  );&#125;\n\nApp.js\nimport Avatar from &#x27;./Avatar.js&#x27;;function Card(&#123; children &#125;) &#123;  return (    &lt;div className=&quot;card&quot;&gt;      &#123;children&#125;    &lt;/div&gt;  );&#125;export default function Profile() &#123;  return (    &lt;Card&gt;      &lt;Avatar        size=&#123;100&#125;        person=&#123;&#123;           name: &#x27;Katsuko Saruhashi&#x27;,          imageId: &#x27;YfeOqp2&#x27;        &#125;&#125;      /&gt;    &lt;/Card&gt;  );&#125;\n\n\n​\t尝试用一些文本替换 &lt;Card&gt; 中的 &lt;Avatar&gt;，看看 Card 组件如何包裹任意嵌套内容。它不必“知道”其中渲染的内容。你会在很多地方看到这种灵活的模式。\n​\t可以将带有 children prop 的组件看作有一个“洞”，可以由其父组件使用任意 JSX 来“填充”。你会经常使用 children prop 来进行视觉包装：面板、网格等等。\nProps 如何随时间变化​\t下面的 Clock 组件从其父组件接收两个 props：color 和 time。（父组件的代码被省略，因为它使用 state，我们暂时不会深入研究。）\n尝试在下面的选择框中更改颜色：\nClock.js\nexport default function Clock(&#123; color, time &#125;) &#123;  return (    &lt;h1 style=&#123;&#123; color: color &#125;&#125;&gt;      &#123;time&#125;    &lt;/h1&gt;  );&#125;\n\n​\t这个例子说明，一个组件可能会随着时间的推移收到不同的 props。 Props 并不总是静态的！在这里，time prop 每秒都在变化。当你选择另一种颜色时，color prop 也改变了。Props 反映了组件在任何时间点的数据，并不仅仅是在开始时。\n​\t然而，props 是 不可变的（一个计算机科学术语，意思是“不可改变”）。当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 不同的 props —— 一个新对象！它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。\n​\t不要尝试“更改 props”。 当你需要响应用户输入（例如更改所选颜色）时，你可以“设置 state”，你可以在 State: 一个组件的内存 中继续了解。\n条件渲染​\t通常你的组件会需要根据不同的情况显示不同的内容。在 React 中，你可以通过使用 JavaScript 的 if 语句、&amp;&amp; 和 ? : 运算符来选择性地渲染 JSX。\n摘要 你将会学习并了解:\n\n如何根据不同条件返回不同的 JSX\n\n在 React，你可以使用 JavaScript 来控制分支逻辑。\n你可以使用 if 语句来选择性地返回 JSX 表达式。\n你可以选择性地将一些 JSX 赋值给变量，然后用大括号将其嵌入到其他 JSX 中。\n\n\n如何根据不同条件包含或者去掉部分 JSX\n\n在 JSX 中，&#123;cond ? &lt;A /&gt; : &lt;B /&gt;&#125; 表示 “当 cond 为真值时, 渲染 &lt;A /&gt;，否则 &lt;B /&gt;”。\n在 JSX 中，&#123;cond &amp;&amp; &lt;A /&gt;&#125; 表示 “当 cond 为真值时, 渲染 &lt;A /&gt;，否则不进行渲染”。\n\n\n一些你会在 React 代码库里遇到的常用的条件语法快捷表达式\n\n快捷的表达式很常见，但如果你更倾向于使用 if，你也可以不使用它们。\n\n\n\n\n条件返回 JSX假设有一个 PackingList 组件，里面渲染多个 Item 组件，每个物品可标记为打包与否：\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t需要注意的是，有些 Item 组件的 isPacked 属性是被设为 true 而不是 false。你可以在那些满足 isPacked&#x3D;{true} 条件的物品旁加上一个勾选符号（✔）。\n​\t你可以用 if&#x2F;else 语句 去判断：\nif (isPacked) &#123;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;;&#125;return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;\n\n​\t如果 isPacked 属性是 true，这段代码会返回一个不一样的 JSX。通过这样的改动，一些物品的名字后面会出现一个勾选符号：\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  if (isPacked) &#123;    return &lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;;  &#125;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t动手尝试一下，看看各种情况会出现什么不同的结果！\n​\t留意这里你是怎么使用 JavaScript 的 if 和 return 语句来写分支逻辑。在 React 中，是由 JavaScript 来处理控制流的（比如条件）。\n选择性地返回 null​\t在一些情况下，你不想有任何东西进行渲染。比如，你不想显示已经打包好的物品。但一个组件必须返回一些东西。这种情况下，你可以直接返回 null。\nif (isPacked) &#123;  return null;&#125;return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;\n\n​\t如果组件的 isPacked 属性为 true，那么它将只返回 null。否则，它将返回相应的 JSX 用来渲染。\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  if (isPacked) &#123;    return null;  &#125;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t实际上，在组件里返回 null 并不常见，因为这样会让想使用它的开发者感觉奇怪。通常情况下，你可以在父组件里选择是否要渲染该组件。让我们接着往下看吧！\n选择性地包含 JSX​\t在之前的例子里，你在组件内部控制哪些 JSX 树（如果有的话！）会返回。你可能已经发现了在渲染输出里会有一些重复的内容：\n&lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;\n\n​\t和下面的写法很像：\n&lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;\n\n​\t两个条件分支都会返回 &lt;li className=&quot;item&quot;&gt;...&lt;/li&gt;：\nif (isPacked) &#123;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;;&#125;return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;\n\n​\t虽然这些重复的内容没什么害处，但这样可能会导致你的代码更难维护。比如你想更改 className？你就需要修改两个地方！针对这种情况，你可以通过选择性地包含一小段 JSX 来让你的代码更加 DRY。\n三目运算符（? :）​\tJavaScript 有一种紧凑型语法来实现条件判断表达式——条件运算符 又称“三目运算符”。\n除了这样：\nif (isPacked) &#123;  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;;&#125;return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;\n\n你还可以这样实现：\nreturn (  &lt;li className=&quot;item&quot;&gt;    &#123;isPacked ? name + &#x27; ✔&#x27; : name&#125;  &lt;/li&gt;);\n\n​\t你可以认为，“如果 isPacked 为 true 时，则（?）渲染 name + ‘ ✔’，否则（:）渲染 name。”\n两个例子完全一样吗？​\t\n​\t如果你之前是习惯面向对象开发的，你可能会认为上面的两个例子略有不同，因为其中一个可能会创建两个不同的  “实例”。但 JSX 元素不是“实例”，因为它们没有内部状态也不是真实的 DOM 节点。它们只是一些简单的描述，就像图纸一样。所以上面这两个例子事实上是完全相同的。在 状态的保持和重置 里会深入探讨其原因。\n​\t现在，假如你想将对应物品的文本放到另一个 HTML 标签里，比如用 &lt;del&gt; 来显示删除线。你可以添加更多的换行和括号，以便在各种情况下更好地去嵌套 JSX：\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  return (    &lt;li className=&quot;item&quot;&gt;      &#123;isPacked ? (        &lt;del&gt;          &#123;name + &#x27; ✔&#x27;&#125;        &lt;/del&gt;      ) : (        name      )&#125;    &lt;/li&gt;  );&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t对于简单的条件判断，这样的风格可以很好地实现，但需要适量使用。如果你的组件里有很多的嵌套式条件表达式，则需要考虑通过提取为子组件来简化这些嵌套表达式。在 React 里，标签也是你代码中的一部分，所以你可以使用变量和函数来整理一些复杂的表达式。\n与运算符（&amp;&amp;）​\t你会遇到的另一个常见的快捷表达式是 JavaScript 逻辑与（&amp;&amp;）运算符。在 React 组件里，通常用在当条件成立时，你想渲染一些 JSX，或者不做任何渲染。使用 &amp;&amp;，你也可以实现仅当 isPacked 为 true 时，渲染勾选符号。\nreturn (  &lt;li className=&quot;item&quot;&gt;    &#123;name&#125; &#123;isPacked &amp;&amp; &#x27;✔&#x27;&#125;  &lt;/li&gt;);\n\n​\t你可以认为，“当 isPacked 为真值时，则（&amp;&amp;）渲染勾选符号，否则，不渲染。”\n下面为具体的例子：\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  return (    &lt;li className=&quot;item&quot;&gt;      &#123;name&#125; &#123;isPacked &amp;&amp; &#x27;✔&#x27;&#125;    &lt;/li&gt;  );&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t当 JavaScript &amp;&amp; 表达式 的左侧（我们的条件）为 true 时，它则返回其右侧的值（在我们的例子里是勾选符号）。但条件的结果是 false，则整个表达式会变成 false。在 JSX 里，React 会将 false 视为一个“空值”，就像 null 或者 undefined，这样 React 就不会在这里进行任何渲染。\n陷阱切勿将数字放在 &amp;&amp; 左侧.\n​\tJavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染。\n​\t例如，一个常见的错误是 messageCount &amp;&amp; New messages。其原本是想当 messageCount 为 0 的时候不进行渲染，但实际上却渲染了 0。\n​\t为了更正，可以将左侧的值改成布尔类型：messageCount &gt; 0 &amp;&amp; New messages。\n选择性地将 JSX 赋值给变量​\t当这些快捷方式妨碍写普通代码时，可以考虑使用 if 语句和变量。因为你可以使用 let 进行重复赋值，所以一开始你可以将你想展示的（这里指的是物品的名字）作为默认值赋予给该变量。\nlet itemContent = name;\n\n​\t结合 if 语句，当 isPacked 为 true 时，将 JSX 表达式的值重新赋值给 itemContent：\nif (isPacked) &#123;  itemContent = name + &quot; ✔&quot;;&#125;\n\n​\t在 JSX 中通过大括号使用 JavaScript。将变量用大括号嵌入在返回的 JSX 树中，来嵌套计算好的表达式与 JSX：\n&lt;li className=&quot;item&quot;&gt;  &#123;itemContent&#125;&lt;/li&gt;\n\n​\t这种方式是最冗长的，但也是最灵活的。下面是相关的例子：\nApp.js\nfunction Item(&#123; name, isPacked &#125;) &#123;  let itemContent = name;  if (isPacked) &#123;    itemContent = name + &quot; ✔&quot;;  &#125;  return (    &lt;li className=&quot;item&quot;&gt;      &#123;itemContent&#125;    &lt;/li&gt;  );&#125;export default function PackingList() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Sally Ride 的行李清单&lt;/h1&gt;      &lt;ul&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;宇航服&quot;         /&gt;        &lt;Item           isPacked=&#123;true&#125;           name=&quot;带金箔的头盔&quot;         /&gt;        &lt;Item           isPacked=&#123;false&#125;           name=&quot;Tam 的照片&quot;         /&gt;      &lt;/ul&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t跟之前的一样，这个方式不仅仅适用于文本，任意的 JSX 均适用：\n​\t如果对 JavaScript 不熟悉，这些不同的风格一开始可能会让你感到不知所措。但是，学习这些将有助于你理解和写任何的 JavaScript 代码，而不仅仅是 React 组件。一开始可以选择一个你喜欢的来用，然后当你忘记其他的怎么用时，可以再翻阅这份参考资料。\n渲染列表​\t你可能经常需要通过 JavaScript 的数组方法 来操作数组中的数据，从而将一个数据集渲染成多个相似的组件。在这篇文章中，你将学会如何在 React 中使用 filter() 筛选需要渲染的组件和使用 map() 把数组转换成组件数组。\n摘要 你将会学习并了解:\n\n如何从组件中抽离出数据，并把它们放入像数组、对象这样的数据结构中。\n\n如何通过 JavaScript 的 map() 方法从数组中生成组件\n\n如何通过 JavaScript 的 filter() 筛选需要渲染的组件\n\n为何以及如何给集合中的每个组件设置一个 key 值：它使 React 能追踪这些组件，即便后者的位置或数据发生了变化。\n\n\n\n从数组中渲染数据​\t这里我们有一个列表。\n&lt;ul&gt;  &lt;li&gt;凯瑟琳·约翰逊: 数学家&lt;/li&gt;  &lt;li&gt;马里奥·莫利纳: 化学家&lt;/li&gt;  &lt;li&gt;穆罕默德·阿卜杜勒·萨拉姆: 物理学家&lt;/li&gt;  &lt;li&gt;珀西·莱温·朱利亚: 化学家&lt;/li&gt;  &lt;li&gt;苏布拉马尼扬·钱德拉塞卡: 天体物理学家&lt;/li&gt;&lt;/ul&gt;\n\n​\t可以看到，这些列表项之间唯一的区别就是其中的内容&#x2F;数据。未来你可能会碰到很多类似的情况，在那些场景中，你想基于不同的数据渲染出相似的组件，比如评论列表或者个人资料的图库。在这样的场景下，可以把要用到的数据存入 JavaScript 对象或数组，然后用 map() 或 filter() 这样的方法来渲染出一个组件列表。\n​\t这里给出一个由数组生成一系列列表项的简单示例：\n\n首先，把数据 存储 到数组中：\n\nconst people = [  &#x27;凯瑟琳·约翰逊: 数学家&#x27;,  &#x27;马里奥·莫利纳: 化学家&#x27;,  &#x27;穆罕默德·阿卜杜勒·萨拉姆: 物理学家&#x27;,  &#x27;珀西·莱温·朱利亚: 化学家&#x27;,  &#x27;苏布拉马尼扬·钱德拉塞卡: 天体物理学家&#x27;,];\n\n\n遍历 people 这个数组中的每一项，并获得一个新的 JSX 节点数组 listItems：\n\nconst listItems = people.map(person =&gt; &lt;li&gt;&#123;person&#125;&lt;/li&gt;);\n\n\n把 listItems 用 &lt;ul&gt; 包裹起来，然后 返回 它：\n\nreturn &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;\n\n来看看运行的结果：\nApp.js\nconst people = [  &#x27;凯瑟琳·约翰逊: 数学家&#x27;,  &#x27;马里奥·莫利纳: 化学家&#x27;,  &#x27;穆罕默德·阿卜杜勒·萨拉姆: 物理学家&#x27;,  &#x27;珀西·莱温·朱利亚: 化学家&#x27;,  &#x27;苏布拉马尼扬·钱德拉塞卡: 天体物理学家&#x27;,];export default function List() &#123;  const listItems = people.map(person =&gt;    &lt;li&gt;&#123;person&#125;&lt;/li&gt;  );  return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;&#125;\n\n\n注意​\t上面的沙盒可能会输出这样一个控制台错误：\n\n​\t等会我们会学到怎么修复它。在此之前，我们先来看看如何把这个数组变得更加结构化。\n对数组项进行过滤​\t让我们把 people 数组变得更加结构化一点。\nconst people = [  &#123;    id: 0,    name: &#x27;凯瑟琳·约翰逊&#x27;,    profession: &#x27;数学家&#x27;,  &#125;,  &#123;    id: 1,    name: &#x27;马里奥·莫利纳&#x27;,    profession: &#x27;化学家&#x27;,  &#125;,  &#123;    id: 2,    name: &#x27;穆罕默德·阿卜杜勒·萨拉姆&#x27;,    profession: &#x27;物理学家&#x27;,  &#125;,  &#123;  \tid: 3,    name: &#x27;珀西·莱温·朱利亚&#x27;,    profession: &#x27;化学家&#x27;,  &#125;,  &#123;  \tid: 4,    name: &#x27;苏布拉马尼扬·钱德拉塞卡&#x27;,    profession: &#x27;天体物理学家&#x27;,  &#125;,];\n\n​\t现在，假设你只想在屏幕上显示职业是 化学家 的人。那么你可以使用 JavaScript 的 filter() 方法来返回满足条件的项。这个方法会让数组的子项经过 “过滤器”（一个返回值为 true 或 false 的函数）的筛选，最终返回一个只包含满足条件的项的新数组。\n​\t既然你只想显示 profession 值是 化学家 的人，那么这里的 “过滤器” 函数应该长这样：(person) &#x3D;&gt; person.profession &#x3D;&#x3D;&#x3D; ‘化学家’。下面我们来看看该怎么把它们组合在一起：\n\n首先，创建 一个用来存化学家们的新数组 chemists，这里用到 filter() 方法过滤 people 数组来得到所有的化学家，过滤的条件应该是 person.profession === &#39;化学家&#39;：\n\nconst chemists = people.filter(person =&gt;  person.profession === &#x27;化学家&#x27;);\n\n\n接下来 用 map 方法遍历 chemists 数组:\n\nconst listItems = chemists.map(person =&gt;  &lt;li&gt;     &lt;img       src=&#123;getImageUrl(person)&#125;       alt=&#123;person.name&#125; /&gt;          &lt;p&gt;            &lt;b&gt;&#123;person.name&#125;:&lt;/b&gt;       &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;       因&#123;person.accomplishment&#125;而闻名世界            &lt;/p&gt;       &lt;/li&gt;);\n\n\n最后，返回 listItems：\n\nreturn &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;\n\n让我们来看看完整的代码：\nutils.js\nexport function getImageUrl(person) &#123;  return (    &#x27;https://i.imgur.com/&#x27; +    person.imageId +    &#x27;s.jpg&#x27;  );&#125;\n\ndata.js\nexport const people = [  &#123;    id: 0,    name: &#x27;凯瑟琳·约翰逊&#x27;,    profession: &#x27;数学家&#x27;,    accomplishment: &#x27;太空飞行相关数值的核算&#x27;,    imageId: &#x27;MK3eW3A&#x27;,  &#125;,  &#123;    id: 1,    name: &#x27;马里奥·莫利纳&#x27;,    profession: &#x27;化学家&#x27;,    accomplishment: &#x27;北极臭氧空洞的发现&#x27;,    imageId: &#x27;mynHUSa&#x27;,  &#125;,  &#123;    id: 2,    name: &#x27;穆罕默德·阿卜杜勒·萨拉姆&#x27;,    profession: &#x27;物理学家&#x27;,    accomplishment: &#x27;关于基本粒子间弱相互作用和电磁相互作用的统一理论&#x27;,    imageId: &#x27;bE7W1ji&#x27;,  &#125;,  &#123;    id: 3,    name: &#x27;珀西·莱温·朱利亚&#x27;,    profession: &#x27;化学家&#x27;,    accomplishment: &#x27;开创性的可的松药物、类固醇和避孕药的研究&#x27;,    imageId: &#x27;IOjWm71&#x27;,  &#125;,  &#123;    id: 4,    name: &#x27;苏布拉马尼扬·钱德拉塞卡&#x27;,    profession: &#x27;天体物理学家&#x27;,    accomplishment: &#x27;白矮星质量计算&#x27;,    imageId: &#x27;lrWQx8l&#x27;,  &#125;,];\n\nApp.js\nimport &#123; people &#125; from &#x27;./data.js&#x27;;import &#123; getImageUrl &#125; from &#x27;./utils.js&#x27;;export default function List() &#123;  const chemists = people.filter(person =&gt;    person.profession === &#x27;化学家&#x27;  );  const listItems = chemists.map(person =&gt;    &lt;li&gt;      &lt;img        src=&#123;getImageUrl(person)&#125;        alt=&#123;person.name&#125;      /&gt;      &lt;p&gt;        &lt;b&gt;&#123;person.name&#125;:&lt;/b&gt;        &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;        因&#123;person.accomplishment&#125;而闻名世界      &lt;/p&gt;    &lt;/li&gt;  );  return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;&#125;\n\n\n陷阱​\t因为箭头函数会隐式地返回位于 &#x3D;&gt; 之后的表达式，所以你可以省略 return 语句。\nconst listItems = chemists.map(person =&gt;  &lt;li&gt;...&lt;/li&gt; // 隐式地返回！);\n\n​\t不过，如果你的 &#x3D;&gt; 后面跟了一对花括号 { ，那你必须使用 return 来指定返回值！\nconst listItems = chemists.map(person =&gt; &#123; // 花括号  return &lt;li&gt;...&lt;/li&gt;;&#125;);\n\n​\t箭头函数 &#x3D;&gt; { 后面的部分被称为 “块函数体”，块函数体支持多行代码的写法，但要用 return 语句才能指定返回值。假如你忘了写 return，那这个函数什么都不会返回！\n用 key 保持列表项的顺序​\t如果把上面任何一个沙盒示例在新标签页打开，你就会发现控制台有这样一个报错：\n\n​\t这是因为你必须给数组中的每一项都指定一个 key——它可以是字符串或数字的形式，只要能唯一标识出各个数组项就行：\n&lt;li key=&#123;person.id&#125;&gt;...&lt;/li&gt;\n\n注意​\t直接放在 map() 方法里的 JSX 元素一般都需要指定 key 值！\n​\t这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 key 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。\n​\t用作 key 的值应该在数据中提前就准备好，而不是在运行时才随手生成：\nutils.js\nexport function getImageUrl(person) &#123;  return (    &#x27;https://i.imgur.com/&#x27; +    person.imageId +    &#x27;s.jpg&#x27;  );&#125;\n\ndata.js\nexport const people = [  &#123;    id: 0, // 在 JSX 中作为 key 使用    name: &#x27;凯瑟琳·约翰逊&#x27;,    profession: &#x27;数学家&#x27;,    accomplishment: &#x27;太空飞行相关数值的核算&#x27;,    imageId: &#x27;MK3eW3A&#x27;,  &#125;,  &#123;    id: 1, // 在 JSX 中作为 key 使用    name: &#x27;马里奥·莫利纳&#x27;,    profession: &#x27;化学家&#x27;,    accomplishment: &#x27;北极臭氧空洞的发现&#x27;,    imageId: &#x27;mynHUSa&#x27;,  &#125;,  &#123;    id: 2, // 在 JSX 中作为 key 使用    name: &#x27;穆罕默德·阿卜杜勒·萨拉姆&#x27;,    profession: &#x27;物理学家&#x27;,    accomplishment: &#x27;关于基本粒子间弱相互作用和电磁相互作用的统一理论&#x27;,    imageId: &#x27;bE7W1ji&#x27;,  &#125;,  &#123;    id: 3, // 在 JSX 中作为 key 使用    name: &#x27;珀西·莱温·朱利亚&#x27;,    profession: &#x27;化学家&#x27;,    accomplishment: &#x27;开创性的可的松药物、类固醇和避孕药&#x27;,    imageId: &#x27;IOjWm71&#x27;,  &#125;,  &#123;    id: 4, // 在 JSX 中作为 key 使用    name: &#x27;苏布拉马尼扬·钱德拉塞卡&#x27;,    profession: &#x27;天体物理学家&#x27;,    accomplishment: &#x27;白矮星质量计算&#x27;,    imageId: &#x27;lrWQx8l&#x27;,  &#125;,];\n\nApp.js\nimport &#123; people &#125; from &#x27;./data.js&#x27;;import &#123; getImageUrl &#125; from &#x27;./utils.js&#x27;;export default function List() &#123;  const listItems = people.map(person =&gt;    &lt;li key=&#123;person.id&#125;&gt;      &lt;img        src=&#123;getImageUrl(person)&#125;        alt=&#123;person.name&#125;      /&gt;      &lt;p&gt;        &lt;b&gt;&#123;person.name&#125;&lt;/b&gt;          &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;          因&#123;person.accomplishment&#125;而闻名世界      &lt;/p&gt;    &lt;/li&gt;  );  return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;&#125;\n\n\n为每个列表项显示多个 DOM 节点​\t如果你想让每个列表项都输出多个 DOM 节点而非一个的话，该怎么做呢？\n​\tFragment 语法的简写形式 &lt;&gt; &lt;&#x2F;&gt; 无法接受 key 值，所以你只能要么把生成的节点用一个 div 标签包裹起来，要么使用长一点但更明确的 Fragment 写法：\nimport &#123; Fragment &#125; from &#x27;react&#x27;;// ...const listItems = people.map(person =&gt;  &lt;Fragment key=&#123;person.id&#125;&gt;    &lt;h1&gt;&#123;person.name&#125;&lt;/h1&gt;    &lt;p&gt;&#123;person.bio&#125;&lt;/p&gt;  &lt;/Fragment&gt;);\n\n​\t这里的 Fragment 标签本身并不会出现在 DOM 上，这串代码最终会转换成 &lt;h1&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;p&gt;…… 的列表。\n如何设定 key 值​\t不同来源的数据往往对应不同的 key 值获取方式：\n\n来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。\n本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。\n\nkey 需要满足的条件\nkey 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。\nkey 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。\n\nReact 中为什么需要 key？​\t设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……\n​\tReact 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。\n陷阱​\t你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 key 值，React 确实默认会这么做。但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。\n​\t与之类似，请不要在运行过程中动态地产生 key，像是 key&#x3D;{Math.random()} 这种方式。这会导致每次重新渲染后的 key 值都不一样，从而使得所有的组件和 DOM 元素每次都要重新创建。这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。所以，使用能从给定数据中稳定取得的值才是明智的选择。\n​\t有一点需要注意，组件不会把 key 当作 props 的一部分。Key 的存在只对 React 本身起到提示作用。如果你的组件需要一个 ID，那么请把它作为一个单独的 prop 传给组件： \n保持组件纯粹​\t部分 JavaScript 函数是 纯粹 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。但为了获得这些好处，你需要遵循一些规则。\n摘要 你将会学习并了解:\n\n纯函数是什么，以及它如何帮助你避免 bug\n\n一个组件必须是纯粹的，就意味着：\n只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量。\n输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX。\n\n\n\n\n如何将数据变更与渲染过程分离，以保持组件的纯粹\n\n渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。\n你不应该改变组件用于渲染的任何输入。这包括 props、state 和 context。通过 “设置” state 来更新界面，而不要改变预先存在的对象。\n\n\n如何使用严格模式发现组件中的错误\n\n\n\n纯函数：组件作为公式在计算机科学中（尤其是函数式编程的世界中），纯函数 通常具有如下特征：\n\n只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。\n输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。\n\n举个你非常熟悉的纯函数示例：数学中的公式。\n​\t考虑如下数学公式：y &#x3D; 2x。\n​\t若 x &#x3D; 2 则 y &#x3D; 4。永远如此。\n​\t若 x &#x3D; 3 则 y &#x3D; 6。永远如此。\n​\t若 x &#x3D; 3，那么 y 并不会因为时间或股市的影响，而有时等于 9 、 –1 或 2.5。\n​\t若 y &#x3D; 2x 且 x &#x3D; 3, 那么 y 永远 等于 6.\n​\t我们使用 JavaScript 的函数实现，看起来将会是这样：\nfunction double(number) &#123;  return 2 * number;&#125;\n\n​\t上述例子中，double() 就是一个 纯函数。如果你传入 3 ，它将总是返回 6 。\n​\tReact 便围绕着这个概念进行设计。React 假设你编写的所有组件都是纯函数。\n​\t也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。\nApp.js\nfunction Recipe(&#123; drinkers &#125;) &#123;  return (    &lt;ol&gt;          &lt;li&gt;Boil &#123;drinkers&#125; cups of water.&lt;/li&gt;      &lt;li&gt;Add &#123;drinkers&#125; spoons of tea and &#123;0.5 * drinkers&#125; spoons of spice.&lt;/li&gt;      &lt;li&gt;Add &#123;0.5 * drinkers&#125; cups of milk to boil and sugar to taste.&lt;/li&gt;    &lt;/ol&gt;  );&#125;export default function App() &#123;  return (    &lt;section&gt;      &lt;h1&gt;Spiced Chai Recipe&lt;/h1&gt;      &lt;h2&gt;For two&lt;/h2&gt;      &lt;Recipe drinkers=&#123;2&#125; /&gt;      &lt;h2&gt;For a gathering&lt;/h2&gt;      &lt;Recipe drinkers=&#123;4&#125; /&gt;    &lt;/section&gt;  );&#125;\n\n\n​\t当你给函数 Recipe 传入 drinkers&#x3D;{2} 参数时，它将返回包含 2 cups of water 的 JSX。永远如此。\n​\t而当你传入 drinkers&#x3D;{4} 时，它将返回包含 4 cups of water 的 JSX。永远如此。\n​\t就像数学公式一样。\n​\t你可以把你的组件当作食谱：如果你遵循它们，并且在烹饪过程中不引入新食材，你每次都会得到相同的菜肴。那这道 “菜肴” 就是组件用于 React 渲染 的 JSX。\n\n副作用：（不符合）预期的后果​\tReact 的渲染过程必须自始至终是纯粹的。组件应该只 返回 它们的 JSX，而不 改变 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！\n​\t以下是违反这一规则的组件示例：\nApp.js\nlet guest = 0;function Cup() &#123;  // Bad: changing a preexisting variable!  guest = guest + 1;  return &lt;h2&gt;Tea cup for guest #&#123;guest&#125;&lt;/h2&gt;;&#125;export default function TeaSet() &#123;  return (    &lt;&gt;      &lt;Cup /&gt;      &lt;Cup /&gt;      &lt;Cup /&gt;    &lt;/&gt;  );&#125;\n\n\n​\t该组件正在读写其外部声明的 guest 变量。这意味着 多次调用这个组件会产生不同的 JSX！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。\n​\t回到我们的公式 y &#x3D; 2x ，现在即使 x &#x3D; 2 ，我们也不能相信 y &#x3D; 4 。我们的测试可能会失败，我们的用户可能会感到困扰，飞机可能会从天空坠毁——你将看到这会引发多么扑朔迷离的 bugs！\n​\t你可以 将 guest 作为 prop 传入 来修复此组件：\nApp.js\nfunction Cup(&#123; guest &#125;) &#123;  return &lt;h2&gt;Tea cup for guest #&#123;guest&#125;&lt;/h2&gt;;&#125;export default function TeaSet() &#123;  return (    &lt;&gt;      &lt;Cup guest=&#123;1&#125; /&gt;      &lt;Cup guest=&#123;2&#125; /&gt;      &lt;Cup guest=&#123;3&#125; /&gt;    &lt;/&gt;  );&#125;\n\n\n​\t现在你的组件就是纯粹的，因为它返回的 JSX 只依赖于 guest prop。\n​\t一般来说，你不应该期望你的组件以任何特定的顺序被渲染。调用 y &#x3D; 5x 和 y &#x3D; 2x 的先后顺序并不重要：这两个公式相互独立。同样地，每个组件也应该“独立思考”，而不是在渲染过程中试图与其他组件协调，或者依赖于其他组件。渲染过程就像是一场学校考试：每个组件都应该自己计算 JSX！\n使用严格模式检测不纯的计算​\t尽管你可能还没使用过，但在 React 中，你可以在渲染时读取三种输入：props，state 和 context。你应该始终将这些输入视为只读。\n​\t当你想根据用户输入 更改 某些内容时，你应该 设置状态，而不是直接写入变量。当你的组件正在渲染时，你永远不应该改变预先存在的变量或对象。\n​\tReact 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。\n​\t我们注意到，原始示例显示的是 “Guest #2”、“Guest #4” 和 “Guest #6”，而不是 “Guest #1”、“Guest #2” 和 “Guest #3”。原来的函数并不纯粹，因此调用它两次就出现了问题。但对于修复后的纯函数版本，即使调用该函数两次也能得到正确结果。纯函数仅仅执行计算，因此调用它们两次不会改变任何东西 — 就像两次调用 double(2) 并不会改变返回值，两次求解 y &#x3D; 2x 不会改变 y 的值一样。相同的输入，总是返回相同的输出。\n​\t严格模式在生产环境下不生效，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 &lt;React.StrictMode&gt; 包裹根组件。一些框架会默认这样做。\n局部 mutation：组件的小秘密​\t上述示例的问题出在渲染过程中，组件改变了 预先存在的 变量的值。为了让它听起来更可怕一点，我们将这种现象称为 突变（mutation） 。纯函数不会改变函数作用域外的变量、或在函数调用前创建的对象——这会使函数变得不纯粹！\n​\t但是，你完全可以在渲染时更改你 *刚刚* 创建的变量和对象。在本示例中，你创建一个 [] 数组，将其分配给一个 cups 变量，然后 push 一打 cup 进去：\nApp.js\nfunction Cup(&#123; guest &#125;) &#123;  return &lt;h2&gt;Tea cup for guest #&#123;guest&#125;&lt;/h2&gt;;&#125;export default function TeaGathering() &#123;  let cups = [];  for (let i = 1; i &lt;= 12; i++) &#123;    cups.push(&lt;Cup key=&#123;i&#125; guest=&#123;i&#125; /&gt;);  &#125;  return cups;&#125;\n\n\n​\t如果 cups 变量或 [] 数组是在 TeaGathering 函数之外创建的，这将是一个很大的问题！因为如果那样的话，当你调用数组的 push 方法时，就会更改 预先存在的 对象。\n​\t但是，这里不会有影响，因为每次渲染时，你都是在 TeaGathering 函数内部创建的它们。TeaGathering 之外的代码并不会知道发生了什么。这就被称为 “局部 mutation” — 如同藏在组件里的小秘密。\n哪些地方 可能 引发副作用​\t函数式编程在很大程度上依赖于纯函数，但 某些事物 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。\n​\t在 React 中，副作用通常属于 事件处理程序。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。\n如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 useEffect 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，这种方法应该是你最后的手段。\n如果可能，请尝试仅通过渲染过程来表达你的逻辑。你会惊讶于这能带给你多少好处！\nReact 为何侧重于纯函数?编写纯函数需要遵循一些习惯和规程。但它开启了绝妙的机遇：\n\n你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。\n你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。\n如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。\n\n我们正在构建的每个 React 新特性都利用到了纯函数。从数据获取到动画再到性能，保持组件的纯粹可以充分释放 React 范式的能力。\t\n","categories":["技术"],"tags":["技术","心得","React"]},{"title":"关于js逆向","url":"/2020/03/18/ReverseJs/","content":"本文适合爬虫新手阅读，欢迎指正和调教。\njs逆向是让爬虫萌新们比较头疼的一块领域，因为市面上大部分的爬虫书籍等教程都未涉及这方面知识，需要爬取用js加密的网站时常常无从下手，只能使用selenium等自动化框架来模拟人工点击。但这种方式往往效率低下，所以本文将以企名片这个网站为例，带大家初探js逆向。\n之所以选择这个网站，首先它难度不大，适合练手；其次即便破解了加密参数，想爬取数据还是得下些功夫，因为未登录情况下只显示一页数据，即便登录还得认证啥的比较麻烦。\n废话不多说，下面进入正题。\n环境准备因为涉及js的调试验证，所以除了Python环境外，你还需要Nodejs（js的运行环境）和WebStorm（IDE）。\nNodejs去官网下载安装包后直接一键安装即可，安装完毕后去控制台运行node --version，如果出现版本号即代表安装成功。\nWebStorm安装完后需要激活，激活教程网上很多，大家自行搜索。它是Jet Brains的产品（和PyCharm是同一家公司），所以使用方式与PyCharm很类似。\n分析过程直接访问这个地址https://www.qimingpian.com/finosda/project/pinvestment，看到的是这个界面：\n我们需要获取图中红框里的数据，也就是创业项目列表。打开开发者工具，刷新一下页面，看看它发起了哪些请求：\n为减少干扰，先只看XHR和Doc的请求，一共有三个：pinvestment、productListVip、industryFieldVip。\n在pinvestment的响应内容里，只能看到一堆js的调用，并没有我们想要的html，说明网页是由js动态生成的。\n而在productListVip和industryFieldVip的响应内容里，都有一个”encrypt_data”的参数，很明显这是一个加密参数，参数内容像是一串Base64字符。既然网站对这个参数做了加密，说明它不想被爬取，所以可以做个假设：我们的目标数据就是encrypt_data参数里的内容。\n有了这个假设，目的就很明确了，只要破解这个加密参数就行。\n爬虫新手们往往走完上面步骤就止步不前。不妨思考一下，参数虽做了加密，但网页毕竟要正常显示内容，所以在网页渲染的过程中，一定有个地方对这个参数做了解密，然后将数据写入html。\n也就是说，我们需要在网页渲染的过程里，一步步观察，看看到底是哪个位置对这个参数做了解密。\n在开发者工具里的Sources选项卡中，可以找到这个网页的js文件夹，界面右侧有断点调试栏。\n在js文件里打上断点，然后一步步调试，就能重现网页渲染的过程。那么断点应该打在哪个位置呢？在断点调试栏里有个XHR&#x2F;fetch Breakpoints，它支持在发送XHR请求的位置打上断点，我们找到的两个含加密参数的请求就是XHR类型的，正好用上这个功能。点击+号输入请求名称即可：\n刷新页面，然后一步一步执行，发现可疑信息就把鼠标移上去看下。\n\n调试的两个小技巧：\n\n压缩的js点击左下角的花括号来美化\n\n\n\n在调试过程中使用Console执行js代码。比如我觉得这个函数很可疑，想执行一下看看。\n\n\n其实上图中执行Object(d.a)(e.encrypt_data)返回的内容就是我们需要的数据了。进到这个函数体里边，就能找到解密函数：\nfunction o(t)就是我们需要的解密函数，可以看到它先调用s函数，传入了四个参数，除了a.a.decode(t)外其他三个都是写死的，最后用JSON.parse转为json对象。\n然而，找到解密函数后，我们要做的不是去分析它函数内部做了什么，虽然可以研究它的解密算法然后用Python重写，但这样太复杂且没必要。因为我们可以用PyExecJS这个库，直接用Python调用并执行js代码。\n这时候，WebStorm就派上用场了。新建一个js文件，把function o里涉及的代码全部抠下来。然后执行console.log把执行结果打印出来。篇幅问题就只贴部分代码：\n//解密函数function my_decrypt(t) &#123;    return JSON.parse(s(&quot;5e5062e82f15fe4ca9d24bc5&quot;, my_decode(t), 0, 0, &quot;012345677890123&quot;, 1))&#125;//解密函数依赖项function my_decode(t) &#123;    c = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;    f = /[\\t\\n\\f\\r ]/g    var e = (t = String(t).replace(f, &quot;&quot;)).length;    e % 4 == 0 &amp;&amp; (e = (t = t.replace(/==?$/, &quot;&quot;)).length),    (e % 4 == 1 || /[^+a-zA-Z0-9/]/.test(t)) &amp;&amp; l(&quot;Invalid character: the string to be decoded is not correctly encoded.&quot;);    for (var n, r, i = 0, o = &quot;&quot;, a = -1; ++a &lt; e; )        r = c.indexOf(t.charAt(a)),            n = i % 4 ? 64 * n + r : r,        i++ % 4 &amp;&amp; (o += String.fromCharCode(255 &amp; n &gt;&gt; (-2 * i &amp; 6)));    return o&#125;//测试代码，加密参数太长就不贴上来了encrypt_data = &quot;xxx&quot;decrypt_data = my_decrypt(encrypt_data)console.log(decrypt_data)\n\n执行结果：\n\n确实是我们需要的数据没错，最后用Python去调用解密函数就行了。调用时还有个需要注意的地方，因为直接返回object给Python会报错，所以这里将JSON.parse移除了，返回parse前的json字符串，\n//解密函数function my_decrypt(t) &#123;    return s(&quot;5e5062e82f15fe4ca9d24bc5&quot;, my_decode(t), 0, 0, &quot;012345677890123&quot;, 1)&#125;\n\n同时为了防止这串字符串内有特殊编码的字符，这里将它转成base64再return：\nfunction my_decrypt(t) &#123;    return new Buffer(s(&quot;5e5062e82f15fe4ca9d24bc5&quot;, my_decode(t), 0, 0, &quot;012345677890123&quot;, 1)).toString(&quot;base64&quot;)&#125;\n\n然后在Python中用base64库的b64decode方法来解码即可。\n总结最后总结一下，说说关于逆向的个人看法。\n之所以市面上很少有爬虫逆向的书籍，除了因为它比较”敏感”之外，也因为它并没有固定的方法论。上文提供的也只是一种思路，其实还是有很多取巧的方式，比如在我们已知参数名为encrypt_data的情况下，在js文件夹下全局搜索，分分钟就能找到解密函数。\n逆向过程挺糟心，也挺有趣的，且逆向成功后会有很大的成就感。\n总而言之，逆向是一个提出假设和实际验证的过程，比如上文中的encrypt_data，我们不能百分百确定它就是我们需要的数据，但可以假设它是，来作为我们的突破口，即便最后发现不是，大不了再做新的假设。这有点像侦探探案，通过已知的信息作为线索来抽丝剥茧，最终破案。\n","categories":["软件教程"],"tags":["软件","js","阅读"]},{"title":"RedHat6.6-单实例安装-Oracle-11g","url":"/2021/03/06/RedHat6.6-%E5%8D%95%E5%AE%9E%E4%BE%8B%E5%AE%89%E8%A3%85-Oracle-11g/","content":"RedHat6.5安装Oracle1.配置linux1.1 设置网络，配置IP地址，配置远程连接（xshell 或 Scrt）编辑网络配置文件 vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0\nIPADDR=192.168.65.129NETMASK=255.255.255.0GATEWAY=192.168.65.2\n配置好后重启网络 \n\n&#x2F;etc&#x2F;init.d&#x2F;network restart\n\n1.2 改系统语言编辑配置文件vi &#x2F;etc&#x2F;sysconfig&#x2F;i18n\n\nLANG&#x3D;”en_US.UTF-8”\n\n1.3 配置本地yum源挂载光盘镜像\n\ncd &#x2F;mnt&#x2F;cdrom&#x2F;mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom&#x2F;\n\n配置yum源\n\nnano &#x2F;etc&#x2F;yum.repos.d&#x2F;rhel-source.repo\n\n[rhel-local]name=localbaseurl=file:///mnt/cdromenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\n\n\nyum repolistyum install vim -y\n\n配置环境变量 vim 有颜色\n\nexport TERM&#x3D;xterm\n\n1.4 关闭防火墙，关闭selinux\nservice iptables stop开机自动关闭防火墙chkconfig iptables off\n\n关闭selinux\n\n编辑文件 &#x2F;etc&#x2F;selinux&#x2F;configSELINUX&#x3D;disabled\n\n2.配置oracle基础环境2.1 新增虚拟磁盘（实体机的硬盘看着划分）\nracle&#x2F;app&#x2F;oracle 分配安装目录大小100g&#x2F;oradata 分配数据文件目录大小100g&#x2F;archive 分配归档日志目录大小100g&#x2F;soft 临时解压安装目录20g，安装好就可以删掉，也可以保留\n\nmkdir /oraclemkdir /oradatamkdir /archivemkdir /soft\n\n开机自动挂载硬盘\n\n&#x2F;etc&#x2F;fstab\n\n/dev/sdb1               /oracle                 ext4    defaults        0 0/dev/sdc1               /oradata                 ext4    defaults        0 0/dev/sdd1               /archive                 ext4    defaults        0 0\n\n3.安装Oracle3.1 创建oinstall和dba组，创建oracle用户groupadd dbagroupadd oinstallgroupadd operuseradd oracle -g oinstall -G dba,oper\n3.2 创建安装目录路径mkdir -p &#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0mkdir -p &#x2F;oracle&#x2F;app&#x2F;oraInventorychown -R oracle.oinstall &#x2F;oracle&#x2F;app&#x2F;oraclechown -R oracle.oinstall &#x2F;oradatachown -R oracle.oinstall &#x2F;archivechown -R oracle.oinstall &#x2F;softchown -R oracle.oinstall &#x2F;oracle\nchmod -R 755 &#x2F;oraclechmod -R 755 &#x2F;oradatachmod -R 755 &#x2F;archivechmod -R 755 &#x2F;soft\npasswd oracle\n4.修改内核参数vi &#x2F;etc&#x2F;sysctl.conf 在文件新增如下内容\nkernel.sem=250 32000 100 128net.ipv4.ip_local_port_range=9000 65500net.core.rmem_default=4194304net.core.rmem_max=4194304net.core.wmem_default=262144net.core.wmem_max=1048576fs.aio-max-nr=1048576fs.file-max=6815744kernel.shmmni=4096sysctl -p\n\n5.oracle对文件的要求vi &#x2F;etc&#x2F;security&#x2F;limits.conf\noracle           soft    nproc           16384oracle           hard    nproc           16384oracle           soft    nofile          65536oracle           hard    nofile          65536\n\n第1行是设置进程数软限制；第2行是设置进程数硬限制；第3行是设置文件数软限制；第4行是设置文件数硬限制。\n\n6.修改安全配置vi &#x2F;etc&#x2F;pam.d&#x2F;login\nsession    required      pam_limits.so#session   required      /lib64/security/pam_limits.so\n\n\n3# 7.修改oracle用户的环境变量\n\nsu - oraclevi .bash_profile\n\nexport TMP=/tmpexport TMPDIR=$TMPexport ORACLE_BASE=/oracle/app/oracleexport ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1export ORACLE_SID=ora11gexport ORACLE_UNQNAME=$ORACLE_SIDexport ORACLE_TERM=xtermexport PATH=$ORACLE_HOME/bin:$PATHexport NLS_LANG=AMERICAN_AMERICA.ZHS16GBK\n\n8.修改hosts，便于解析IP地址 主机名192.168.65.129 ora11g\n查看主机名称echo $HOSTNAME\n修改后可以ping主机名\n9.安装数据库软件 上传oracle软件rpm -ivh –nodeps –force pdksh-5.2.14-37.el5_8.1.x86_64.rpmyum install tigervnc-server tigervnc -y\nyum install -y gcc-3.4.6yum install -y gccyum install libaio-develyum install -y compat-libsdc++yum install -y compat-libsdc++-develyum install -y compat-develyum install libsdc-devel -y\nyum list all | grep libsdcyum list all | grep compat\nyum install -y  compat-libstdc*yum install -y libstdc++-develyum install gcc-c++ -yyum install elfutils* -y\n10 配置远程vncroot用户下vncserver输入账号密码然后看配置中的端口是多少比如192.168.65.129:1\n11 开始安装oralce cd /soft/database ./runInstaller\n 运行后会跳出安装界面窗口，先跳过邮箱验证\n\n\n选择第二个，仅安装数据库软件\n\n 选中添加中文字体\n就选择第一个企业版\n\n检查安装条件没问题后，直接点安装如果提示swap size检查失败，那么增加swap分区大小即可\n1.使用root用户，在/tmp（随意），下执行下面语句dd if=/dev/zero of=swapfree bs=32k count=65515(增加swap大小为bs*count，bs为block，count为数量)2.将创建的文件用做交换分区执行语句：           mkswap swapfree3、开启这个交换空间执行语句：swapon swapfree4、通过free命令查看，交换空间在原来交换空间的基础上增加了2G5、在/etc/fstab中加入下面语句，设置此交换分区开机启动/tmp/swapfree swap swap defaults 0 0\n\n\n跳出提示，用root用户执行命令\n安装完成后，netca先创建监听然后dbca创建数据库 \n选择第二个自定义数据库输入实例名比如：ora11g第一个选择后，可通过网页来管理数据库输入oracle的dba密码统一使用选择第二个输入选择数据文件的存储路径，前面建的&#x2F;oradata路径specify归档可以开，先默认不开后面需要再开先选择上面的typical默认分配到80%，然后再选择custom字符集选择下中文GBK16\n这个是控制文件按照这个图片来调整datafile数据文件的大小和自动增长安装完成后，就可以正常使用数据库了\n登录查看数据库状态\n\nsqlplus &#x2F; as sysdba\n\nselect open_mode from v$database;\n可以看到open_mode的状态是打开的\n","categories":["软件教程"],"tags":["技术","oracle","心得"]},{"title":"Mysql报错-1130","url":"/2021/07/06/mysql%E6%8A%A5%E9%94%99-1130/","content":"mysql出现错误码1130的解决办法\n错误描述：\n错误代码：1130Host ... is not allowed to connect to this MySQL server\n\n\n1、改表法：\n可能是你的帐号不允许从远程登陆，只能在localhost。\n\n这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项\n\n从“localhost”改称”%”mysql -u root -p\n\nmysql -uroot -p 密码;mysql&gt;use mysql;mysql&gt;update user set host = ‘%&#x27; where user =’root’;mysql&gt;flush privileges;mysql&gt;select host,user from user where user=’root’;\n现在就可以连接了！\n2、授权法：例如，你想root使用root从任何主机连接到mysql服务器的话。\nGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;\n如果你想允许用户root从ip为192.168.1.3的主机连接到mysql服务器，并使用root作为密码\nGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;192.168.217.133&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;\n","categories":["技术"],"tags":["技术","linux","心得","mysql"]},{"title":"Midjourney_ai绘画全面解析","url":"/2023/05/20/midiourney%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":" Midjourney绘画全面解析\n\n初识 MidjourneyMidjourney 是一个人工智能生成图像产品。其创始人 David Holz 认为，Midjourney 是人类想象力的延伸。如果对其发展历程感兴趣可以参考下面的文章：Midjourney：只需要十一人在生成式AI、云计算等技术逐渐抹平大企业与中小企业之间的技术、成本差距后，各企业真正比拼的，只剩下人才、创意与执行力微信公众平台\nMidjourney 官方对于其产品的介绍如下：\n\nMidJourney is proficient at adapting actual art styles to create an image of any combination of things the user wants. It excels at creating environments, especially fantasy and sci-fi scenes, with dramatic lighting that looks like rendered concept art from a video game.Midjourney 擅长于运用实际的艺术风格生成用户想要的任何事物的图像。它擅长于创建环境，特别是浪漫梦幻的场景，并且会使用戏剧性的光照效果让画面看起来像是从游戏渲染出来的概念艺术。简单点说：人工智能，以文生图，效果炸裂。下面是 Midjourney 官方给出的最新版本 V5 的生成样例，只能说效果非常惊艳。\n\n\nMidjourney 站点直达官网链接\n\n\nMidjourney 官方主页,链接: https://midjourney.com/\n需要科学上网\n新用户注册可以进来这个地址，然后点右下角的「Sign In」按钮。\n\nDiscord说明:\n\n\nMidjourney 在 Discord 的服务器, 链接: https://discord.gg/midjourney\nDiscord 是一个聊天社区产品，Midjourney 目前搭载在 Discord 上给用户使用。\n用户在服务器聊天室中给 Midjourney 机器人发指令和提示语，机器人就会执行图像生成。\n\n基础设置解析\n输入指令：&#x2F;settings 发送后，出现下图设置项。\n\n\n\n1-5 分别对应 Midjourney 的版本，MJ version 5.1 为当前最新版本\n\n\n\nNiji version 4 和 5 代表着动漫风格的模型。\n\n\n\nStyle low、med、hight、very higt 分别代表着艺术风格化程度，从低、中、高、非常高。Reset Settings 为重置设置。\n\n\n\nPublic mode 代表着公开模式，生成的图，会出现在其他地方。非 60 美元&#x2F;月套餐，只能是该模式\nStealth mode 代表着秘密模式，仅限 60 美元&#x2F;月套餐用户使用。\nRemix mode 为混音模式。\nFast mode 为快速模式。60 美元&#x2F;月套餐，每个月有 30 个小时快速出图时间。30 美元&#x2F;月，每个月有 15 个小时快速出图时间 。10 美元&#x2F;月，每个月有 200 张快速出图套餐，200 张额度很快会用完，不推荐此套餐。\nRelax mode 低速模式，快速模式一分钟左右出图，而低速模式可能需要 10 分钟左右，速度比较慢。\n\n\n\n生成的图片下方，有 2 排按钮，后面的数字代表上方对应的图片序号。\nU &#x3D; Upscale to max；\nV &#x3D; Make Variations\n\n\nniji-漫画模型\nNiji是Midjourney中用于绘制二次元（动漫）风格的专用模块\n\n每个模型的区别\n在下图中，从 Niji4 到 5 可以看出，动漫画风更加高级，更加二次元，从卡通走向成熟，Test 模型是测试模型：\n\n\n\nniji 5 里有 4 种风格,见下图：\n\n\n\n分别是默认风格、表现力风格、可爱风格和最新出的景观风格，\n下面放一下风格之间的区别（因为景观风格是刚出的，这里没有放示意，可以自己尝试一下）。\n\n\n\nRemix混音模式，这里选择了一张官方的图，一堆艺术线稿样式的南瓜，然后选择“Make Variations”。\n\n\n\n在弹出窗口中修改或输入新的提示。例如在输入框里输入 pile of cartoon owls（一堆卡通猫头鹰）。\n\n\n\n则对应的猫头鹰代替南瓜。\n\n\n用法解析Prompt：\na cute cat, 3d, octane render, blender --ar 16:9 --niji 5 --s 400 --style expressive\n\n\n其中–ar 16:9 代表着图片的分辨率比例。长宽比为 16:9。\n–niji 5 代表着 niji 5 版本模型。\n–s 400 代表着艺术化风格化, 最新的 niji 5 中，最高支持到 400 的艺术风格化\n–style  Niji V5版本的 cute 和 expressive 两种模式。cute就是字面意思，更可爱的风格；expressive更偏3D和欧美样式。\n\n表情包生成Prompt:\nemoticon pack, cute white round fluffy chubby kitty emoticons, 9 [cute, expecting, happy, crying, sad, disappointed, shy, heart-felt, eating], disney style, 2d --style expressive --niji 5表情包，可爱的白色圆形蓬松胖乎乎的小猫表情包，9[可爱，期待，快乐，哭泣，悲伤，失望，害羞，心有感觉，吃]，迪士尼风格，2d --style expressive --niji 5\n\n\n国风插画_踏鹊枝模式：niji 5 的 style expressive\n💡核心关键词：\n\n【中国古典美人】ancient Chinese beauty\n【喜鹊在侧】with magpie\n【水墨渲染】 ink blending\n【艺术家】art by Qiu Ying, Zhang Daqian\n\n\n 可以多尝试运用不同的颜色组合，比如 blue and green color, yellow and green color 等~\n\nPrompt:\nan ancient Chinese beauty, solo, wearing chinese costumes, with magpie, ink blending, art by Qiu Ying, Zhang Daqian, blue and red color, bright.一位中国古代美女，独唱，身着中国服饰，与喜鹊、墨汁交融，艺术由仇英、张大千所作，颜色蓝而红，鲜艳。\n\n\n一个小女孩Prompt:\nA girl, 16 year old Luoli, dressed in Hanfu, is a Chinese beauty, cute,Hayao Miyazaki&#x27;s Painting Style , 8K, octane render, highly detailed, intricate details --ar 2:3 --niji 5一个女孩，16岁的萝莉，穿着汉服，是一个中国美女，可爱，宫崎骏的画风，8K，渲染，高度细致，复杂的细节--ar 2:3--niji 5\n\n\nMJ-现实混合模型每个模型的区别\nv1 版本画的花朵，比较抽象。\nv2 版本，花朵细节增加。\nv3 版本，细节相对于 v2 更加丰富，且创意更好。\n\n\n\n在下图，v4 到 v5 版本可以看出猫咪的细节更加真实。\nv4 看上去像绘画，v5 就更像照片，\nTest Photo 模型是 Midjourney 照片测试模型：\n\n\n\n在 v4 版本中有 a、b 和 c（默认）\n\n\n\nv5.1 的模型相对 v5 效果更强，简单的关键词也可以产生很好的效果，\n改善了边缘细节，并提升了画面清晰度，\nv5.1 下还有 raw 模式，该模式可以支持长 prompt，\n更能准确的理解关键词，生成的图片更加准确，如下图：\n\n\n用法解析一个小女孩Prompt:\nA girl, 16 year old Luoli, dressed in Hanfu, is a Chinese beauty, cute, 8K, octane render, highly detailed, intricate details --ar 2:3 --v 5.1一个女孩，16岁的萝莉，穿着汉服，是一个中国美女，可爱，8K，渲染，高度细致，复杂的细节 --ar 2:3--v 5.1\n\n\n写 Prompt 的基本思路\n首先，我们要明确一点，写 Prompt 提示语最重要的并不是我们自身要知道多少多少个绝妙的提示词，也不是我们能写出多么长的提示语。最重要的是我们要有正确的写提示语的思路。顺着这个思路我们可以通过 ChatGPT 或者搜索引擎去帮助我们找到所需要的提示词，甚至可以给选来呢 ChatGPT，让它学习这个思路，然后自动输出 Midjourney 的完整提示词。\n\n回到写 Midjourney 提示语的思路。\n图像生成是一种艺术表达形式，而所有艺术形式的创作的最基本思路就是两点：内容 + 形式。\n\n所谓内容，就是指我们希望在这个画布上塞一些什么东西，说的具体点就是「在什么时间、什么地点，什么人在干什么事」；所谓形式，就是指构图、光线、色彩、氛围等等要素，包括一些特定的风格，都属于形式的范畴。基于这个简单思路我们来举个例子：\n\n\n上面这个例子给大家展示了一个由粗到细写提示语的过程。但其实当你有一定经验之后，很多词你是会预先想到的。比如上面这个例子中的画幅、场景、构图等等。所以在后面的文章，我们会继续将提示词的写法细拆得更具体一些。\n\nMidjourney Prompt 提示语说明Prompt 是一段简短的文本语言，供 Midjourney Bot 理解并生成图像。\n\nMidjourney Bot 会将 Prompt 中的词句和短语拆分成更小的片段，称为令牌（token），然后将这些 token 与用于训练机器的数据进行比较并用于生成图像。精心撰写的 Prompt 可以帮助生成独特美妙的图像。\n\nPrompt 结构基础提示语\n基础的提示语可以简单到一个单词、短语或表情符号\n\n\n高阶提示语\n更高阶的提示语可以包括若干个图像 url、多个文本短语和若干个参数\n\n\n图像提示语 \n\n可以将图像 url 添加到提示语中，以影响最终图像的风格和内容。图像 url 总是出现在提示语的前面。\n\n文本提示语 \n\n要生成的图像的文本描述。请参阅下面的提示信息，精心编写的提示语有助于生成惊艳的图像。\n\n参数 \n\n参数改变图像的生成方式。参数可以改变图像宽高比、模型、升频器等等。参数一般放在提示语的最后。\n\n写提示语的建议提示语的长度提示语可以非常简单。\n\n一个单词（甚至一个表情符号）就能生成一幅图像。很短的提示语将严重依赖于Midjourney 的默认风格，所以更具描述性的提示语将更好地呈现出独特的内容。\n然而，这并不意味着超长的提示就是更好的。\n最重要的是要专注于你想要创造的内容概念。\n\n语法Midjourney Bot 并不能完全像人类一样理解语法、句子结构和单词。所以，提示语的用词很重要。关于语法、用此方面有一下小提示：\n\n在许多情况下，更具体的同义词效果更好。举个例子：不要用「big」，试试「huge」「enormous」或「immense」。\n保持简洁。如果可以删除不必要的单词，更少的单词意味着每个单词都有更大的影响力。\n正确地使用逗号、括号和连字符号来帮助组织你的想法，但同时要理解 Midjourney Bot 不一定能可靠地理解它们。\nMidjourney Bot 不考虑大写。 \nMidjourney Model Version 4 在解释传统句型结构方面略优于其他模型。\n\n专注于你想要的事物最好是描述你想要什么，而不是你不想要什么。\n\n如果你要求一个「没有蛋糕」的聚会，\n你得到的图像结果可能还是会包含一个蛋糕。\n如果希望确保某个物体不在最终生成的图像中，\n请尝试使用「no」参数进行提示。\n举个例子：–no cake\n\n想想哪些细节很重要\n一些没有说出来的事情可能是很重要的。按照你的想法进行具体或模糊的表达，但你遗漏的事情对于 Midjourney Bot 来说都是随机的。含糊其辞是获得随机性、多样性结果的好方法，但你可能得不到你想要的具体细节。 \n所以，试着弄清楚任何对你来说重要的背景或细节。可以从以下方面着手进行思考: \n\n● 主题：person, animal, character, location, object ……● 媒介：photo, painting, illustration (插画) , sculpture (雕塑) , doodle (涂鸦) , tapestry (壁毯) ……● 环境：indoors, outdoors, on the moon, in Narnia (纳尼亚) , underwater, the Emerald City (翡翠城) ……● 灯光：soft, ambient (环境光) , overcast (阴天) , neon (霓虹) , studio lights ……● 颜色：vibrant (鲜艳) , muted (柔和) , bright, monochromatic (单色) , colorful, black and white, pastel (蜡笔画) ……● 情绪：Sedate (稳重) , calm, raucous (喧闹) , energetic (精力充沛) ……● 构图：Portrait (人像) , headshot (大头照) , closeup (特写) , birds-eye view (鸟瞰) ……\n\n避免只用一个复数单词\n 复数单词有很大的偶然性。试试具体的数字。\n「Three cats」比「cats」更具体。集体名词也可以用，\n用「flock of birds」代替「birds」同样更具体。\n\nstylize （艺术风格化)\n使用方式“–s”或“–stylize” ，\n低风格化生成的图像与提示非常匹配，但艺术性较差。\n高风格化创建的图像非常具有艺术性，创意性更强，但与提示的联系较少。\n–stylize 的默认值为 100，\n并且在使用默认 [V4、V5 模型] 时接受 0-1000 的整数值。\n如下图所示：随着风格化数值越高，则画面的细节和表现力越强，细节和层级也越复杂。\n\n\n\nv5 版本，风格化数值支持范围 0-1000，默认 100。\n官方标注这里有缺少，最新的 niji 5 中，支持最高到 400 的艺术风格化\n\n\n命令之间的组合运用chaos (混乱)\n使用方式“–c”或“–chaos” ，\nchaos 的数值影响初始图像，\n高 chaos 值将产生更多不寻常和意想不到的结果和组合。\n较低的 chaos 值具有更可靠、可重复的结果，\n搭配 seed 值使用，将产生相似的图片。\n–chaos 数值范围为 0-100，默认值为 0。\n如下图所示：混乱值越高，则生成一组图片之间的差异性组合越大，可能会出现新的图片，越低则越接近原图，可以用于生成相似人物，数值可以写 5 以内。\n\n\nno (负面提示)\n使用方式“–no” ，例:–no plants 尝试从图像中移除植物。\n例如生成了一个卧室的图。\n\n\n\n当我不想要床出现在房间里时，则加入 –no bed. 则生成图不会出现床。\n\n\nstop (停止)\n使用方式“–stop ” ，\n–stop 接受值:10-100。默认–stop 值为 100。–stop0 不起作用。\n使用–stop 选择在什么进度结束。\n较小的百分比结束会产生更糊、不详细的结果。\n下图中，添加–stop 不同的数值，得到对应进度生成图。当 –stop 100，则是就是 100%生成的正常图。\n\n\nrepeat (重复)\n使用方式“–r”或“–repeat ” 。\n众所周知，MJ 属于抽卡模式，\n游戏里大家都知道可以十连抽，那我们的 mj 可以不可以呢？\n答案是可以的。\n这里用到的就是重复命令“–repeat”,\n用这个命令可以一次性生成多次图片，可以加速我们的抽卡环节。\n–r 后输入我们需要出图的次数。\n要注意的是标准版 30 美元&#x2F;月订阅者: 2–10 ，\nPro版60美元&#x2F;月订阅者:2–40。\n由于生成图片较多，需要点击 yes 确认；反悔的话，可以点击 cancel all，进行取消。\n\n\n:: (多重提示)\n当我们使用 :: 作为分隔符时，可以分别处理两个或多个单独的关键词，\n 而且还可以设置每个关键词的比重。\n0.5 的时候，0 可以省略，写成.5，如“::.5” 。\n如果关键词是：hot dog，则出现热狗。\n\n\n\n如果通过::输入，关键词是：hot:: dog (分开联想创作，热和狗) ：\n\n\n\n这里是缩写，实际 hot:: dog &#x3D; hot::1 dog::1，等于 1:1。\n也可以用“,”号来区分，如 hot,dog，也会分开联想，但还是有些区别。\n第二个示意，输入关键词：baby corn（玉米笋）出现对应的玉米笋。\n\n\n\n将 baby corn 变为 baby:: corn。\nbaby 和 corn 的权重是 1:1。\n生成的图如下图所示。\n\n\n\n当 baby::2 corn。\n即婴儿和玉米的权重是 2:1。则玉米出现的占比更小，\n如图生成出来的图片出现玉米糊。\n\n\n\n当 baby::100 corn。\n即婴儿和玉米的权重是 100:1，\n生成的画面几乎没有玉米的画面。\n\n\n\n注意，这里::权重的总和必须是正数,最好大于 0.5,等于 0 的时候，生成的图片会出现与关键词无关\n例:baby:: corn &#x3D; baby::1 corn::1，1+1&#x3D;2\n由此可以得到：\nbaby:: corn::-2 ❌\nbaby:: corn::-.5 ✅\nbaby::2 corn::-2 ❌\nbaby3:: corn::-2 ❌\nbaby::1.5 corn::-2 ❌\nbaby::51 corn::-50 ✅\n只是示意，平时不要写这么刁钻的，可以写成完整的，\n如::写成::1，-.5 写成-0.5；\n用官方示意再解释一下，输入关键词：\nvibrant tulip fields （生机勃勃的郁金香花田）得到如下图所示：\n\n\n\n这里更改关键词：\nvibrant tulip fields:: red::-.5（生机勃勃的郁金香花田,不要红色 ）\n得到如下图所示：\n这里“red::-0.5”等同“–no red” 如果“red::2”则“画面全是红色的郁金香”\n\n\niw (图像权重，图生图)\n使用方式，例“–iw 2” 。\n–iw 的数值，会影响我们上传的图像与文本之间的比重；\n 默认–iw 数值为 1，\n较高的 –iw 值意味着我们上传的图片对生成的结果，影响更大。\n 数值范围为 0.5-2。\n\n\n\n垫一张上面的图，\n加上一点描述:a cute girl sitting in a fantasy world. \n当–iw 1（默认）时如下图所示：\n\n\n\n会看到生成的图片动作相近，略有差距\n当–iw 2 时。\n\n\n\n这里会看到生成的图片动作比较接近。\n当–iw 0.5 时候\n此时生成的图片差距比较大。\n\n\n&#x2F;describe (图生文)\n首先，这里我们找一张模特照片（图片来自于 unsplash）：\n\n\n\n 使用方式，输入框中输入“&#x2F;describe” ，\n添加图片后，会得到对应的四组关键词。\n\n\n\n选择其中一组关键词生成如下图：\n\n\n\n配合前面提到的 seed 值，\n使用相同 seed 值 + chaos,生成微调画面。如下图所示：\n\n\n\n这里要注意的是，\n如果开始了混音模式，点图片下的 V 键，\n生成四组图片时，生成的图片效果效果可能不是很好，\n卡通人物的话不是很明显。\n下图左侧图片未开启 remix 模式。右侧是开启了 remix 模式。\n\n\n\n然后还是选择一组关键词，\n用图生图的方式生成图片，加上“–iw 2”\n原图如下：\n\n\n\n生成图如下：\n\n\n\n网上很多 mj 控图大法，\n可以控制生成相同角色的教程，实际效果其实不是很准确。\nMidjourney 的可控性还没那么强。\n 无非就是 seed 值，加 iw 权重，垫图，再 chaos 进行微调，\n但只能有点相似，细看还是有区别的，\n做不到一模一样（有个插件可以进行换脸，名字叫 InsightFaceSwap）。\n但可以使用一些命令，在同一张图中，生成相似的图如：\n4 panels withdifferent poses （可以生成 4 个不同表情 ）\n\n\n\ncharacter sheet（可以生成一组相似动漫角色）：\n\n\n\nthree views of an image, generate three views, namely the front view, the side view, and the back view. \n（三视图，还是需要垫一张三视图，效果才会出来）\n\n&#x2F;blend (混合)\n使用方式，输入框中输入“&#x2F;blend” 。\n该命令下，可以上传 2-5 张图像，并将它们合并成一个新的图像。\n\n\n\n例如上传一张空鱼缸图片和一张金鱼，就可以生成一张有鱼的鱼缸。\n\n\ntile (无缝贴图)\n使用方式“–tile ” ，\n可用作重复拼贴的图像，创建壁纸或纹理的无缝图案。\n 适用于模型版本 v 1、2、3 和 5。\n\n\nvideo (动画)\n使用方式“–video” ，\n用于获取图像生成的过程动画，效果如下:\n\n\n{} (排列组合)\n使用方式，例 {red,yellow} ，可以修改部分关键词的同时，\n快速创建多次作业 最多可以创建 40 个作业 。\n\n假如我们要生成三张不同颜色的花，正常需要输入三组命令：\n\na red flower.\na green flower.\na yellow flower.\n\n这里只需要输入：\n\na {red, green, yellow} flower\n\n则会生成三组图片；也可用于尺寸 ar、模型版本、艺术风格等，如：\n\n–ar {3:4,16:9} –v {3,4,5,niji} –s {50,250,750} –iw {.5,1.5,2}\n或者组合使用，如：\nPrompt: a {red, green, yellow} flower. –ar {3:4,16:9} –s {50,100}\n或 Prompt: A {girl,boy,cat} is standing in the {classroom,bedroom} –ar {3:4,16:9} –s {50,100,800}\n\n如何需要用到 2 个单词来形容一组画面，在排列组合里,可以用反斜杠“\\”来分割 ，如下：\n\nPrompt: a {red,Cartoon , yellow} flower.\n则会生成一朵红色花，和一黄色卡通花：\n\n\n&#x2F;prefer suffix (默认后缀)\n使用方式，输入框输入“&#x2F;prefer suffix” ，\n指定文字或命令，添加到关键词末尾，\n再次输入“&#x2F;prefer suffix”，取消设置 。\n可以定义每次出图的后缀。\n\n\n\n如输入关键词，\nPrompt: a cat. 则会自动加上后缀：\nPrompt: a cat, 8k, high detail. –ar 3:4\n&#x2F;settings 可以看到我们设置默认后缀，\n缺点:不能在关键词后加入任何命令，如“a cat. –s 200”,否则无法出图。\n群里看到很多人遇到过，明明关键词没问题，别人都正常出图，\n就自己不行，这里可能就是自己不小心误操作，设置了默认后缀。\n因为我们的 MJ 默认命令只能在最后，如果你加入了“–s 250”，\n那出来的结果关键词就是 –s 250 8k,high detail,则不能识别。\n如下图：\n\n\n&#x2F;prefer option set (预设)\n上面的方式局限性比较大，但我们还可以用预设来方便我们生成图片。\n使用方式，输入框输入“&#x2F;prefer suffix”\n创造一个预设，option 设置名称，\n如 fg1(风格 1，可以自定义习惯的英文，或者贴合 mj，如 P、K)，\nvalue 类型里写–s 250 –ar 3:4。\n\n\n\n这样只要后缀输入我们预设，则会自动加上设置的后缀命令，使用方法：\nPrompt: a cat –fg1 &#x3D; Prompt: a cat –s 250 –ar 3:4\n可以创建多个预设，省去输入的时间。\n注：最多可以设置 20 个预设， \n&#x2F;prefer option list 可以查看所有预设。\n\n常用命令拆解常见的命令有：\n--seed：种子值--q：品质--c：混乱--no：负面提示--iw：权重（0.5-2）::（多重提示）-- repeat（重复）--stop（停止）--title（无缝贴图：适用于模型版本 1、2、3、5）--video（过程动画，适用于模型版本 1、2、3、test）/blend（最多 5 张图片混合）/describe（以图生文）--uplight（升频器，放大图片使用，添加适量的细节和纹理，用 v1-v4 的模型时候，或者默认 niji 模型，可以将默认的 256*256 或 512*512，放大为 1024*1024，因为现在我们默认用 v5，已经是 1024*1024 了，所以一般用不到了）--upbeta（ 同上，同样也是放大，放大后表面更光滑，且不会添加额外的细节。v4 和默认 niji 模型的时候可以放大到 2048*2048，v1-v3 还是 1024*1024，v5 不支持）--upanime（同上，niji 4 的默认升频器，适合动漫风格的插画，也是可以放大到 1024*1024，适用于 v1-v4 模型，因为现在 niji 5 默认也是 1024*1024，一般也不用到了，三种升频器都是加到关键词最后，之后点击图片下的 u1、u2、u3、u4 进行使用）\n\n关于 Quality（品质）使用方式“–q”或“–Quality” ，这里决定了我们最终生成的图片质量，更高的参数会产生更多的细节，类似我们做三维渲染一样，时间越长，效果会更好，当然同时也会消耗更多的 GPU 分钟数，注意这里的质量设置不会影响图片分辨率。\n\n如下图所示，分别是：–q .25、–q .5 和–q 1。其中–q.5 对应的模式是 Half quality。-q 1 对应的模式是 Base quality。\n\n\n\n–q .25：最快得到结果。速度提高 4 倍数，GPU 渲染分钟数减少 3&#x2F;4。\n–q.5：减少细节。速度提高两倍，GPU 渲染分钟数减少 1&#x2F;2。\n–q 1：默认设置，细节和速度之间的平衡。\n\n\n\n注意的是 v5 最高支持 –q 1，\n就算输入–q 2 也会向下兼容 q 1，如果想使用–q 2，\n可以使用 v1、2 或者 v3 模型。\n\n\n关于 seed（种子值）\n虽然我们的出图是随机的，但毕竟是程序化的控制，\n所以我们每张图片都对应着一个 seed 值，\n使用相同的 seed 值和关键词将产生几乎一样的图片（实际就是一样的）。\n使用方式“–seed xxxx ” 如“–seed 12345 ” 。\n如下图所示：使用相同 seed 值，生成的两次图片，是同样的结果。\n\n\n\n获取 seed 值的方式如下图所示：\n\n\n\n右键-添加反应-显示更多，输入 envelope 选择邮件图标，\n点击后，在 Midjourney 私聊中获取 seed 值。\n\n\n图片放大推荐由于 Midjourney 生成的尺寸大小有限制，通常默认 10241024，或者 20482048，图为官方尺寸示意：\n\n如果想要图片分辨率变得更大，则可以下面两个网站。\n\nhttps://bigjpg.com/ ：每月免费次数 20 张，支持 png。\n付费用户可以使用 8 倍和 16 倍放大，最低 500 张每个月。\nhttps://www.upscayl.org/ ：免费、本地，适用于公司设计稿不能对外发的场景。\n\n素材管理软件，除了我们常用的 Eagle，也可以使用 Billfish（免费）和 Connecter（免费）。\n\n其中 Connecter 本地目录，不创建文件夹，\n可预览图片或 3d 文件格式，如 psd、tiff 和 c4d、max 等等。\n\n\nConnecter 也可以快速预览多个文件\n\n如果我们有很多个文件夹，里面有若干个图片文件，\n这样就可以用软件，一键预览所有文件，更加方便我们找到素材，\n示意动画：\n\n\n有一些 logo 或图标，格式是 jpg 或者 png 格式。\n\n可以使用 https://vectorizer.ai/ 快速图片转矢量。\n\n快速抠图网站：\n\nhttps://pixian.ai/\nhttps://www.remove.bg/zh\n\n真正的咒语生成器\n下面这个详细的写 Midjourney 提示词思路几乎可以囊括 90% 以上的场景，乍一看比较复杂，但其实是有内在逻辑的，我将其整体成了表格以后写文生图的提示词都可以参考这个思路，或者你还可以试试写一些例子并教会 ChatGPT 用这个思路。\n整体大框架包括先后四个要点：\n1是否需要限定特定行业或领域（比如 logo 设计和电商产品图就完全不是同一个东西）\n2描述画面内容（类似记叙文：时间、地点、人物、事件，重要的部分加修饰，比如人的装扮之类的）\n3选择喜欢的画面风格（比如要求是写实的摄影、泡泡玛特3D渲染风格，或者抽象的浮世绘）\n4给更多画面形式的约束（想象自己是摄影师，怎么构图，要什么样的光线和视角等等）具体的说明可以参照下面的详细表格\n\n\n\n\n","categories":["技术"],"tags":["技术","心得","AI绘画"]},{"title":"mysql遇到的小问题1055报错解决方法","url":"/2020/06/06/mysql%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%981055%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"MySQL发生[Err] 1055的解决方案在mysql库中进行insert into,执行结束后，总是会跳出报错\n\n[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_b\n\n第一次遇到这样的错误，貌似是由于MySQL的版本问题,发现自己用的是MySQL 8版本\n此时有两种解决方案方案一：临时修改（服务器重启后会失效）\n-- 通过该语句查询这个值 --select @@sql_mode;\t\n会得到如下结果：\nONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n再执行下述语句，引号里的内容是上述结果剔除ONLY_FULL_GROUP_BY后余下的内容\nset @@sql_mode= &quot;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;;\n\n方案二：修改mysql配置文件（服务器重启后生效）在my.cnf文件中的[mysqld]的下面加上下列语句\nsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION\n一般不建议将ONLY_FULL_GROUP_BY关闭，因为这个符合SQL标准,也可以使用MySQL中的一个函数 any_value(field)，括号中是一个字段，可以使得括号中的字段既能被查询出来又可以不出现在group by语句中\ndocker中配置调整如果你用的是docker容器\n#查询出mysql的容器名称docker ps#进入docker环境，下面的mysql1是我的容器名称docker exec -it mysql1 /bin/bash#查看配置文件cat /etc/mysql/my.cnf#如果要修改，先安装下vim编辑器apt-get updateapt-get install vim#修改mysql配置文件vim /etc/mysql/my.cnf#在mysqld最下面加入sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION\n","categories":["技术"],"tags":["技术","心得","mysql"]},{"title":"Linux_Deepin使用命令","url":"/2020/02/17/linuxCZ/","content":"Linux(Deepin)系统 apt-get 命令的使用：安装、更新、卸载软件包\n\napt-get 命令适用于 deb 包管理式的 Linux 操作系统（Debian、Ubuntu等），主要用于自动从互联网软件仓库中搜索、下载、安装、升级、卸载软件或操作系统。\nUbuntu 软件包查找: https://packages.ubuntu.com/\n1. 安装 软件包\n\napt-get install PackageName &#x2F;&#x2F; 普通安装\napt-get install PackageName&#x3D;VersionName &#x2F;&#x2F; 安装指定包的指定版\napt-get –reinstall install PackageName &#x2F;&#x2F; 重新安装\napt-get build-dep PackageName &#x2F;&#x2F; 安装源码包所需要的编译环境\napt-get -f install &#x2F;&#x2F; 修复依赖关系\napt-get source PackageName &#x2F;&#x2F; 下载软件包的源码\n\n\n2. 卸载 软件包\n\napt-get remove PackageName &#x2F;&#x2F; 删除软件包, 保留配置文件\napt-get –purge remove PackageName &#x2F;&#x2F; 删除软件包, 同时删除配置文件\napt-get purge PackageName &#x2F;&#x2F; 删除软件包, 同时删除配置文件\napt-get autoremove PackageName &#x2F;&#x2F; 删除软件包, 同时删除为满足依赖&#x2F;&#x2F; 而自动安装且不再使用的软件包\napt-get –purge autoremove PackageName &#x2F;&#x2F; 删除软件包, 删除配置文件,&#x2F;&#x2F; 删除不再使用的依赖包\napt-get clean &amp;&amp; apt-get autoclean &#x2F;&#x2F; 清除 已下载的软件包 和 旧软件包\n\n\n3. 更新 软件包\n\napt-get update &#x2F;&#x2F; 更新安装源（Source）\napt-get upgrade &#x2F;&#x2F; 更新已安装的软件包\napt-get dist-upgrade &#x2F;&#x2F;更新已安装的软件包（识别并处理依赖关系的改变）\n\n\n4. 查询 软件包\n\ndpkg -l &#x2F;&#x2F; 列出已安装的所有软件包\napt-cache search PackageName &#x2F;&#x2F; 搜索软件包\napt-cache show PackageName &#x2F;&#x2F; 获取软件包的相关信息, 如说明、大小、版本等\napt-cache depends PackageName &#x2F;&#x2F; 查看该软件包需要哪些依赖\napt-cache rdepends PackageName &#x2F;&#x2F; 查看该软件包被哪些包依\napt-get check &#x2F;&#x2F; 检查是否有损坏的依赖\n\n\n5. apt-get –help执行命令: apt-get –help，输出:\n\n","categories":["软件教程"],"tags":["linux","软件","阅读"]},{"title":"Linux中使用nohup详解","url":"/2020/11/10/nohupxj/","content":"\n\nnohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。\nnohup 是 no hang up 的缩写，就是不挂断的意思。\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。\n在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。\n\n案例  nohup command &gt; myout.file 2&gt;&amp;1 &amp;   \n在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。  0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 \n这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中\n\nnohup和&amp;的区别&amp; ： 指在后台运行\nnohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行\n &amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出\n那么，我们可以巧妙的吧他们结合起来用就是nohup COMMAND &amp;\n这样就能使命令永久的在后台执行例如：sh test.sh &amp; \n将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但标准输出和标准错误信息会丢失（缺少的日志的输出）\n将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。\nnohup sh test.sh\n将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行\n nohup sh test.sh  &amp; \n将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。\n\n ps -aux | grep &quot;hexo&quot; \n查询进程\n","categories":["软件教程"],"tags":["linux","软件","阅读"]},{"title":"关于oracle下的DG搭建","url":"/2021/01/06/oracle%E2%80%94DG%E6%90%AD%E5%BB%BA/","content":"oracle11g高可用,oracle11g 搭建DG环境总结一、前言：   网络上关于dataguard的配置文章很多，但是很多打着oracle11g的文章实际都是只能在9 10 上运行，比如FAL_CLIENT在11g中已经废弃，但是现在网络上的文章都是没有标注这一点。而且对于具体含义语焉不详对于新手只能知其然而不知其所以然。这篇文章我就想让像我这样的人对于dataguard配置不仅仅知道怎么配置，还要知道为什么需要这样配置，这样的效果才是最好的。  这篇文章不仅仅是记录如何配置，还介绍了为什么是这样，以及注意要点，我希望这个文章可以作为进行dataguard配置的一个参考手册。\n二、前提1.主库是归档模式：  如果我们不清楚为什么是归档模式，那我们就应该也不会清楚dataguard是用来做什么的。透过很多修饰的官方语言，我们需要明确DG（dataguard简称，后同）实际上的作用就是用来高可用。而实现原理就是从主库获取数据到从库，在主库发生异常的时候，从库接管主库，完成身份的变化。可以一个主库，最多9个从库。同时分为逻辑standby和物理standby这里我们讨论的是物理standby.   一旦创建并配置成 standby 后，dg 负责传输 primary数据库 redo data 到 standby 数据库，standby 数据库通过应用接收到的 redo data 保持与 primary 数据库的事务一致。   这下清楚了吧，需要保证主从库一致，需要传输archive log和redo log到从库，如果不是归档模式无法保证主从库的数据一致。\n2.从库只需要安装数据库软件，数据从主库传输后完成。\n3.很多人说11g有了active dataguard(ADG)，逻辑standby 实际上已经没什么用处了。\n主从库硬件最好一致。oracle数据库版本需要一致。内存检查项：\ngrep MemTotal /proc/meminfo\n\n 交换分区检查项：如果内存在1-2G,swap是1.5倍；2-16G,1倍；超过16G，设置为16G即可。\n grep SwapTotal /proc/meminfo\n查看共享内存大小：\ndf -h /dev/shm\n查看系统处理器架构，与oracle安装包一致\nuname -m\n空间空间 &#x2F;tmp必须大于1G\ndf -h /tmp\n配置环境数据库用户必须有sysdba权限后面的环境：\n\n主库 192.168.65.129 数据库实例名：orcl        db_unique_name:orcl从库 192.168.65.130 数据库实例名：std       db_unique_name:std\n\n测试环境为：两台服务器配置一样：Oracle Linux Server release 6.5  X86_64, DB  11.2.0.4.0\n前提环境：一台已经安装好数据库软件并创建数据库实例的服务器\n另一台也就是备库，只安装了数据库软件，空实例。\n安装环境与创建数据库这里就不用说了，很简单的。\n整个环境为成4个步骤：\n\n1，主库(orcl)修改\n2，备库(std)修改\n3，主备duplicate数据库\n4，测试DG是否成功\n\n判断DG是否已经安装：\nselect * from v$option where parameter = &#x27;Oracle Data Guard&#x27;;\n\n如果是true表示已经安装可以配置，否则需要安装相应组件。\n\n教程开始su - oracle#启动库lsnrctl start sqlplus / as sysdba#启动监听startup#查看强制记录日志状态SQL&gt; select name,force_logging from v$database;NAME\t  FOR--------- ---ORCL\t  NO#修改强制记录日志alter database force logging#查看强制记录日志状态SQL&gt; select name,force_logging from v$database;NAME\t  FOR--------- ---ORCL\t  YESexitcd $ORACLE_HOME/dbs#传输密码文件至备库,记得修改下备库的orapw文件名称（此步骤只在主库上操作）scp orapworcl ora11g-2:$ORACLE_HOME/dbs/orapwstd\n\n创建standby日志组，创建完成后查询是否成功一般而言， standbyredo 日志文件组数要比 primary 数据库的 online redo 日志文件组数至少多一个。推荐 standbyredo 日志组数量基于 primary 数据库的线程数(这里的线程数可以理解为 rac 结构中的 rac节点数)。\n\n有一个推荐的公式可以做参考：(每线程的日志组数+1)*最大线程数假设现在节点是1个，则&#x3D;(3+1)*1&#x3D;4如果是双节点 则&#x3D;(3+1)*2&#x3D;8这里我们创建4个standby logfile:另：不建议组号group#紧挨着redo，因为后续redo有可能调整，这里我们从建立从11到14的standby logfile\n\ncd $ORACLE_BASE/oradata#创建强制日志路径mkdir standbylogalter database add standby logfile group  11 &#x27;/u01/oracle/app/oradata/standbylog/standby11.log&#x27; size 50m;alter database add standby logfile group  12 &#x27;/u01/oracle/app/oradata/standbylog/standby12.log&#x27; size 50m;alter database add standby logfile group  13 &#x27;/u01/oracle/app/oradata/standbylog/standby13.log&#x27; size 50m;alter database add standby logfile group  14 &#x27;/u01/oracle/app/oradata/standbylog/standby14.log&#x27; size 50m;#查看standby日志组SQL&gt; select group#,sequence#,status,bytes/1024/1024 from v$standby_log;SQL&gt; select group#,status,type,member from v$logfile;    GROUP# STATUS  TYPE---------- ------- -------MEMBER--------------------------------------------------------------------------------\t 1\t   ONLINE/u01/oracle/app/oradata/orcl/redo01.log\t 2\t   ONLINE/u01/oracle/app/oradata/orcl/redo02.log\t 3\t   ONLINE/u01/oracle/app/oradata/orcl/redo03.log\t11\t   STANDBY/u01/oracle/app/oradata/standbylog/standby11.log\t12\t   STANDBY/u01/oracle/app/oradata/standbylog/standby12.log\t13\t   STANDBY/u01/oracle/app/oradata/standbylog/standby13.log\t14\t   STANDBY/u01/oracle/app/oradata/standbylog/standby14.log7 rows selected.\n\n修改主库的pfile参数文件（只在主库上做）用spfile创建一个pfile，用于修改SQL&gt; create pfile from spfile;SQL&gt; show parameter spfile;NAME\t\t\t\t     TYPE\t VALUE------------------------------------ ----------- ------------------------------spfile\t\t\t\t     string\t /u01/oracle/app/oracle/product\t\t\t\t\t\t /11.2.0/dbhome_1/dbs/spfileorc\t\t\t\t\t\t l.oracd $ORACLE_HOME/dbsvi initorcl.ora---------------------------------------orcl.__db_cache_size=1895825408orcl.__java_pool_size=16777216orcl.__large_pool_size=33554432orcl.__oracle_base=&#x27;/u01/oracle/app&#x27;#ORACLE_BASE set from environmentorcl.__pga_aggregate_target=838860800orcl.__sga_target=2483027968orcl.__shared_io_pool_size=0orcl.__shared_pool_size=503316480orcl.__streams_pool_size=0*.audit_file_dest=&#x27;/u01/oracle/app/admin/orcl/adump&#x27;*.audit_trail=&#x27;db&#x27;*.compatible=&#x27;11.2.0.4.0&#x27;*.control_files=&#x27;/u01/oracle/app/oradata/orcl/control01.ctl&#x27;,&#x27;/u01/oracle/app/fast_recovery_area/orcl/control02.ctl&#x27;*.db_block_size=8192*.db_domain=&#x27;&#x27;*.db_name=&#x27;orcl&#x27;*.db_recovery_file_dest=&#x27;/u01/oracle/app/fast_recovery_area&#x27;*.db_recovery_file_dest_size=5218762752*.diagnostic_dest=&#x27;/u01/oracle/app&#x27;*.dispatchers=&#x27;(PROTOCOL=TCP) (SERVICE=orclXDB)&#x27;*.open_cursors=300*.pga_aggregate_target=824180736*.processes=150*.remote_login_passwordfile=&#x27;EXCLUSIVE&#x27;*.sga_target=2474639360*.undo_tablespace=&#x27;UNDOTBS1&#x27;#以下内容是需要新增的*.db_unique_name=&#x27;orcl&#x27;*.log_archive_config=&#x27;dg_config=(orcl,std)&#x27;*.log_archive_dest_1=&#x27;LOCATION=/u01/oracle/app/arch valid_for=(all_logfiles,primary_role) db_unique_name=orcl&#x27;*.log_archive_dest_2=&#x27;SERVICE=std valid_for=(online_logfile,primary_role) db_unique_name=std&#x27;*.log_archive_dest_state_1=enable*.log_archive_dest_state_2=enable*.log_archive_max_processes=4*.fal_server=&#x27;std&#x27;*.fal_client=&#x27;orcl&#x27;*.db_file_name_convert=&#x27;/u01/oracle/app/oradata/std&#x27;,&#x27;/u01/oracle/app/oradata/orcl&#x27;*.log_file_name_convert=&#x27;/u01/oracle/app/oradata/std&#x27;,&#x27;/u01/oracle/app/oradata/orcl&#x27;*.standby_file_management=&#x27;auto&#x27;\n\n手工创建&#x2F;u01&#x2F;oracle&#x2F;app&#x2F;arch,此目录是上面配置文件里面后加的mkdir -p /u01/oracle/app/archsqlplus / as sysdba#用修改过的pfile重新创建一个spfile，用于重启数据库（此步骤只在主库上做）SQL&gt; shu immediate;Database closed.Database dismounted.ORACLE instance shut down.SQL&gt; create spfile from pfile;File created.#数据库启动到mount状态：SQL&gt; startup mount;ORACLE instance started.Total System Global Area 2471931904 bytesFixed Size\t\t    2255752 bytesVariable Size\t\t  603980920 bytesDatabase Buffers\t 1845493760 bytesRedo Buffers\t\t   20201472 bytesDatabase mounted.#启动归档模式：SQL&gt; alter database archivelog;Database altered.#open数据库：SQL&gt; alter database open;Database altered.#查看是否启用归档模式SQL&gt; archive log list;Database log mode\t       Archive ModeAutomatic archival\t       EnabledArchive destination\t       /u01/oracle/app/archOldest online log sequence     71Next log sequence to archive   73Current log sequence\t       73#查看当前数据库是否使用spfile启动：SQL&gt; show parameter spfile;NAME\t\t\t\t     TYPE\t VALUE------------------------------------ ----------- ------------------------------spfile\t\t\t\t     string\t /u01/oracle/app/oracle/product\t\t\t\t\t\t /11.2.0/dbhome_1/dbs/spfileorc\t\t\t\t\t\t l.oraSQL&gt; select name,log_mode,force_logging from v$database;NAME\t  LOG_MODE     FOR--------- ------------ ---ORCL\t  ARCHIVELOG   YES\n\n添加静态监听（主库，备库都要做）主库监听配置\nnano $ORACLE_HOME&#x2F;network&#x2F;admin&#x2F;listener.ora\n\nORCL =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.137)(PORT = 1521))      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))    )  )ADR_BASE_ORCL = /u01/oracle/appSID_LIST_LISTENER=(SID_LIST =  (SID_DESC =      (GLOBAL_DBNAME = orcl_DGMGRL)      (ORACLE_HOME = /u01/oracle/app/oracle/product/11.2.0/dbhome_1)      (SID_NAME = orcl)  ))\n\n\nnano $ORACLE_HOME&#x2F;network&#x2F;admin&#x2F;tnsnames.ora\n\norcl =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.137)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl)    )  )std =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.138)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = std)    )  )  orcl_DGMGR =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.137)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl_DGMGRL)    )  )std_DGMGR =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.138)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = std_DGMGRL)    )  )#重启监听lsnrctl reload\n\n\n备库监听配置\nnano $ORACLE_HOME&#x2F;network&#x2F;admin&#x2F;listener.ora\n\nLISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.138)(PORT = 1521))      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))    )  )ADR_BASE_ORCL = /u01/oracle/appSID_LIST_LISTENER=(SID_LIST =  (SID_DESC =      (GLOBAL_DBNAME = std_DGMGRL)      (ORACLE_HOME = /u01/oracle/app/oracle/product/11.2.0/dbhome_1)      (SID_NAME = std)  ))\n\nnano $ORACLE_HOME&#x2F;network&#x2F;admin&#x2F;tnsnames.ora\n\norcl =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.137)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl)    )  )std =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.138)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = std)    )  )  orcl_DGMGR =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.137)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl_DGMGRL)    )  )std_DGMGR =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.65.138)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = std_DGMGRL)    )  )\n启动监听，看看是否有报错\n#重启监听lsnrctl reload#或者lsnrctl start\n主库端把pfile拷贝给备库端的$ORACLE_HOME&#x2F;dbs目录下,并重命名\ncd $ORACLE_HOME/dbsscp initorcl.ora ora11g-2:$ORACLE_HOME/dbs/initstd.ora\n\n\n备库端进行修改（注意目录结构）：cd $ORACLE_HOME/dbsnano initstd.ora------------------------------orcl.__db_cache_size=1895825408orcl.__java_pool_size=16777216orcl.__large_pool_size=33554432orcl.__oracle_base=&#x27;/u01/oracle/app&#x27;#ORACLE_BASE set from environmentorcl.__pga_aggregate_target=838860800orcl.__sga_target=2483027968orcl.__shared_io_pool_size=0orcl.__shared_pool_size=503316480orcl.__streams_pool_size=0*.audit_file_dest=&#x27;/u01/oracle/app/admin/std/adump&#x27;*.audit_trail=&#x27;db&#x27;*.compatible=&#x27;11.2.0.4.0&#x27;*.control_files=&#x27;/u01/oracle/app/oradata/std/control01.ctl&#x27;,&#x27;/u01/oracle/app/fast_recovery_area/std/control02.ctl&#x27;*.db_block_size=8192*.db_domain=&#x27;&#x27;*.db_name=&#x27;orcl&#x27;*.db_recovery_file_dest=&#x27;/u01/oracle/app/fast_recovery_area&#x27;*.db_recovery_file_dest_size=5218762752*.diagnostic_dest=&#x27;/u01/oracle/app&#x27;*.dispatchers=&#x27;(PROTOCOL=TCP) (SERVICE=stdXDB)&#x27;*.open_cursors=300*.pga_aggregate_target=824180736*.processes=150*.remote_login_passwordfile=&#x27;EXCLUSIVE&#x27;*.sga_target=2474639360*.undo_tablespace=&#x27;UNDOTBS1&#x27;*.db_unique_name=&#x27;std&#x27;*.log_archive_config=&#x27;dg_config=(orcl,std)&#x27;*.log_archive_dest_1=&#x27;LOCATION=/u01/oracle/app/arch valid_for=(all_logfiles,primary_role) db_unique_name=std&#x27;*.log_archive_dest_2=&#x27;SERVICE=orcl valid_for=(online_logfile,primary_role) db_unique_name=orcl&#x27;*.log_archive_dest_state_1=enable*.log_archive_dest_state_2=enable*.log_archive_max_processes=4*.fal_server=&#x27;orcl&#x27;*.fal_client=&#x27;std&#x27;*.db_file_name_convert=&#x27;/u01/oracle/app/oradata/orcl&#x27;,&#x27;/u01/oracle/app/oradata/std&#x27;*.log_file_name_convert=&#x27;/u01/oracle/app/oradata/orcl&#x27;,&#x27;/u01/oracle/app/oradata/std&#x27;*.standby_file_management=&#x27;auto&#x27;\n创建缺少的文件目录\nmkdir -pv /u01/oracle/app/admin/std/adumpmkdir -pv /u01/oracle/app/oradata/stdmkdir -pv /u01/oracle/app/fast_recovery_areamkdir -pv /u01/oracle/app/fast_recovery_area/stdmkdir -pv /u01/oracle/app/archmkdir -pv /u01/oracle/app/diag/rdbms/std/std/tracemkdir -pv /u01/oracle/app/oradata/standbylog[oracle@ora11g-2 ~]$ cd ~[oracle@ora11g-2 ~]$ nano .bash_profileexport ORACLE_SID=std exitsu - oracle\n\n用修改后的pfile创建一个spfile,用于启动数据库（备库端做）:\nSQL&gt; sqlplus / as sysdbaSQL&gt; create spfile from pfile;File created.SQL&gt; startup nomount;\n利用RMAN在备库上恢复主库（备库做）:\n[oracle@ora11g-2 ~]$ rman target sys/oracle@orcl_DGMGR auxiliary sys/oracle@std_DGMGRRecovery Manager: Release 11.2.0.4.0 - Production on Wed Jul 6 17:32:26 2022Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.connected to target database: ORCL (DBID=1637071856)connected to auxiliary database: STD (not mounted)RMAN&gt; duplicate target database for standby from active database nofilenamecheck;RMAN&gt; exit------------------------------SQL&gt; sqlplus / as sysdbaSQL&gt; alter database recover managed standby database disconnect from session;SQL&gt; select sequence#,applied from v$archived_log order by 1;#如果有发现NO的，也是正常的，说明该日志在主库上还没有归档，可以在主库上运行以下命令来进行日志切换，再到备库查看日志应用情况。#主库运行操作SQL&gt; alter system switch logfile;SQL&gt; archive log list;-----------------------##如果发现不能同步，在备库端进行以下操作：SQL&gt; alter database recover managed standby database cancel;SQL&gt; shu immediate;SQL&gt; startup nomount;SQL&gt; alter database mount standby database;SQL&gt; alter database open read only;SQL&gt; alter database recover managed standby database using current logfile disconnect from session;------------------------#主库操作#启动brokenSQL&gt; alter system set dg_broker_start=true;System altered.#开启闪回SQL&gt; alter database flashback on;System altered.SQL&gt; select open_mode,database_role,log_mode,flashback_on from v$database;OPEN_MODE\t     DATABASE_ROLE    LOG_MODE\t   FLASHBACK_ON-------------------- ---------------- ------------ ------------------READ WRITE\t     PRIMARY\t      ARCHIVELOG   YES------------#备库操作SQL&gt; alter system set dg_broker_start=true;System altered.SQL&gt; select database_role from v$database;DATABASE_ROLE----------------PHYSICAL STANDBYSQL&gt; recover managed standby database cancel;Media recovery complete.SQL&gt; alter database flashback on;Database altered.SQL&gt; recover managed standby database using current logfile disconnect;Media recovery complete.SQL&gt; select open_mode,database_role,log_mode,flashback_on from v$database;#备库执行实施同步语句SQL&gt; alter database recover managed standby database using current logfile disconnect from session;Database altered.\n\n创建DGMGRL配置文件主库操作[oracle@ora11g-1 dbs]$ dgmgrl sys/oracle@orcl_dgmgrDGMGRL for Linux: Version 11.2.0.4.0 - 64bit ProductionCopyright (c) 2000, 2009, Oracle. All rights reserved.Welcome to DGMGRL, type &quot;help&quot; for information.Connected.----------------------DGMGRL&gt; create configuration dg as primary database is orcl connect identifier is orcl_dgmgr;Configuration &quot;dg&quot; created with primary database &quot;orcl&quot;----------------------DGMGRL&gt; show configuration;Configuration - dg  Protection Mode: MaxPerformance  Databases:    orcl - Primary databaseFast-Start Failover: DISABLEDConfiguration Status:DISABLED----------------------DGMGRL&gt; add database std as connect identifier is std_dgmgr maintained as physical;Database &quot;std&quot; added----------------------DGMGRL&gt; show configuration;Configuration - dg  Protection Mode: MaxPerformance  Databases:    orcl - Primary database    std  - Physical standby databaseFast-Start Failover: DISABLEDConfiguration Status:DISABLED----------------------DGMGRL&gt; enable configuration;Enabled.----------------------DGMGRL&gt; show configuration;Configuration - dg  Protection Mode: MaxPerformance  Databases:    orcl - Primary database    std  - Physical standby databaseFast-Start Failover: DISABLEDConfiguration Status:SUCCESS\n\n主或者备库操作[oracle@ora11g-2 dbs]$ dgmgrl sys/oracle &quot;start observer&quot; &amp;[1] 38210[oracle@ora11g-2 dbs]$ DGMGRL for Linux: Version 11.2.0.4.0 - 64bit ProductionCopyright (c) 2000, 2009, Oracle. All rights reserved.Welcome to DGMGRL, type &quot;help&quot; for information.Connected.Observer started\n\n主库操作DGMGRL&gt; ENABLE FAST_START FAILOVER;Enabled.----------------------DGMGRL&gt; show configuration;DGMGRL&gt; show database verbose &#x27;orcl&#x27;;DGMGRL&gt; show database verbose &#x27;std&#x27;;\n手动切换到备库测试：DGMGRL&gt; switchover to &#x27;std&#x27;Performing switchover NOW, please wait...Operation requires a connection to instance &quot;std&quot; on database &quot;std&quot;Connecting to instance &quot;std&quot;...Connected.New primary database &quot;std&quot; is opening...Operation requires startup of instance &quot;orcl&quot; on database &quot;orcl&quot;Starting instance &quot;orcl&quot;...ORACLE instance started.Database mounted.Database opened.Switchover succeeded, new primary is &quot;std&quot;------------------------------DGMGRL&gt; switchover to &#x27;orcl&#x27;Performing switchover NOW, please wait...Operation requires a connection to instance &quot;orcl&quot; on database &quot;orcl&quot;Connecting to instance &quot;orcl&quot;...Connected.New primary database &quot;orcl&quot; is opening...Operation requires startup of instance &quot;std&quot; on database &quot;std&quot;Starting instance &quot;std&quot;...ORACLE instance started.Database mounted.Database opened.Switchover succeeded, new primary is &quot;orcl&quot;\n\n自动切换功能begin    DBMS_SERVICE.CREATE_SERVICE (    service_name =&gt; &#x27;HAHA&#x27;,    network_name =&gt; &#x27;HAHA&#x27;,    aq_ha_notifications =&gt; TRUE,    failover_method =&gt; &#x27;BASIC&#x27;,    failover_type =&gt; &#x27;SELECT&#x27;,    failover_retries =&gt; 30,    failover_delay =&gt; 5);end;create or replace procedure cmc_taf_service_procis      v_role VARCHAR(30);begin     select DATABASE_ROLE into v_role from V$DATABASE;     if v_role = &#x27;PRIMARY&#x27; then         DBMS_SERVICE.START_SERVICE(&#x27;HAHA&#x27;);     else         DBMS_SERVICE.STOP_SERVICE(&#x27;HAHA&#x27;);     end if; end;create or replace TRIGGER cmc_taf_service_trg_startupafter startup on databasebegin    cmc_taf_service_proc;end;create or replace TRIGGER cmc_taf_service_trg_rolechangeafter db_role_change on databasebegin    cmc_taf_service_proc;end;SQL&gt; exec cmc_taf_service_proc;SQL&gt; alter system archive log current;\n\n\n遇到的问题（ORA-16829: fast-start failover configuration is lagging）解决方式：1.关闭fast_start failoverDGMGRL&gt; DISABLE FAST_START FAILOVER;Disabled.2.备库重启SQL&gt; shutdown abortORACLE instance shut down.SQL&gt; startupORACLE instance started.3.备库执行实施同步语句SQL&gt; alter database recover managed standby database using current logfile disconnect from session;Database altered.4.过一段时间再检查备库状态，发现恢复正常DGMGRL&gt; show database orclDatabase - orcl  Role:            PHYSICAL STANDBY  Intended State:  APPLY-ON  Transport Lag:   0 seconds (computed 1 second ago)  Apply Lag:       0 seconds (computed 1 second ago)  Apply Rate:      0 Byte/s  Real Time Query: ON  Instance(s):    orcl但是接着又出现apply lagDGMGRL&gt; show database orclDatabase - orcl  Role:            PHYSICAL STANDBY  Intended State:  APPLY-ON  Transport Lag:   0 seconds (computed 0 seconds ago)  Apply Lag:       2 minutes 37 seconds (computed 0 seconds ago)  Apply Rate:      0 Byte/s  Real Time Query: ON  Instance(s):    orcl5.将DelayMins设置0DGMGRL&gt; edit database orcl set property DelayMins=0;Property &quot;delaymins&quot; updatedDGMGRL&gt; edit database std set property DelayMins=0;Property &quot;delaymins&quot; updated继续不断检查dg的状态DGMGRL&gt; show database orclDatabase - orcl  Role:            PHYSICAL STANDBY  Intended State:  APPLY-ON  Transport Lag:   0 seconds (computed 0 seconds ago)  Apply Lag:       0 seconds (computed 0 seconds ago)  Apply Rate:      0 Byte/s  Real Time Query: ON  Instance(s):    orclDatabase Status:SUCCESS6.重新开启fast_start failoverDGMGRL&gt; enable fast_start failoverEnabled.DGMGRL&gt; show configurationConfiguration - orcl  Protection Mode: MaxPerformance  Databases:    orcl - Primary database      Warning: ORA-16819: fast-start failover observer not started    dg   - (*) Physical standby database      Warning: ORA-16819: fast-start failover observer not startedFast-Start Failover: ENABLEDConfiguration Status:WARNING这时发现ORA-16829错误已经消失6.备库执行取消同步语句，全部使用DGMGRL工具管理SQL&gt; alter database recover managed standby database cancel;Database altered.取消后发现错误再次出现DGMGRL&gt; show database dg;Database - dg  Role:            PHYSICAL STANDBY  Intended State:  APPLY-ON  Transport Lag:   0 seconds (computed 0 seconds ago)  Apply Lag:       0 seconds (computed 0 seconds ago)  Apply Rate:      (unknown)  Real Time Query: OFF  Instance(s):    dg  Database Error(s):    ORA-16766: Redo Apply is stopped  Database Warning(s):    ORA-16829: fast-start failover configuration is lagging    ORA-16819: fast-start failover observer not startedDatabase Status:ERROR7.对备库使用DGMGRL重启APLLYDGMGRL&gt; edit database orcl set state=&quot;APPLY-OFF&quot;;Succeeded.DGMGRL&gt; edit database orcl set state=&quot;APPLY-ON&quot;;Succeeded.最后发现一切正常DGMGRL&gt; show database orcl;Database - orcl  Role:            PHYSICAL STANDBY  Intended State:  APPLY-ON  Transport Lag:   0 seconds (computed 1 second ago)  Apply Lag:       0 seconds (computed 1 second ago)  Apply Rate:      0 Byte/s  Real Time Query: ON  Instance(s):    orcl  Database Warning(s):    ORA-16819: fast-start failover observer not startedDatabase Status:WARNING\n\n错误总结：在使用了DGMGRL来管理Dataguard时，就千万不要再使用SQLPLUS命令行来管理了，所有的操作必须都要在DGMGRL下进行修改配置，否则会造成参数冲突，导致问题排查困难，造成不必要的劳动\n\nDG启停维护\n启动顺序：先启动备库，后启动主库关闭顺序：先关闭主库，后关闭备库\n\n1.正确关闭备库和主库#主库SQL&gt;SHUTDOWN IMMEDIATE;#备库:SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;SQL&gt;SHUTDOWN IMMEDIATE;\n\n2.正确打开备库和主库#备库:--先启备库sql&gt;startup nomountsql&gt;alter database mount standby database;sql&gt;alter database open;sql&gt;alter database recover managed standby database using current logfile disconnect from session;#主库:SQL&gt; STARTUP;\n\n快速关库\nshutdown abort\n","categories":["技术"],"tags":["技术","linux","oracle","心得","dg"]},{"title":"Oracle日常维护语句","url":"/2020/01/06/oracle%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E8%AF%AD%E5%8F%A5/","content":"常用语句数据库启停监听启停su - oracle--查看监听器命令lsnrctl status--监听器启动lsnrctl start --监听器停⽌lsnrctl stop  \n\n\n库启停sqlplus / as sysdba#启动库SQL&gt;startup#关闭库SQL&gt;shutdown immediate\n\noracle查看实例名select name,dbid from v$database;--或者show parameter db_name;--查看 pfile 文件位置show parameter pfile;\n\n查看 oracle版本SQL&gt; select * from v$version;\n\n查询内存分配情况SQL&gt; select * from v$sga;\n\n查看并发连接数SQL&gt; select count(*) from v$session where status=&#x27;ACTIVE&#x27;;\n\n日志文件SQL&gt; select * from v$logfile;\n\n\n\n查看控制文件SQL&gt; select name from v$controlfile;\n\n\n\n查看、管理 ORACLE 表查看所有 segment 的大小Select Segment_Name,Sum(bytes)/1024/1024 From User_Extents Group By Segment_Name;\n\n查询用户下的表SELECT table_name FROM  all_tables;\n\n查看某个表属于哪个表空间SQL&gt; select tablespace_name from all_tables where table_name=&#x27;SYS_EXPORT_FULL_01&#x27;;\n\n创建表时指定表空间SQL&gt;create table a (name varchar(10)) tablespace test;\n\n查看数据库表结构SQL&gt; desc 表名;\n\n查看表的索引SQL&gt;select index_name,index_type,table_name from user_indexes where table_name=&#x27;表名&#x27;;\n\n查看用户序列SQL&gt; select sequence_name from USER_SEQUENCES;\n\n查看用户触发器SQL&gt; select * from user_triggers where table_name = upper(&#x27;job&#x27;);--通过group by 语句使用rollup运算符汇总ID列SQL&gt; select ID,avg(age),sum(age),max(age),count(*)2 from job group by rollup(ID);\n\n修改表的列名SQL&gt; alter table 表名 rename column 列名 to 新列名;\n\n修改表的列的字符大小SQL&gt; alter table student modify class varchar2(10);\n\n创建主键SQL&gt; alter table 表名 add constraint 主键名 primary key(列名);\n\n\n查询表空间使用情况表空间总体情况SELECT UPPER(F.TABLESPACE_NAME) &quot;表空间名&quot;,　　D.TOT_GROOTTE_MB &quot;表空间大小(G)&quot;,　　D.TOT_GROOTTE_MB - F.TOTAL_BYTES &quot;已使用空间(G)&quot;,　　--TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),&#x27;990.99&#x27;) || &#x27;%&#x27; &quot;使用比&quot;,    TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2)) || &#x27;%&#x27; &quot;使用比&quot;,　　F.TOTAL_BYTES &quot;空闲空间(G)&quot;,　　F.MAX_BYTES &quot;最大块(G)&quot;    --,E.file_name &quot;存储位置&quot;　　FROM (SELECT TABLESPACE_NAME,　　ROUND(SUM(BYTES) / (1024 * 1024 * 1024), 2) TOTAL_BYTES,　　ROUND(MAX(BYTES) / (1024 * 1024 * 1024), 2) MAX_BYTES　　FROM SYS.DBA_FREE_SPACE　　GROUP BY TABLESPACE_NAME) F,　　(SELECT DD.TABLESPACE_NAME,　　 ROUND(SUM(DD.BYTES) / (1024 * 1024 * 1024), 2) TOT_GROOTTE_MB　　FROM SYS.DBA_DATA_FILES DD　　GROUP BY DD.TABLESPACE_NAME) D,    SYS.DBA_DATA_FILES E　　WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME　　ORDER BY 1;\n\n查询表空间的总容量select tablespace_name, sum(bytes) / 1024 / 1024 /1024 as &quot;大小（GB）&quot;　　from dba_data_files　　group by tablespace_name;\n\n查询表空间使用率select total.tablespace_name,　　round(total.MB, 2) as Total_MB,　　round(total.MB - free.MB, 2) as Used_MB,　　round((1 - free.MB / total.MB) * 100, 2) || &#x27;%&#x27; as Used_Pct　　from (select tablespace_name, sum(bytes) / 1024 / 1024 as MB　　from dba_free_space　　group by tablespace_name) free,　　(select tablespace_name, sum(bytes) / 1024 / 1024 as MB　　from dba_data_files　　group by tablespace_name) total　　where free.tablespace_name = total.tablespace_name;\n\n监控当前数据库谁在运行什么SQL语句select osuser, username, sql_text  from  v$session a, v$sqltext b where  a.sql_address =b.address order by address, piece;\n\n找使用CPU多的用户sessionselect a.sid,spid,status,substr(a.program,1,40) prog, a.terminal,osuser,value/60/100 value from  v$session a,v$process b,v$sesstat c where  c.statistic#=12 and         c.sid=a.sid and         a.paddr=b.addr         order by value desc;\n\n\n\n\n\n等待最多的用户SELECT   s.SID, s.username, SUM (a.wait_time + a.time_waited) total_wait_time    FROM v$active_session_history a, v$session s   WHERE a.sample_time BETWEEN SYSDATE - 30 / 2880    AND SYSDATEGROUP BY s.SID, s.usernameORDER BY total_wait_time DESC;\n\n等待最多的SQLSELECT   a.program, a.session_id, a.user_id, d.username, s.sql_text,         SUM (a.wait_time + a.time_waited) total_wait_time    FROM v$active_session_history a, v$sqlarea s, dba_users d   WHERE a.sample_time BETWEEN SYSDATE - 30 / 2880 AND SYSDATE     AND a.sql_id = s.sql_id     AND a.user_id = d.user_idGROUP BY a.program, a.session_id, a.user_id, s.sql_text, d.username;\n\n查看消耗资源最多的SQLSELECT hash_value, executions, buffer_gets, disk_reads, parse_callsFROM V$SQLAREAWHERE buffer_gets &gt; 10000000 OR disk_reads &gt; 1000000ORDER BY buffer_gets + 100 * disk_reads DESC;\n\n查看某条SQL语句的资源消耗查看某条SQL语句的资源消耗SELECT hash_value, buffer_gets, disk_reads, executions, parse_callsFROM V$SQLAREAWHERE hash_Value = 228801498 AND address = hextoraw(&#x27;CBD8E4B0&#x27;);\n\n查询会话执行的实际SQLSELECT   a.SID, a.username, s.sql_text    FROM v$session a, v$sqltext s   WHERE a.sql_address = s.address     AND a.sql_hash_value = s.hash_value     AND a.status = &#x27;ACTIVE&#x27;ORDER BY a.username, a.SID, s.piece;\n\n查看死锁信息SELECT (SELECT username          FROM v$session         WHERE SID = a.SID) blocker, a.SID, &#x27;is blocking&#x27;,       (SELECT username          FROM v$session         WHERE SID = b.SID) blockee, b.SID  FROM v$lock a, v$lock b WHERE a.BLOCK = 1 AND b.request &gt; 0 AND a.id1 = b.id1 AND a.id2 = b.id2;\n\n显示正在等待锁的所有会话SELECT * FROM DBA_WAITERS;\n\noracle配置查询select SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;TERMINAL&#x27;) terminal, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;LANGUAGE&#x27;) language, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;SESSIONID&#x27;) sessionid, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;INSTANCE&#x27;) instance, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;ENTRYID&#x27;) entryid, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;ISDBA&#x27;) isdba, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_TERRITORY&#x27;) nls_territory, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_CURRENCY&#x27;) nls_currency, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_CALENDAR&#x27;) nls_calendar, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_DATE_FORMAT&#x27;) nls_date_format, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_DATE_LANGUAGE&#x27;) nls_date_language, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NLS_SORT&#x27;) nls_sort, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;CURRENT_USER&#x27;) current_user, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;CURRENT_USERID&#x27;) current_userid, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;SESSION_USER&#x27;) session_user, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;SESSION_USERID&#x27;) session_userid, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;PROXY_USER&#x27;) proxy_user, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;PROXY_USERID&#x27;) proxy_userid, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;DB_DOMAIN&#x27;) db_domain, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;DB_NAME&#x27;) db_name, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;HOST&#x27;) host, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;OS_USER&#x27;) os_user, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;EXTERNAL_NAME&#x27;) external_name, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;IP_ADDRESS&#x27;) ip_address, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;NETWORK_PROTOCOL&#x27;) network_protocol, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;BG_JOB_ID&#x27;) bg_job_id, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;FG_JOB_ID&#x27;) fg_job_id, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;AUTHENTICATION_TYPE&#x27;) authentication_type, SYS_CONTEXT(&#x27;USERENV&#x27;,&#x27;AUTHENTICATION_DATA&#x27;) authentication_data from dual;\n\n\n切换字符集#查看oracle数据库的字符集SQL&gt; select userenv(&#x27;language&#x27;) from dual;\n\n查看oracle数据库的编码SQL&gt; select * from nls_database_parameters where parameter =&#x27;NLS_CHARACTERSET&#x27;;[oracledb@ ~]$ set NLS_LANG=AMERICAN_AMERICA.AL32UTF8     #windows_os[oracledb@ ~]$ export NLS_LANG=AMERICAN_AMERICA.AL32UTF8  #linux_os\n\n查询当前oracle的并发连接数SQL&gt; select count(*) from v$session where status=&#x27;ACTIVE&#x27;;\n\n查看不同用户的连接数：SQL&gt; select username,count(username) from v$session where username is not null group by username;\n\n查看所有用户：select * from all_users;\n\n当前的连接数select count(*) from v$process;\n\n查询当前连接会话数select s.value,s.sid,a.usernamefrom v$sesstat S,v$statname N,v$session Awhere n.statistic#=s.statistic# andname=&#x27;session pga memory&#x27;and s.sid=a.sidorder by s.value;\n\n清除用户下连接进程SQL&gt; alter system kill session &#x27;204,4609&#x27;;SQL&gt; alter system kill session &#x27;399,5841&#x27;;SQL&gt; alter system kill session &#x27;590,6041&#x27;;修改processes和sessions值　　SQL&gt; alter system set processes=300 scope=spfile;　　系统已更改。　　SQL&gt; alter system set sessions=335 scope=spfile;　　系统已更改。\n\n\n\n修改processes和sessions值必须重启oracle服务器才能生效ORACLE的连接数(sessions)与其参数文件中的进程数(process)有关，它们的关系如下：　　sessions&#x3D;(1.1*process+5)\n　　\n\n数据库允许的最大连接数select value from v$parameter where name = &#x27;processes&#x27;;\n\n\n查看数据库现有模式、是否归档SQl&gt;select name,log_mode from v$database;\n\n\n也可以用下面的语句\narchive log list；--(该方法需要as sysdba)\n\n\n查看数据库的创建日期和归档方式\nSQL&gt; Select Created, Log_Mode, Log_Mode From V$Database;\n\n配置用户密码过期时间alter profile &quot;default&quot; limit password_life_time unlimited; --配置用户密码永不过期alter profile &quot;default&quot; limit password_life_time 100; --配置用户密码100天过期\n\n\nexpdp与impdp整库导出命令exp system/itcast full=y 或者 exp system/itcast file=文件名 full=y\n\n\n整库导入命令imp system/itcast full=y or imp system/itcast full=y file=water.dmp\n\n\n\n按用户导出与导入按用户导出exp system/itcast owner=wateruser file=wateruser.dmp\n\n\n按用户导入imp system/itcast file=wateruser.dmp fromuser=wateruser\n\n\n按表导出与导入按表导出exp wateruser/itcast file=a.dmp tables=t_account,a_area\n\n按表导入imp wateruser/itcast file=a.dmp tables=t_account,a_are\n\n\n如何正确终止expdp与impdp任务，操作步骤如下：步骤1查看视图dba_datapump_jobs\nselect job_name,state from dba_datapump_jobs;\n\n步骤2正确停止expdp导出任务使用stop_job\nexpdp USERNAME/USERPASSWORD@SIDNAME attach=SYS_EXPORT_SCHEMA_02\n\n步骤3停止任务\nExport&gt; stop_job=immediate Are you sure you wish to stop this job ([yes]/no): yes\n\n步骤4查看系统中的备份job状态\nselect owner_name,job_name ,state from dba_datapump_jobs;\n\n\n#扩展：下列命令在交互模式下有效：HELP： 总结交互命令。KILL_JOB： 分离和删除作业。PARALLEL： 更改当前作业的活动 worker 的数目。PARALLEL=.2START_JOB： 启动/恢复当前作业。START_JOB=SKIP_CURRENT 在开始作业之前将跳过作业停止时执行的任意操作。STATUS ：在默认值（0）将显示可用时的新状态的情况下，要监视的频率（以秒计）作业状态。STATUS[=interval]STOP_JOB： 顺序关闭执行的作业并退出客户机。STOP_JOB=IMMEDIATE 将立即关闭数据泵作业。\n\n创建、管理 Oracle 表空间先查询空闲空间select tablespace_name,file_id,block_id,bytes,blocks from dba_free_space;\n\n增加 Oracle 表空间--先查询数据文件名称、大小和路径的信息，语句如下：select tablespace_name,file_id,bytes,file_name from dba_data_files;--修改文件大小语句如下alter database datafile&#x27;需要增加的数据文件路径，即上面查询出来的路径&#x27;resize 800M;\n\n\n创建 Oracle 表空间create tablespace testdatafile &#x27;/home/app/oracle/oradata/oracle8i/test01.dbf&#x27; size 8Mautoextend onnext 5Mmaxsize 10M;create tablespace salesdatafile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize unlimitedmaxsize unlimited 是大小不受限制create tablespace salesdatafile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize 1000Mextent management local uniform;unform表示区的大小相同，默认为1Mcreate tablespace salesdatafile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize 1000Mextent management local uniform size 500K;unform size 500K表示区的大小相同，为500Kcreate tablespace salesdatafile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize 1000Mextent management local autoallocate;--autoallocate表示区的大小由随表的大小自动动态改变，大表使用大区小表使用小区create tablespace salesdatafile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize 1000Mtemporary;--temporary创建字典管理临时表空间 ，要创建本地管理临时表空间要加temporary tablespace关键字create temporary tablespace salestempfile &#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27; size 800Mautoextend onnext 50Mmaxsize 1000M--创建本地管理临时表空间，如果是临时表空间，所有语句中的datafile都换为tempfile ，所有语句中的datafile都换为tempfile8i--为表空间增加数据文件：alter tablespace sales adddatafile &#x27;/home/app/oracle/oradata/oracle8i/sales02.dbf&#x27; size 800Mautoextend on next 50Mmaxsize 1000M; \n\n查看表空间是否自动扩展SQL&gt; select file_id,file_name,tablespace_name,autoextensible,increment_by from dba_data_files order by file_id desc;\n\n更改自动扩展属性：alter database datafile&#x27;/home/app/oracle/oradata/oracle8i/sales01.dbf&#x27;,&#x27;/home/app/oracle/oradata/oracle8i/sales02.dbf&#x27;&#x27;/home/app/oracle/oradata/oracle8i/sales01.dbfautoextend off\n\n\n表空间的查看与修改查看用户默认表空间SQL&gt; select username,default_tablespace from dba_users;查看所有用户的默认表空间SQL&gt; select username,default_tablespace from user_users;查看某个用户的默认表空间，前提需要connect该用户。\n\n\n\nSQL&gt; select USERNAME,DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE from dba_users where username = &#x27;hr&#x27;; 查看用户对应的默认表空间\n\n\n修改用户默认表空间SQL&gt; alter user zhanghr default tablespace test;\n\n\n设置数据库的默认临时表空间SQL&gt;Alter database default temporary tablespace temp_tbs_name;\n查看用户和默认表空间的关系SQL&gt;select username,default_tablespace from dba_users;\n\n\n查看临时表空间SQL&gt; select file_name,file_id,blocks,user_blocks from dba_temp_files；SQL&gt; select tablespace_name,current_users,total_blocks,used_blocks,free_blocks from v$sort_segment;\n\n\n查看 undo 表空间SQL&gt; show parameter undo;NAME TYPE VALUE------------------------------------ ----------- ------------------------------undo_management string AUTOundo_retention integer 900undo_tablespace string UNDOTBS1\n\n查看 undo 表空间大小SQL&gt; select sum(bytes)/1024/1024 &quot;current undo size(M)&quot; from dba_data_files where tablespace_name=&#x27;UNDOTBS1&#x27;;\n\n\n通过增加数据文件来改变 undo 表空间大小SQL&gt; alter tablespace undotbs1add datafile &#x27;/oracle/oradata/orc6/undo02.dbf&#x27; size 10M;复制代码2.6.10 通过 resize 更改数据文件大小SQL&gt; alter database datafile &#x27;/oracle/oradata/orc6/undo02.dbf&#x27; resize 100M;\n\n\n查看某个表空间的数据文件SQL&gt; select file_name,tablespace_name,bytes/1024/1024 &quot;bytes MB&quot;,maxbytes/1024/1024 &quot;maxbytes MB&quot; from dba_data_files where tablespace_name=&#x27;ORA1TBS&#x27;;指定表空间名要大写\n\n\n查看所有表空间大小SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_data_filesgroup by tablespace_name;\n\n\n查看已使用的表空间大小SQL&gt; select tablespace_name,sum(bytes)/1024/1024 from dba_free_spacegroup by tablespace_name;\n\n清理（还原时出错，清用户表空间）1、删除数据表空间：#执行语句：[oracledb@ ~]$ sqlplus / as sysdbaSQL&gt; drop tablespace mepro_data including contents and datafiles cascade constraint;\n\n2、删除临时表空间：#执行语句：SQL&gt; drop tablespace mepro_temp including contents and datafiles cascade constraints;\n\n3、删除用户：#执行语句：SQL&gt; drop user srmhdld cascade;\n\n4、报用户正在连接，无法删除的解决方法---方法1：重启并迅速执行drop user语句（个人推荐）SQL&gt; shutdown immediate;SQL&gt; startup--方法2：删除正在连接的session（连接的session连接着很多时，清理耗时，没有方法1快速）#查询用户会话SQL&gt; select username,serial#,sid,program,machine,status from v$session where username=&#x27;USERNAME&#x27; AND STATUS=&#x27;ACTIVE&#x27;;SQL&gt; select saddr,sid,serial#,paddr,username,status from v$session where username is not null;---删除相关用户会话SQL&gt; alter system kill session &#x27;serial#, sid&#x27;;\n\n查看、管理 ORACLE 数据文件查看数据文件SQL&gt; select name from v$datafile;\n\n更改数据文件大小SQL&gt; alter database datafile &#x27;/oradata2/hisvhfs/undotbs01.dbf&#x27; resize 30G;\n\n\n查看用户所有表空间及对应的数据文件和数据文件大小SQL&gt; select tablespace_name, file_id, file_name, round(bytes/(1024*1024),0) total_space from dba_data_files order by tablespace_name;\n\n\n查看数据文件状态及大小SQL&gt; select name,BYTES,STATUS ,FILE# from v$datafile;\n\n\n创建、配置新用户及查看用户属性解锁新用户：SQL&gt; alter user scott account unlock；SQL&gt; alter user scott identified by tiger;\n\n\n删除oracle用户：SQL&gt;drop user username cascade; (删除与用户相关的所有对象)\n\n\n这样该用户包括该用户下的表，试图，同义词，过程，索引，及相关的一切就删除了。\n创建用户并赋权限以及设置默认表空间。\n以sysdba用户登陆进行以下设置：\n-- Create the usercreate user VHFSMidentified by vhnj1fsmdefault tablespace MGRVHFSTBSDEF 此处是设置默认表空间。temporary tablespace TEMPprofile DEFAULTquota unlimited on mgrvhfstbs2010 此处是设置可操作的其他表空间quota unlimited on mgrvhfstbsdef;-- Grant/Revoke role privilegesgrant connect to VHFSM;grant dba to VHFSM;-- Grant/Revoke system privilegesgrant unlimited tablespace to VHFSM;\n\n\n查看用户及角色权限\n1.查看所有用户：select * from dba_users;select * from all_users;select * from user_users;\n\n\n2.查看用户或角色系统权限(直接赋值给用户或角色的系统权限)：select * from dba_sys_privs;select * from user_sys_privs;\n\n\n3.查看角色(只能查看登陆用户拥有的角色)所包含的权限sql&gt;select * from role_sys_privs;\n\n\n4.查看用户对象权限：select * from dba_tab_privs;select * from all_tab_privs;select * from user_tab_privs;\n\n\n5.查看所有角色：select * from dba_roles;\n\n\n6.查看用户或角色所拥有的角色：select * from dba_role_privs;select * from user_role_privs;\n\n\n7.查看哪些用户有sysdba或sysoper系统权限(查询时需要相应权限)select * from V$PWFILE_USERS--注意：--1、以下语句可以查看Oracle提供的系统权限select name from sys.system_privilege_map--2、查看一个用户的所有系统权限(包含角色的系统权限)SELECT privilegeFROM dba_sys_privsWHERE grantee = &#x27;DATAUSER&#x27;UNIONSELECT privilegeFROM dba_sys_privsWHERE grantee IN (SELECT granted_role FROM dba_role_privs WHERE grantee = &#x27;DATAUSER&#x27;);\n\n数据库游标设置SQL&gt; show parameter open_cursors; 查看游标参数SQL&gt; select count(*) from v$open_cursor; 查看打开的游标SQL&gt; select name,value from v$sysstat where name =&#x27;opened cursors current&#x27;;查看当前打开的游标SQL&gt; alter system set open_cursors=3000 scope=both; 修改默认游标数\n\n\n查看、配置 ORACLE 重做日志创建日志文件组SQL&gt; alter database add logfile group 4(&#x27;/oracle/oradata/orc6/redo04.log&#x27;)size 10M;\n\n查看日志文件组SQL&gt; select group#,status,member from v$logfile;\n\n\n为日志文件组增加日志文件SQL&gt; alter database add logfile member &#x27;/oracle/oradata/orc6/redo05.log&#x27; to group 3;\n\n\n查看日志文件大小SQL&gt; select GROUP#,BYTES,BLOCKSIZE,MEMBERS from v$log;\n\n\n\ndesc 的常用查询SQL&gt; desc dba_temp_files; 查询临时表空间SQL&gt; desc v$database; 查看数据库SQL&gt; desc dba_data_files; 查看数据文件SQL&gt; desc user_segments; 查看oracle segment（段）SQL&gt; desc dba_segments; 查看ORACLE segmentSQL&gt; desc dba_tables; 查看表SQL&gt; desc dba_objects 查看对象SQL&gt; desc dba_users; 查看用户SQL&gt; desc dba_tablespaces; 查看表空间SQL&gt; desc user_segments; 查看数据段SQL&gt; desc dba_jobs； 查看jobSQL&gt; desc dba_role_privs； 查看角色权限SQL&gt; desc dba_constraints 查看约束SQL&gt; desc dba_cons_columns 查看列约束SQL&gt; show parameter log_archive_dest; 查看archive log所在位置SQL&gt; archive log list; 查看归档目录以及log sequenceSQL&gt; select * from V$FLASH_RECOVERY_AREA_USAGE; 查看flash_recovery_area 使用情况。SQL&gt; select sum(percent_space_used)*3/100 from v$flash_recovery_area_usage; 计算flash_recovery_area已经占用的空间。SQL&gt; show parameter recover; 查找recovery目录SQL&gt; desc v$process 通过v$process视图，我们获的是当前系统中所有进程信息，包括“后台进程”，也包括“服务器进程”。SQL&gt; select addr, program from v$process;SQL&gt; desc v$bgprocess 通过v$bgprocess视图,我们获得当前系统中启动的Oracle“后台进程”信息SQL&gt; select paddr, name from v$bgprocess where paddr&lt;&gt;&#x27;00&#x27;;通过v$bgprocess.paddr与v$process.addr关联起来的，关联后查询结果显而易见只会有Oracle“后台进程”的信息SQL&gt; select a.paddr, a.name, a.description from v$bgprocess a, v$process b where a.paddr=b.addr;\n\n查看 ASM 磁盘组信息SQL&gt; desc v$asm_disk；SQL&gt; desc v$asm_diskgroup;\n\n\n\n扩展知识1）扩展1：情况1、高版本往低版本导出还原时，如12往11还原时，在12c执行导出时，添加低版本的版本号version&#x3D;11.1.0.2.0\n#格式：[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME dumpfile=XXX.dmp DIRECTORY=dir_dump version=11.1.0.2.0\n\n情况2、低版本往高版本还原时，高版本一般兼容低版本，目前个人运维工作中11往12还原没遇到什么问题。\n2）扩展2：（1）、按指定大小备份，如每份5G大小（parallel是多线程处理，线程数要小于生成文件个数，线程要小于 cpu 线程数）\n#备份格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX_%U.dmp logfile=expdpXXX.log filesize=5G parallel=16\n\n（2）、多个备份文件还原：\n#还原格式[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX_%U.dmp logfile=impdpXXX.log parallel=16\n\n3）扩展3导出过滤不导出某张表：#格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp  exclude=TABLE:\\&quot;IN \\&#x27;TABLENAME\\&#x27;\\&quot;\n\n4）扩展4不同库还原时不改变数据结构使用truncate参数：#格式[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp remap_schema=源SCHEMASNAME:目标SCHEMASNAME remap_tablespace=源_data:目标_data TABLE_EXISTS_ACTION=truncate\n\n5）扩展5导出备份时保留表，清除表数据(query参数)：#格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp logfile=expdpXXX.log  query=TABLENAME1:&#x27;&quot; where 1=2&quot;&#x27;,TABLENAME2:&#x27;&quot; where 1=2&quot;&#x27;,........\n\n6）扩展6导出备份时保留表，清除表数据，同时过滤某两张表#格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp logfile=expdpXXX.log  query=TABLENAME1:&#x27;&quot; where 1=2&quot;&#x27;,TABLENAME2:&#x27;&quot; where 1=2&quot;&#x27; exclude=TABLE:\\&quot;IN \\&#x27;TABLENAME1\\&#x27;\\&#x27;TABLENAME2\\&#x27;\\&quot;\n\n\n7）扩展7仅统计数据库各表数据，但不导出，参数estimate_only&#x3D;y#格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump estimate_only=y\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"oracle中查询、禁用、启用、删除表外键","url":"/2022/01/06/oracle%E4%B8%AD%E6%9F%A5%E8%AF%A2%E3%80%81%E7%A6%81%E7%94%A8%E3%80%81%E5%90%AF%E7%94%A8%E3%80%81%E5%88%A0%E9%99%A4%E8%A1%A8%E5%A4%96%E9%94%AE/","content":"oracle中查询、禁用、启用、删除表外键1.查询所有表的外键的：select table_name, constraint_name from user_constraints where constraint_type = &#x27;R&#x27;;\n\n2.禁用所有外键约束, 使用下面的sql生成对应sql脚本:select &#x27;alter table &#x27; || table_name || &#x27; disable constraint &#x27; || constraint_name || &#x27;;&#x27; from user_constraints where constraint_type = &#x27;R&#x27;;\n\n生成的sql类似下面的语句：alter table BERTH disable constraint BERTH_FK;alter table BOLLARD disable constraint BOLLARD_FK;alter table YARD_UNAVAIL_REGION disable constraint YARD_UNAVAIL_REGION_FK;\n\n3.启用所有外键约束, 使用下面的sql生成对应sql脚本:select &#x27;alter table &#x27; || table_name || &#x27; enable constraint &#x27; || constraint_name || &#x27;;&#x27; from user_constraints where constraint_type = &#x27;R&#x27;;\n\n生成的sql类似下面的语句：alter table BERTH enable constraint BERTH_FK;alter table BOLLARD enable constraint BOLLARD_FK;alter table YARD_UNAVAIL_REGION enable constraint YARD_UNAVAIL_REGION_FK;\n\n4.删除所有外键约束, 使用下面的sql生成对应sql脚本:select &#x27;alter table &#x27; || table_name || &#x27; drop constraint &#x27; || constraint_name || &#x27;;&#x27; from user_constraints where constraint_type = &#x27;R&#x27;;\n\n生成的sql类似下面的语句：alter table BERTH drop constraint BERTH_FK;alter table BOLLARD drop constraint BOLLARD_FK;alter table YARD_UNAVAIL_REGION drop constraint YARD_UNAVAIL_REGION_FK;\n","categories":["技术"],"tags":["技术","oracle","心得"]},{"title":"python实现b站自动下载收藏视频，防止视频和谐","url":"/2022/10/01/python-bilibili-Collection-Download/","content":"点击收藏b站视频后，自动下载收藏视频\n\n前言\n详细代码已上传至GitHub,访问链接：https://github.com/longhz/Collection_download_bilibili_video当然，你也可以直接下载测试运行，我已经打包好了下载链接：https://github.com/longhz/Collection_download_bilibili_video/releases\n\n目的写这个同步下载的小脚本是为了什么？今年，我在b站寻找资料时候，发现我关注的up主一些视频下架了，收藏的视频失效了很多，然后萌生了本地收藏视频的想法，想到了就开始动手去做\n\n实现的结果我最终要实现一个什么样的结果？\n\n\n我在b站点赞收藏的视频，分类规划文件夹\n根据不同的文件夹来生成不同的本地json\n脚本在执行后，每隔10分钟检测一次收藏夹是否有变动\n如果监测到有新收藏，会触发下载脚本\n下载的视频不能是音频和视频分开，得合二为一，所以会用的ffmpeg\n最终,在我本地电脑指定的保存视频路径中，能看到我的收藏视频\n\n 我已经实现了我的最终目标，我将脚本放在了我的nas后台，于是视频再也不会失效\n\n下面是主体的运行逻辑和框架生成本地json获取收藏夹中的一页内容当收藏夹的内容超过20，那么将会产生新的一页，这里pag来进行分页获取每一页的信息\n# 获取收藏夹一页内容def generate_fav_content_url(fid: int, page_number: int) -&gt; str:    &quot;&quot;&quot;        获取收藏夹一页内容        https://api.bilibili.com/x/v3/fav/resource/list?            keyword=&amp;order=mtime&amp;type=0&amp;tid=0&amp;platform=web&amp;jsonp=jsonp&amp;ps=20&amp;            media_id=&#123;fid&#125;&amp;pn=&#123;page_number&#125;        :param fid: 收藏夹id        :param page_number: 收藏夹中页码        :return: 获取收藏夹一页内容urlreturn f&#x27;https://api.bilibili.com/x/v3/fav/resource/list?ps=20&amp;media_id=&#123;fid&#125;&amp;pn=&#123;page_number&#125;&#x27;\n\n获取收藏夹信息这里获取的信息用于解析出查询页面的前置条件\n# 获取收藏夹信息def generate_fav_url(fid: int) -&gt; str:    &quot;&quot;&quot;    获取收藏夹信息    https://api.bilibili.com/x/v3/fav/resource/list?        pn=1&amp;ps=20&amp;keyword=&amp;order=mtime&amp;type=0&amp;tid=0&amp;platform=web&amp;jsonp=jsonp&amp;        media_id=&#123;fid&#125;    :param fid: 收藏夹id    :return: 获取收藏夹信息url    &quot;&quot;&quot;    return f&#x27;https://api.bilibili.com/x/v3/fav/resource/list?ps=1&amp;media_id=&#123;fid&#125;&#x27;\n\n查询页码# 查询页码def page_numbe(fid):    &quot;&quot;&quot;    fid: 视频收藏夹id    Returns: 分页统计    &quot;&quot;&quot;    resp = request_retry_json(generate_fav_url(fid))    media_count = resp[&#x27;data&#x27;][&#x27;info&#x27;][&#x27;media_count&#x27;]    page_count = math.ceil(media_count / 20)    return page_count\n\n获取Response信息def request_retry(url: str, headers: dict = None, retry: int = 3) -&gt; requests.Response:    if headers is None:        headers = &#123;&#x27;Connection&#x27;: &#x27;close&#x27;&#125;    headers[&#x27;Connection&#x27;] = &#x27;close&#x27;    while retry &gt; 0:        try:            resp = requests.get(url, headers=headers)            return resp        except:            logging.error(&#x27;request %s error: %s&#x27; % (url, sys.exc_info()[0]))            time.sleep(5 - retry)        retry -= 1    raise requests.RequestExceptiondef request_retry_json(url: str, headers=None, retry: int = 3) -&gt; dict:    return json.loads(request_retry(url, headers, retry).text)\n\n读取网页信息，并转化为son格式def request_info(resp):    bili_json1 = []    for a in resp[&#x27;data&#x27;][&#x27;medias&#x27;]:        # 视频搜索id        av_id = a[&#x27;id&#x27;]        # 视频搜索av_id链接        av_id_link = a[&#x27;link&#x27;]        # 播放时长        n = int(a[&#x27;duration&#x27;])        m = int(n / 60)        s = n - m * 60        # print(f&quot;可以换算成 &#123;m&#125;分钟 &#123;s&#125;秒。&quot;)        duration = f&quot;时长：&#123;m&#125;分钟&#123;s&#125;秒&quot;        # 类型        type = a[&#x27;type&#x27;]        # 标题        title = a[&#x27;title&#x27;]        # 去除格式和特殊符号        re_exp = u&quot;([^\\u4e00-\\u9fa5\\u0030-\\u0039\\u0041-\\u005a\\u0061-\\u007a\\’!\\&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@，。?、…【】《》？“”‘’！[&quot;u&quot;\\\\]^_`&#123;|&#125;~\\s])&quot;        video_title = str(title).strip(re_exp)                # 对一些格式的保留和替换        video_name = &quot;&quot;.join(video_title.split())        video_name = (((video_name.replace(&quot;/&quot;, &quot;-&quot;)).replace(&quot;】&quot;, &quot;-&quot;)).replace(&quot;[&quot;, &quot;-&quot;)).replace(&quot;【&quot;, &quot;-&quot;)        video_name = (((video_name.replace(&quot;；&quot;, &quot;-&quot;)).replace(&quot;\\n&quot;, &quot;&quot;)).replace(&quot;]&quot;, &quot;-&quot;)).replace(&quot;r&amp;b&quot;, &quot;&quot;)        video_name = (((video_name.replace(&quot;（&quot;, &quot;-&quot;)).replace(&quot;）&quot;, &quot;&quot;)).replace(&quot; &quot;, &quot;&quot;)).replace(&quot;＆&quot;, &quot;与&quot;)        video_name = (((video_name.replace(&quot;--&quot;, &quot;-&quot;)).replace(&quot;(&quot;, &quot;&quot;)).replace(&quot;)&quot;, &quot;&quot;)).replace(&quot;&amp;&quot;,&quot;&quot;)        video_name = (((video_name.replace(&quot;amp;&quot;, &quot;&quot;)).replace(&quot;|&quot;, &quot;-&quot;)).replace(&quot;《&quot;, &quot;&quot;)).replace(&quot;》&quot;, &quot;&quot;)                # 图片链接        cover = a[&#x27;cover&#x27;]        # 摘要        intro = a[&#x27;intro&#x27;]        # 页数        page = a[&#x27;page&#x27;]        # up主个人id        up_mid = a[&#x27;upper&#x27;][&#x27;mid&#x27;]        # up主昵称        up_name = a[&#x27;upper&#x27;][&#x27;name&#x27;]        # up主头像        up_face = a[&#x27;upper&#x27;][&#x27;face&#x27;]        # 视频id        bv_id = a[&#x27;bv_id&#x27;]        # 视频链接        bv_link = &quot;https://www.bilibili.com/video/&quot; + a[&#x27;bv_id&#x27;]        # 该视频收藏人数        bv_collect = a[&#x27;cnt_info&#x27;][&#x27;collect&#x27;]        # 该视频播放次数        bv_play = a[&#x27;cnt_info&#x27;][&#x27;play&#x27;]        # 当前观看人数        bv_danmaku = a[&#x27;cnt_info&#x27;][&#x27;danmaku&#x27;]        bili_json = &#123;            &#x27;title&#x27;: video_name,            &#x27;intro&#x27;: intro,            &#x27;cover&#x27;: cover,            &#x27;bv_id&#x27;: bv_id,            &#x27;bv_link&#x27;: bv_link,            &#x27;page&#x27;: page,            &#x27;av_id&#x27;: av_id,            &#x27;av_id_link&#x27;: av_id_link,            &#x27;type&#x27;: type,            &#x27;duration&#x27;: duration,            &#x27;bv_collect&#x27;: bv_collect,            &#x27;bv_play&#x27;: bv_play,            &#x27;bv_danmaku&#x27;: bv_danmaku,            &#x27;up_mid&#x27;: up_mid,            &#x27;up_name&#x27;: up_name,            &#x27;up_face&#x27;: up_face,            &#x27;is_Download&#x27;: 0        &#125;        bili_json1.append(bili_json)    return bili_json1\n\njson调用格式清理def write_json(resp, json_file_path_name):    bili_create_json(json_file_path_name)    try:        bili_json_format_eliminate(json_file_path_name)    except Exception as err:        pass    with open(json_file_path_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as fw:        fw.write(&#x27;,&#x27;)        json.dump(resp, fw, indent=4, ensure_ascii=False)        fw.write(&#x27;\\n&#x27;)    # print(&quot;写入完毕&quot;)    fw.close()    bili_create_json(json_file_path_name)    bili_tihuan(json_file_path_name)\n\n\n写入json文件def read_write_json(resp, json_file_path_name):    &quot;&quot;&quot;        文件操作中的 r, r+, a, a+, w, w+ 几种方式的区别:        r只读，r+ 可读可写，若文件不存在，报错；        w只写，w+ 可读可写，二者都会将文件内容清零,若文件不存在，创建；        a附加写方式打开，不可读，a+ 附加读写方式打开，二者都是若文件不存在，创建；    &quot;&quot;&quot;    my_file = Path(json_file_path_name)    resp1 = request_info(resp)    a = 0    b = 0    if my_file.is_file():        for rss in resp1:            tt1 = rss[&#x27;bv_id&#x27;]            title_ysx = str(rss[&#x27;title&#x27;].strip())            flag = select_json(tt1, json_file_path_name)                        if flag == 1:                # print(&quot;检测到已存在json文件中&quot;)                a = a + 1                # pass            else:                if title_ysx in &quot;已失效视频&quot;:                    print(&quot;该视频已被up主删除，已失效，为您跳过该条新增记录！&quot;)                    # b = b + 1                else:                    write_json(rss, json_file_path_name)                    b = b + 1                    print(f&#x27;新增了第&#123;b&#125;条收藏记录，标题：&#x27; + rss[&#x27;title&#x27;])        print(f&#x27;已检测到已存在收藏记录&#123;a&#125;条,新增了&#123;b&#125;条收藏记录&#x27;)    else:        print(&quot;检测到文件不存在，已为您新建json文件&quot;)        for rss in resp1:            title_ysx = str(rss[&#x27;title&#x27;].strip())            if title_ysx in &quot;已失效视频&quot;:                print(&quot;该视频已被up主删除，已失效，为您跳过该条新增记录！&quot;)            else:                write_json(rss, json_file_path_name)                b = b + 1                print(f&#x27;新增了第&#123;b&#125;条收藏记录，标题：&#x27; + rss[&#x27;title&#x27;])        print(f&#x27;已检测到已存在收藏记录&#123;a&#125;条,新增了&#123;b&#125;条收藏记录&#x27;)\n\n创建并添加json文件内容def ins_json(fid: int, json_name: str, file_dir):    # fid: 收藏夹id    fid = fid    # page_number: 收藏夹中页码    page_number = page_numbe(fid)    # 文件名称    json_name = json_name + &#x27;.json&#x27;    Subscribe = os.path.join(file_dir, &#x27;Subscribe_json&#x27;)    mkdir_folder(Subscribe)    # json文件路径名称    json_file_path_name = File_dir(Subscribe, json_name)    # total 负责做累加和    total = 1    while total &lt;= page_number:        url = generate_fav_content_url(fid, total)        resp = request_retry_json(url)        read_write_json(resp, json_file_path_name)        print(f&#x27;第&#123;total&#125;页收藏夹已记录~~\\n&#x27;)        total += 1    print(&quot;执行完毕&quot;)\n\n下载收藏夹中的视频请求的url地址# 请求的url地址def get_response(html_url):    &quot;&quot;&quot;    Args: 发送请求，以及获取数据函数        html_url: 请求的url地址    Returns: 返回请求服务器返回的响应数据    &quot;&quot;&quot;    # 请求代码，在发送请求前，需要进行伪装 headers 请求头    # user-agent 浏览器基本标识 用户代理 基本伪装 反爬手段    # &lt;Response [200]&gt; 对象response响应对象 200 状态码 表示请求成功    # 404 网址可能出错    # 403 网址没有权限，出现 403 加防盗链 referer ,是为了告诉服务器，我们发送请求的url地址，是从哪里跳转过来的    headers = &#123;        &quot;referer&quot;: &quot;https://search.www.bilibili.com&quot;,        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;    &#125;    response = requests.get(url=html_url, headers=headers, stream=True)  # 请求代码    # stream 字节流 (可选，开启后可用于判断大小以及做进度条使用)    # 一般选取小而快的内容时，将stream设置为false或者不加也许，可以快速的读取response.content内容    # 当stream开启后，后面需要自己执行response.close()操作进行关闭接收，否则只有所有的响应体数据被读取完毕连接才会被释放，如果用with可以不用close()    return response\n\n视频的详情页def get_video_info(html_url):    &quot;&quot;&quot;    获取视频标题 /音频 url地址 / 视频画面url地址    Args:        html_url: 视频的详情页    Returns: 视频标题 /音频 url地址 / 视频画面url地址    &quot;&quot;&quot;    response = get_response(html_url=html_url)    # response.text 获取响应体的文本数据    # print(response.text)    # 解析数据 提取视频标题 re正则表达式 css选择器 xpath bs4 parsel lxml (解析模块) jsonpath 主要提取json数据    # 正则表达式提取的数据内容 返回都是列表数据类型[0] 列表 所返回的索引取值（ 0或者-1都行，0是从左往右，-1是从右往左）    title = re.findall(&#x27;&lt;h1 title=&quot;(.*?)&quot; class=&quot;video-title tit&quot;&gt;&#x27;, response.text)[0] # 标题    # 去除格式和特殊符号    re_exp = u&quot;([^\\u4e00-\\u9fa5\\u0030-\\u0039\\u0041-\\u005a\\u0061-\\u007a\\’!\\&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@，。?、…【】《》？“”‘’！[&quot;u&quot;\\\\]^_`&#123;|&#125;~\\s])&quot;    video_title = str(title).strip(re_exp)    # 替换和保留一些格式    video_name = &quot;&quot;.join(video_title.split())    video_name = (((video_name.replace(&quot;/&quot;, &quot;-&quot;)).replace(&quot;】&quot;, &quot;-&quot;)).replace(&quot;[&quot;, &quot;-&quot;)).replace(&quot;【&quot;, &quot;-&quot;)    video_name = (((video_name.replace(&quot;；&quot;, &quot;-&quot;)).replace(&quot;\\n&quot;, &quot;&quot;)).replace(&quot;]&quot;, &quot;-&quot;)).replace(&quot;r&amp;b&quot;, &quot;&quot;)    video_name = (((video_name.replace(&quot;（&quot;, &quot;-&quot;)).replace(&quot;）&quot;, &quot;&quot;)).replace(&quot; &quot;, &quot;&quot;)).replace(&quot;＆&quot;, &quot;与&quot;)    video_name = (((video_name.replace(&quot;--&quot;, &quot;-&quot;)).replace(&quot;(&quot;, &quot;&quot;)).replace(&quot;)&quot;, &quot;&quot;)).replace(&quot;&amp;&quot;, &quot;&quot;)    video_name = (((video_name.replace(&quot;amp;&quot;, &quot;&quot;)).replace(&quot;|&quot;, &quot;-&quot;)).replace(&quot;《&quot;, &quot;&quot;)).replace(&quot;》&quot;, &quot;&quot;)    html_data = re.findall(&#x27;&lt;script&gt;window.__playinfo__=(.*?)&lt;/script&gt;&#x27;,response.text)[0]    # html_data 是&lt;class &#x27;str&#x27;&gt;数据类型    # 为了更加方便提取数据，可以字符串数据 转换成 字典数据类型    json_data = json.loads(html_data)    # 根据键值对取值    audio_url = json_data[&#x27;data&#x27;][&#x27;dash&#x27;][&#x27;audio&#x27;][0][&#x27;base_url&#x27;]    video_url = json_data[&#x27;data&#x27;][&#x27;dash&#x27;][&#x27;video&#x27;][0][&#x27;base_url&#x27;]    video_info = [video_name, audio_url, video_url]    return video_info\n\n下载保存def save(title, audio_url, video_url, tmp_dir):    &quot;&quot;&quot;    Args: 保存数据函数        title: 视频标题        audio_url: 音频url        video_url: 视频画面url    Returns:    &quot;&quot;&quot;    au_response = get_response(html_url=audio_url)    audio_content = au_response.iter_content(chunk_size=1024)    au_total = int(au_response.headers.get(&#x27;content-length&#x27;, 0))    vi_response = get_response(html_url=video_url)    video_content = vi_response.iter_content(chunk_size=1024)    vi_total = int(vi_response.headers.get(&#x27;content-length&#x27;, 0))    with open(tmp_dir + &#x27;/&#x27; + title + &#x27;.mp3&#x27;, mode=&#x27;wb&#x27;) as f, tqdm(            desc=&quot;音频下载进度&quot;,            total=au_total,            unit=&#x27;iB&#x27;,            unit_scale=True,            unit_divisor=1024    ) as bar:        for data in audio_content:            size = f.write(data)            bar.update(size)        f.close()    with open(tmp_dir + &#x27;/&#x27; + title + &#x27;.mp4&#x27;, mode=&#x27;wb&#x27;) as f, tqdm(            desc=&quot;视频下载进度&quot;,            total=vi_total,            unit=&#x27;iB&#x27;,            unit_scale=True,            unit_divisor=1024    ) as bar:        for data in video_content:            size = f.write(data)            bar.update(size)        f.close()    print(title, &quot;已下载保存至临时目录：&quot; + tmp_dir + &#x27;/&#x27; + title)\n\n下载主函数def Download_main(bv_id, tmp_dir, Download_videos):    &quot;&quot;&quot;    Args: 下载主函数        bv_id: bv号        tmp_dir：临时目录        Download_videos：实际保存目录    Returns:    &quot;&quot;&quot;    url = f&#x27;https://www.bilibili.com/video/&#123;bv_id&#125;&#x27;    video_info = get_video_info(url)  # [title, audio_url, video_url]    save(video_info[0], video_info[1], video_info[2], tmp_dir)    merge_data(video_info[0], tmp_dir, Download_videos)\n\n\n数据合并 - 视频合并（使用了ffmpeg）def merge_data(video_name, tmp_dir, Download_videos):    &quot;&quot;&quot; 数据合并 - 视频合并 &quot;&quot;&quot;    print(&#x27;视频合并开始：&#x27;, video_name)    cmd = f&quot;ffmpeg -i &#123;tmp_dir&#125;/&#123;video_name&#125;.mp4 -i &#123;tmp_dir&#125;/&#123;video_name&#125;.mp3 -c:v copy -c:a aac -strict experimental &#123;Download_videos&#125;/&#123;video_name&#125;.mp4&quot;    subprocess.run(cmd, shell=True)    print(f&#x27;视频合成结束,已将视频保存至路径： &#123;Download_videos&#125;/&#123;video_name&#125;.mp4&#x27;)\n\n读取json文件，执行脚本，修改下载状态def bili_json(folder_dir, Download_videos, json_file_path_name):    &quot;&quot;&quot;    Args: 读取json文件，执行脚本，修改下载状态        folder_dir:        Download_videos:    Returns:    &quot;&quot;&quot;    # 休眠10s    sleepTime = 10    json_flag = json_file_path_name.strip()    # 判断路径是否存在 存在 True 不存在   False    isExists = os.path.exists(json_flag)    # 判断结果    if not isExists:        print(json_file_path_name + &quot;不存在,已为您跳过!&quot;)    else:        with open(json_file_path_name, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as jsonFile:            data = json.load(jsonFile)            for aa in data:                bv_id = aa[&#x27;bv_id&#x27;]                is_Download = aa[&#x27;is_Download&#x27;]                title = aa[&#x27;title&#x27;]                # print(type(is_Download))                if is_Download == 0:                    bb = str(aa[&#x27;is_Download&#x27;]).replace(&#x27;0&#x27;, &#x27;1&#x27;)                    print(f&quot;\\n检测到新收藏,标题为：&#123;title&#125;,正在下载,请稍后&quot;)                    bili_download_main(folder_dir, Download_videos, bv_id)                    aa[&#x27;is_Download&#x27;] = int(bb)                    # print(&quot;下载脚本执行完毕！,休眠30s后，继续执行！ \\n ------------------------------------------------&quot;)                    with open(json_file_path_name, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:                        json.dump(data, f, indent=4, ensure_ascii=False)                        f.close()                    # jsonFile.close()                    print(f&quot;休眠10s后，将执行下载命令！ \\n ------------------------------------------------&quot;)                    time.sleep(sleepTime)                else:                    jsonFile.close()                    print(title + &quot;\\n检测到已存在下载历史，已为你跳过下载~ \\n ------------------------------------------------&quot;)\n\n下载前校验文件夹是否存在def bili_download_main(folder_dir, Download_videos, bv_id):    # url = &#x27;https://www.bilibili.com/video/BV1xL411M7yg/&#x27;    # video_info = get_video_info(url)    # print(video_info)    # 键盘输入    # keyword = input(&quot;输入要下载的bv号：&quot;)    # main(keyword)    start_time = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    start_time = datetime.strptime(start_time, r&quot;%Y-%m-%d %H:%M:%S&quot;)    try:        mkdir_folder(folder_dir)        print(&quot;临时文件夹——创建成功&quot;)        mkdir_folder(Download_videos)        print(&quot;视频实际存储文件夹——创建成功&quot;)        Download_main(bv_id, folder_dir, Download_videos)        print(&quot;视频下载成功&quot;)        end_time = datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)        end_time = datetime.strptime(end_time, r&quot;%Y-%m-%d %H:%M:%S&quot;)        diff = end_time - start_time        rm_folder(folder_dir)        print(&quot;临时文件夹——已删除&quot;)        print(f&quot;总计运行&#123;diff.total_seconds()&#125;秒&quot;)    except Exception as err:        end_time = datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)        end_time = datetime.strptime(end_time, r&quot;%Y-%m-%d %H:%M:%S&quot;)        diff = end_time - start_time        print(&quot;临时文件夹——已删除&quot;)        print(f&quot;总计运行&#123;diff.total_seconds()&#125;秒&quot;)\n\nconfig.ini设置与导入包def config_collection():    # 导入configparser模块，    conf = ConfigParser()    return conf\n\nconfig.ini设置\n[bili_collection]fid_1: 1781782216fid_1_name: 测试收藏;如果有多个收藏夹，复制fid_序列数字，如下面所示;fid_2: #;fid_2_name: #[video_dir];临时文件夹名称Temporary_folder: tmp;视频文件夹名称Download_videos_folder: Download_videos;具体保存路径windows_dir: D:/Downloads/video/;如果linux使用;linux_dir: /tmp/\n\n创建文件夹和替换文本创建文件def mkdir_folder(path):    &quot;&quot;&quot;    Args:        path: 创建临时文件    Returns:    &quot;&quot;&quot;    # 去除首位空格    path = path.strip()    # 去除尾部 \\ 符号    path = path.rstrip(&quot;\\\\&quot;)    # 判断路径是否存在 存在 True 不存在   False    isExists = os.path.exists(path)    # 判断结果    if not isExists:        # 如果不存在则创建目录        # 创建目录操作函数        os.makedirs(path)        # print(path+&#x27; 创建成功&#x27;)        return True    else:        # 如果目录存在则不创建，并提示目录已存在        # print(path+&#x27; 目录已存在&#x27;)        return False\n\n删除文件和文件夹def rm_folder(dir):    &quot;&quot;&quot;    Args:        dir: 遍历删除文件夹和文件    Returns:    &quot;&quot;&quot;    # 引入模块    import os    # 判断是否是文件夹，如果是，递归调用rmdir()函数    if (os.path.isdir(dir)):        # 遍历地址下的所有文件        for file in os.listdir(dir):            # 删除文件            oo = dir + r&#x27;/&#x27; + file            os.remove(oo)            # print(&quot;文件已删除&quot;)            # 继续删除文件夹            rm_folder(dir)        # 如果是空文件夹，直接删除        if (os.path.exists(dir)):            os.rmdir(dir)            # print(dir, &quot;文件夹删除成功&quot;)    # 如果是文件，直接删除    else:        if (os.path.exists(dir)):            os.remove(dir)            print(dir, &quot;文件删除成功&quot;)\n\njson文件格式初始化def bili_create_json(json_file_path_name):    ffe = os.path.exists(json_file_path_name)    if ffe == True:        with open(json_file_path_name, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as fw:            fw.write(&#x27;]\\n&#x27;)        # print(&quot;写入完毕&quot;)        fw.close()    else:        with open(json_file_path_name, &#x27;w+&#x27;, encoding=&#x27;utf-8&#x27;) as fw:            fw.write(&#x27;[&#x27;)        # print(&quot;创建写入完毕&quot;)        fw.close()\n\n文本格式清理def bili_json_format_eliminate(json_file_path_name):    matchPattern = re.compile(r&#x27;]&#x27;)    file = open(json_file_path_name, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;)    lineList = []    while 1:        line = file.readline()        if not line:            # print(&quot;指定格式已清理&quot;)            break        elif matchPattern.search(line):            pass        else:            lineList.append(line)    file.close()    file = open(json_file_path_name, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;)    for i in lineList:        file.write(i)    file.close()\n文本查询和替换def bili_tihuan(json_file_path_name):    # 创建一个变量并存储我们要搜索的文本    search_text = &quot;[,&quot;    # 创建一个变量并存储我们要添加的文本    replace_text = &quot;[&quot;    # 使用 open() 函数以只读模式打开我们的文本文件    with open(json_file_path_name, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as file:        # 使用 read() 函数读取文件内容并将它们存储在一个新变量中        data = file.read()        # 使用 replace() 函数搜索和替换文本        data = data.replace(search_text, replace_text)    # 以只写模式打开我们的文本文件以写入替换的内容    with open(json_file_path_name, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;) as file:        # 在我们的文本文件中写入替换的数据        file.write(data)    # 打印文本已替换    # print(&quot;文本已替换&quot;)\n\n查询验证文本是否存在def select_json(bv_id, json_file_path_name):    with open(json_file_path_name, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as jsonFile:        data = json.load(jsonFile)        aa = 0        for data_a in data:            if bv_id == data_a[&#x27;bv_id&#x27;]:                # print(&quot;存在&quot;)                aa = aa+1                jsonFile.close()                return aa            else:                pass        # print(aa)        jsonFile.close()        return aa\n\n判断系统平台和文件保存路径判断当前运行平台是windows还是linuxdef isWondowsorLinux():    &#x27;&#x27;&#x27; 判断当前运行平台 :return: &#x27;&#x27;&#x27;    sysstr = platform.system()    if (sysstr == &quot;Windows&quot;):        return True    elif (sysstr == &quot;Linux&quot;):        return False    else:        print(&quot;Other System &quot;)    return False\n\n根据系统环境分配文件保存路径def File_dir(file_dir: str, json_name: str):    mkdir_folder(file_dir)    # 判断当前系统环境    if isWondowsorLinux() == True:        windows_dir = os.path.join(file_dir, json_name)        return windows_dir    else:        linux_dir = os.path.join(file_dir, json_name)        return linux_dir\n\n调用收藏同步和执行下载日期获取def getDate():    date = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    return &quot;当前时间：&quot;+date\n\nconfig 初始化conf = config_collection()# 获取当前目录路径file_dir = os.path.dirname(os.path.abspath(__file__))# 实际文件路径CONF_FILE = os.path.join(file_dir, &#x27;config.ini&#x27;)# 实例化语言格式conf.read(CONF_FILE, encoding=&quot;utf-8&quot;)\n\n同步收藏夹def tb_sc():    # 获取配置文件的参数信息    fid_1 = conf.get(&quot;bili_collection&quot;, &quot;fid_1&quot;)    fid_1_name = conf.get(&quot;bili_collection&quot;, &quot;fid_1_name&quot;)    ins_json(fid_1, fid_1_name, file_dir)    # ---如果有多个收藏夹，可以仿照下面复制，要记得修改数字---    # fid_2 = conf.get(&quot;bili_collection&quot;, &quot;fid_2&quot;)    # fid_2_name = conf.get(&quot;bili_collection&quot;, &quot;fid_2_name&quot;)    # ins_json(fid_2, fid_2_name, file_dir)\n\n下载收藏夹视频def download_video():    # 获取配置文件的参数信息    tmp_file_name = conf.get(&quot;video_dir&quot;, &quot;Temporary_folder&quot;)    download_file_name = conf.get(&quot;video_dir&quot;, &quot;Download_videos_folder&quot;)    # 根据系统来使用linux还是windows    # linux_dir = conf.get(&quot;video_dir&quot;, &quot;linux_dir&quot;)    windows_dir = conf.get(&quot;video_dir&quot;, &quot;windows_dir&quot;)    # 临时文件夹路径    folder_dir_path = File_dir(windows_dir, tmp_file_name)    # 视频下载实际保存路径    Download_videos_path = File_dir(windows_dir, download_file_name)    # 收藏夹视频json文件路径    json_file_path_name1 = File_dir((os.path.join(file_dir, &#x27;Subscribe_json&#x27;)), (conf.get(&quot;bili_collection&quot;, &quot;fid_1_name&quot;)) + &quot;.json&quot;)    # 调用下载    bili_json(folder_dir_path, Download_videos_path, json_file_path_name1)    # ---如果有多个收藏夹，可以仿照下面复制，要记得修改数字---    # json_file_path_name2 = File_dir((os.path.join(file_dir, &#x27;Subscribe_json&#x27;)), (conf.get(&quot;bili_collection&quot;, &quot;fid_2_name&quot;)) + &quot;.json&quot;)    # bili_json(folder_dir_path, Download_videos_path, json_file_path_name2)\n\n运行# 1分=60s,休眠10分钟    sleepTime = 600    # 添加err_log日志文件    logging.basicConfig(filename=&#x27;err.log&#x27;)    while True:        try:            # 执行收藏同步            tb_sc()            print(getDate() + &quot; 收藏记录执行完毕！&quot;)            try:                # 执行视频下载                download_video()                print(getDate() + &quot; 视频下载执行完毕！&quot;)            except Exception as e:                s = traceback.format_exc()                print(getDate() + &quot; 视频下载执行失败！&quot;)                logging.error(s)        except Exception as e:            s = traceback.format_exc()            print(getDate() + &quot; 收藏记录执行失败！&quot;)            logging.error(s)        print(&quot;脚本执行完毕！&quot; + getDate() + &quot; ,休眠10分钟后，继续执行！&quot;)        # 休眠10分钟        time.sleep(sleepTime)        continue\n","categories":["技术"],"tags":["技术","心得","python"]},{"title":"rac1. 开始正式搭建rac-oracle11g","url":"/2021/06/06/rac1-%E5%BC%80%E5%A7%8B%E6%AD%A3%E5%BC%8F%E6%90%AD%E5%BB%BArac-oracle11g/","content":"oracle11g搭建1 创建oinstall和dba组，创建oracle用户groupadd dbagroupadd oinstallgroupadd opergroupadd asmadmingroupadd asmdbagroupadd asmoper添加grid 用户useradd -g oinstall -G dba,asmdba,asmadmin,asmoper grid添加oracle 用户useradd -g oinstall -G dba,oper,asmdba oracle修改密码echo -n oracle|passwd --stdin gridecho -n oracle|passwd --stdin oraclemkdir -p /u01/app/11.2.0/gridmkdir -p /u01/app/gridmkdir -p /u01/app/oraclechown grid:oinstall /u01/app/11.2.0/gridchown grid:oinstall /u01/app/gridchown -R oracle:oinstall /u01/app/oraclechmod -R 775 /u01/chown -R grid:oinstall /u01\n2. 修改内核参数vi &#x2F;etc&#x2F;sysctl.conf 在文件新增如下内容\nsed -i &#x27;s/kernel.shmmax/#kernel.shmmax/g&#x27; /etc/sysctl.confsed -i &#x27;s/kernel.shmall/#kernel.shmall/g&#x27; /etc/sysctl.conf#添加内核配置文件信息cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOFfs.aio-max-nr=1048576fs.file-max=6815744kernel.shmall=2097152kernel.shmmax=1073741824kernel.shmmni=4096kernel.sem=250 32000 100 128net.ipv4.ip_local_port_range=9000 65500net.core.rmem_default=262144net.core.rmem_max=4194304net.core.wmem_default=262144net.core.wmem_max=1048576EOFsysctl -p #提交内核参数\n\n3.两节点资源限制cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOForacle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536oracle soft stack 10240grid soft nproc 2047grid hard nproc 16384grid soft nofile 1024grid hard nofile 65536grid soft stack 10240EOFsysctl -p #提交内核参数\n\n\n4.&#x2F;etc&#x2F;profile #root用户的参数文件配置cat &gt;&gt; /etc/profile &lt;&lt; EOFif [ \\$USER = &quot;ORACLE&quot; ]||[ \\$USER = &quot;grid&quot; ]; thenif [ \\$SHELL = &quot;/bin/ksh&quot; ]; thenulimit -p 16384ulimit -p 65536elseulimit -u 16384 -n 65536fiumask 022fi###############################################export PATH=\\$PATH:/u01/app/11.2.0/grid/bin#color of grepalias grep=&#x27;grep --color=auto&#x27;EOF\n\n5.配置用户环境变量（对应用户下执行）5.1 grid 用户节点1\ncat &gt;&gt; /home/grid/.bash_profile &lt;&lt; EOFexport TMP=/tmp;export TMPDIR=\\$TMP;export ORACLE_HOSTNAME=rac1;export ORACLE_SID=+ASM1;export ORACLE_BASE=/u01/app/grid;export ORACLE_HOME=/u01/app/11.2.0/grid;export NLS_DATE_FORMA=&quot;yy-mm-dd HH24:MI:SS&quot;;export PATH=\\$ORACLE_HOME/bin:\\$PATH;export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK;EOF\n执行变更 source .bash_profile查看变更 env | grep ORA节点2\ncat &gt;&gt; /home/grid/.bash_profile &lt;&lt; EOFexport TMP=/tmp;export TMPDIR=\\$TMP;export ORACLE_HOSTNAME=rac2;export ORACLE_SID=+ASM2;export ORACLE_BASE=/u01/app/grid;export ORACLE_HOME=/u01/app/11.2.0/grid;export NLS_DATE_FORMA=&quot;yy-mm-dd HH24:MI:SS&quot;;export PATH=\\$ORACLE_HOME/bin:\\$PATH;export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK;EOF\n执行变更 source .bash_profile查看变更 env | grep ORA\n5.2 Oracle用户节点1\ncat &gt;&gt; /home/oracle/.bash_profile &lt;&lt; EOFexport TMP=/tmp;export TMPDIR=\\$TMP;export ORACLE_HOSTNAME=rac1;export ORACLE_BASE=/u01/app/oracle;export ORACLE_HOME=\\$ORACLE_BASE/product/11.2.0/db_1;export ORACLE_UNQNAME=prod;export ORACLE_SID=prod1;export ORACLE_TERM=xterm;export PATH=/usr/sbin:\\$PATH;export PATH=\\$ORACLE_HOME/bin:\\$PATH;export LD_LIBRARY_PATH=\\$ORACLE_HOME/lib:/lib:usr/lib;export CLASSPATH=\\$ORACLE_HOME/JRE:\\$ORACLE_HOME/jlib:\\$ORACLE_HOME/rdbms/jlib;export NLS_DATE_FORMA=&quot;yy-mm-dd HH24:MI:SS&quot;;export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK;EOF\n\n执行变更 source .bash_profile查看变更 env | grep ORA\n节点2\ncat &gt;&gt; /home/oracle/.bash_profile &lt;&lt; EOFexport TMP=/tmp;export TMPDIR=\\$TMP;export ORACLE_HOSTNAME=rac2;export ORACLE_BASE=/u01/app/oracle;export ORACLE_HOME=\\$ORACLE_BASE/product/11.2.0/db_1;export ORACLE_UNQNAME=prod;export ORACLE_SID=prod2;export ORACLE_TERM=xterm;export PATH=/usr/sbin:\\$PATH;export PATH=\\$ORACLE_HOME/bin:\\$PATH;export LD_LIBRARY_PATH=\\$ORACLE_HOME/lib:/lib:usr/lib;export CLASSPATH=\\$ORACLE_HOME/JRE:\\$ORACLE_HOME/jlib:\\$ORACLE_HOME/rdbms/jlib;export NLS_DATE_FORMA=&quot;yy-mm-dd HH24:MI:SS&quot;;export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK;EOF\n\n执行变更 source .bash_profile查看变更 env | grep ORA\n..bash_profile 或者 source .bash_profile#环境变量设置生效\n6 配置用户等效性（对应用户执行）Oracle 11g r2 ssh 可以在安装过程中进行配置\n6.1 grid 配置用户等效性mkdir ~&#x2F;.sshchmod 755 ~&#x2F;.ssh\nrac1ssh-keygen -t rsassh-keygen -t dsassh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub rac2ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_dsa.pub rac2rac2ssh-keygen -t rsassh-keygen -t dsassh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub rac1ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_dsa.pub rac1#以上用默认配置，一路回车即可#创建认证文件并将密钥内容填入\n\ntouch ~&#x2F;.ssh&#x2F;authorized_keyschmod 644 ~&#x2F;.ssh&#x2F;authorized_keys\nrac1cat ~&#x2F;.ssh&#x2F;.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keysrac2cat ~&#x2F;.ssh&#x2F;.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys\nrac1ssh grid@rac2 cat ~&#x2F;.ssh&#x2F;authorized_keysrac2ssh grid@rac1 cat ~&#x2F;.ssh&#x2F;authorized_keys\n#建立等效性rac1,rac2 双节点执行ssh rac1 datessh rac1-priv datessh rac2 datessh rac2-priv date\n\n6.2 oracle 配置用户等效性rac1ssh-keygen -t rsassh-keygen -t dsassh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub rac2ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_dsa.pub rac2rac2ssh-keygen -t rsassh-keygen -t dsassh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub rac1ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_dsa.pub rac1#以上用默认配置，一路回车即可\ntouch ~&#x2F;.ssh&#x2F;authorized_keyschmod 644 ~&#x2F;.ssh&#x2F;authorized_keys\nrac1cat ~&#x2F;.ssh&#x2F;.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keysssh oracle@rac2 cat ~&#x2F;.ssh&#x2F;authorized_keysrac2cat ~&#x2F;.ssh&#x2F;.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keysssh oracle@rac1 cat ~&#x2F;.ssh&#x2F;authorized_keys\n#建立等效性rac1,rac2 双节点执行ssh rac1 datessh rac1-priv datessh rac2 datessh rac2-priv date\nASM磁盘管理安装rpm包先用uname -r 或者 uname -a 查看当前的系统环境比如我目前的系统是redhat6.6，需要安装对应版本的包下载链接：https://kdy.zhongshenglong.xyz:163/#s/8MP4bqcA\nrpm -ivh kmod-oracleasm-2.0.8-4.el6_6.x86_64rpm -ivh oracleasm-support-2.1.8-1.el6.x86_64rpm -ivh oracleasmlib-2.0.4-1.el6.x86_64\n配置 ASM磁盘1. 初始化（2个节点都要执行）oracleasm configure -i\n\nConfiguring the Oracle ASM library driver.\nThis will configure the on-boot properties of the Oracle ASM librarydriver.  The following questions will determine whether the driver isloaded on boot and what permissions it will have.  The current valueswill be shown in brackets (‘[]’).  Hitting  without typing ananswer will keep that current value.  Ctrl-C will abort.\n\nDefault user to own the driver interface []: gridDefault group to own the driver interface []: oinstallStart Oracle ASM library driver on boot (y/n) [n]: yScan for Oracle ASM disks on boot (y/n) [y]: yWriting Oracle ASM library driver configuration: done\n\n初始化oracleasm init\n磁盘分区（节点1执行即可，2不要执行）fdisk -lll /dev/sd*可查看到之前挂载的3个盘然后执行格式化盘符fdisk /dev/sdbfdisk /dev/sdcfdisk /dev/sdd\n创建磁盘（节点1执行）ocr裸盘oracleasm createdisk OCR_VOTE /dev/sdb1数据oracleasm createdisk DATA /dev/sdc1归档oracleasm createdisk FRA /dev/sdd1\n\n\n变更查看 (rac1和rac2两个节点都要执行)oracleasm scandisks查看oracleasm listdisks\n\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"rac2.安装grid集群","url":"/2021/06/06/rac2-%E5%AE%89%E8%A3%85grid%E9%9B%86%E7%BE%A4/","content":"1.安装cvuqdisk 软件包节点1：\nmkdir -p /software/gridcd /software/gridllunzip linux.x64_11gR2_grid.zipchown -R grid:oinstall grid/export CVUQDISK_GRP=oinstallcd grid/rpm/rpm -ivh cvuqdisk-1.0.9-1.rpm\n节点2：\n\nscp cvuqdisk-1.0.7-1.rpm  rac2:&#x2F;software&#x2F;\n\nmkdir -p /software/gridcd /software/gridllunzip linux.x64_11gR2_grid.zipchown -R grid:oinstall grid/export CVUQDISK_GRP=oinstallrpm -ivh cvuqdisk-1.0.9-1.rpm\n\n2. 安装前校验检查（grid用户）cd /software/grid/grid./runcluvfy.sh stage -post hwos -n rac1,rac2 -verbose\n\n如果报错，则授权即可\nchown -R grid:oinstall /tmp/bootstrap\n\n开启图形化设置\nroot用户执行\nxhost +Sl:localuser:oraclexhost +Sl:localuser:grid\n正式环境下：export DISPLAY&#x3D;0.0xhost+\n虚拟环境，这里面的ip是net8的ip\nexport DISPLAY=192.168.65.1:0.0查看echo $DISPLAY\n\n解决图形化乱码\nLANG=en_US.UTF-8\n\n\n.&#x2F;runInstaller\n\n安装所需要的包，如果安装了高版本的还提示，可以忽略不影响查看命令rpm -qa | grep pdksh执行命令后，如果安装提示INS-20802 这个是由于scan-cluster使用&#x2F;etc&#x2F;hosts文件来解析造成的，直接点skip跳过就行安装完成后点击close\n11g的bug处理rac1\n首先卸载grid软件/u01/app/11.2.0/grid/crs/install/rootcrs.pl -deconfig -force -verbose重新执行/u01/app/11.2.0/grid/root.sh脚本\n\n然后新开个窗口，拉起服务，用root用户执行：\n/bin/dd if=/var/tmp/.oracle/npohasd of=/dev/null bs=1024 count=1\n\n\nrac1首先卸载grid软件\n/u01/app/11.2.0/grid/crs/install/rootcrs.pl -deconfig -force -verbose重新执行/u01/app/11.2.0/grid/root.sh脚本\n\n然后新开个窗口，拉起服务，用root用户执行：\n/bin/dd if=/var/tmp/.oracle/npohasd of=/dev/null bs=1024 count=1\n\n配置root环境rac1-root用户\nvi .bash_profileexport PATH=$PATH:/u01/app/11.2.0/grid/binsource .bash_profile\n\nrac2-root用户\nvi .bash_profileexport PATH=$PATH:/u01/app/11.2.0/grid/binsource .bash_profile\n\n\nrac1和rac2运行\ncrsctl check crs\n\n**rac1-root用户 **\ncrsctl stat res -t\n\nrac1-grid用户\ncrs_stat -tcrs_stat -t -v\n出现这个情况说明集群安装完成！\n关闭RAC集群切换到相应的目录下(根据现场环境切换)find &#x2F; -name crsctlcd &#x2F;u01&#x2F;app&#x2F;11.2.0&#x2F;grid&#x2F;bin##停止集群服务一节点[root@rac1 bin]# .&#x2F;crsctl stop crs二节点[root@rac2 bin]# .&#x2F;crsctl stop crs\n启动RAC集群find &#x2F; -name crsctlcd &#x2F;u01&#x2F;app&#x2F;11.2.0&#x2F;grid&#x2F;bin节点1：[root@rac1 bin]# .&#x2F;crsctl start crs节点2：[root@rac2 bin]# .&#x2F;crsctl start crs\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"rac3.Rac安装数据库","url":"/2021/06/06/rac3-Rac%E5%AE%89%E8%A3%85%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"Rac安装数据库\n本次任务将创建3个asm磁盘组,分别为：OCR\\DATA\\RAC。其中 DATA 将存放数据库文件； RAC 存放归档文件\n\nsu - gridasmca\n先创建和选择磁盘，外部External\n创建开机自启动root用户下（rac1和rac2同时启用）crsctl enable hascrsctl enable crs\n开始安装数据库11g上传安装包，解压至&#x2F;software&#x2F;目录下然后unzip 安装包名称进行解压\n\nchown -R oracle:oinstall database&#x2F;\n\nexport DISPLAY=192.168.65.1:0.0查看echo $DISPLAY\n解决图形化乱码\nLANG=en_US.UTF-8\n\n.&#x2F;runInstaller\n\nrac1和rac2同时执行（root用户下） /u01/app/oracle/product/11.2.0/db_1/root.sh完成后，可以尝试登录\n sqlplus / as sysdba\n\n查看物理内存free -m\n查看操作系统共享内存，oracle数据库使用内存要小于此值df -h &#x2F;dev&#x2F;shm&#x2F;\n调整方法：修改 nano &#x2F;etc&#x2F;fstabvi &#x2F;etc&#x2F;fstab修改对应&#x2F;dev&#x2F;shm 项 defaus,size&#x3D;2500Mcat &#x2F;etc&#x2F;fstab | grep shm\n重新挂载mount -o remount &#x2F;dev&#x2F;shm\ndbca建库到此，rac11g 正式安装成功可以登录查询下版本信息，操作命令，归档模式，如图所示\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"rac相关操作知识","url":"/2021/08/06/rac%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86/","content":"CRS及相关服务的常用命令的演示1、查看状态的命令# su-oracle --先切换到oracle用户$ crs_stat -t --查看crs及所有的service的状态$ crsctl check crs --用crsctl命令，检查crs相关服务的状态$ srvctl config database --查看服务名称$ srvctl config database -d rac -a # 检查数据库相关的信息$ srvctl status database -d prod --使用srvctl查看数据库状态--srvctl status instance -d prod -i rac1 # 检查指定实例的状态$ srvctl config asm -a # ASM配置$ srvctl status asm # ASM的状态$ srvctl status asm -n rac1 (rac2) --使用srvctl查看asm状态$ srvctl status nodeapps --使用srvctl查看所有节点上的服务是否正常$ srvctl status nodeapps -n rac1 (rac2) $ srvctl status vip -n rac1 (rac2) --VIP各个节点的状态以及配置$ srvctl status scan --SCAN的状态$ srvctl config scan --SCAN的配置$ srvctl config database -d prod -a --数据库配置$ srvctl status listener --TNS监听器状态以及配置$ srvctl config nodeapps -a -g -s -l --节点应用程序配置(VIP、GSD、ONS、监听器)\n\n\n2、启动和关闭相关服务的命令# su - oracle$ crs_start-all --启动所有的crs服务$ crs_stop-all --停止所有的crs服务$ crsctl start crs --启动crs服务$ crsctl stop crs --停止crs服务$ srvctl start nodeapps -n rac1 (rac2) --启动某节点上所有的应用$ srvctl stop nodeapps -n rac1 (rac2) --停止某节点上所有的应用$ srvctl start listener -n rac1 (rac2) --启动某个节点的listener$ srvctl stop listener -n rac1 (rac2) --停止某个节点的listener$ srvctl start instance-d db-i rac1 (rac2) --启动某个instance$ srvctl stop instance-d db-i rac1 (rac2) --停止某个instance$ srvctl start database-d db --启动数据库$ srvctl stop database-d db --停止数据库\n\n\n3、修改VIPsrvctl modify nodeapps -n xxx1 -A 192.10.0.1/255.255.255.0\n\n\nsrvctl 命令\nSRVCTL命令可以控制RAC数据库中的instance，listener以及services。通常SRVCTL在ORACLE用户下执行。下面我们来介绍srvctl命令。\n\n1、通过SRVCTL命令来start&#x2F;stop&#x2F;check所有的实例:$ srvctl start|stop|status database -d &lt;db_name&gt;\n\n\n2、start&#x2F;stop指定的实例：$ srvctl start|stop|status instance -d &lt;db_name&gt; -i &lt;instance_name&gt;\n\n\n3、列出当前RAC下所有数据库$ srvctl config database -d &lt;db_name&gt;\n\n\n4、start&#x2F;stop&#x2F;check所有的nodeapps，比如：VIP, GSD, listener, ONS：\n$ srvctl start|stop|status nodeapps -n &lt;node_name&gt;\n\n\n5、如果你使用ASM，srvctl也可以start&#x2F;stop ASM实例：$ srvctl start|stop asm -n &lt;node_name&gt; [-i &lt;asm_inst_name&gt;] [-o&lt;oracle_home&gt;]\n\n\n6、可以获取所有的环境信息：$ srvctl getenv database -d &lt;db_name&gt; [-i &lt;instance_name&gt;]\n\n\n7、设置全局环境和变量：$ srvctl setenv database -d &lt;db_name&gt; -t LANG=en\n\n\n8、从OCR中删除已有的数据库：$ srvctl remove database -d &lt;db_name&gt;\n\n\n9、向OCR中添加一个数据库：$ srvctl add database -d &lt;db_name&gt; -o &lt;oracle_home&gt;[-m &lt;domain_name&gt;] [-p&lt;spfile&gt;] [-A &lt;name|ip&gt;/netmask] [-r &#123;PRIMARY | PHYSICAL_STANDBY |LOGICAL_STANDBY] [-s &lt;start_options&gt;]&#125;\n\n\n10、向OCR中添加一个数据库的实例：$ srvctl add instance -d &lt;db_name&gt; -i &lt;instance_name&gt; -n &lt;node1&gt;$ srvctl add instance -d &lt;db_name&gt; -i &lt;instance_name&gt; -n &lt;node2&gt;\n\n\n11、向OCR中添加一个ASM实例：$ srvctl add asm -n &lt;node_name&gt; -i &lt;asm_inst_name&gt; -o &lt;oracle_home&gt;\n\n\n12、添加一个service$ srvctl add service -d &lt;db_name&gt; -s &lt;service_name&gt; -r &lt;preferred_list&gt;[-a &lt;available_list&gt;] [-P &lt;TAF_policy&gt;] [-u]\n\n\n13、修改在其他节点上的service$ srvctl modify service -d &lt;db_name&gt; -s &lt;service_name&gt; -I &lt;orig_instance_name&gt; -t &lt;target_instance_name&gt;\n\n\n14、relocate某个节点的service到其他节点srvctl relocate service -d &lt;db_name&gt; -s &lt;service_name&gt; -I","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"比起不停地获取大量的讯息，更重要的是学会屏蔽。","url":"/2019/07/19/sdjx/","content":"台灯是夜猫子的日光 黑夜是梦想者的倔强\n互联网时代盛产焦虑，有时候我们一天刷刷微博热点和短视频，很快就过去了。明星绯闻或是抖音才艺，都和你没有半毛钱关系，长期把时间花在这些事上，大脑的阈值会不断提高，渐渐地，对读书学习这样的低刺激事产生脱敏，越来越缺乏耐性和意志力。学着尽量去屏蔽外界的声音，才能更好的提高专注力和深度思考问题。要做好自我警惕\n\n","categories":["日记"],"tags":["心得","图片","日记"]},{"title":"redhHt Oracle Rac网络配置","url":"/2021/06/03/redhet-Rac%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","content":"此操作在虚拟机下，实体机环境由网络组协助配置完成\n1.虚拟机克隆（两台服务器，2个操作系统）2.虚拟机设置2.1 网卡添加（节点1和节点2一起设置）节点1：rac1，添加两块网卡，一块NAT模式（服务器可以对外上网），一块仅主机模式（私网，2台服务器之间去连接）,添加共享文件夹节点2：rac2，添加两块网卡，一块NAT模式，一块仅主机模式,添加共享文件夹\n2.2 网络设置\nvi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1\n\n关于外网：如果要打开比如百度，需要在配置中加上DNS1:网关ipRAC1\nDEVICE=eth0HWADDR=00:50:56:3E:DD:2ATYPE=EthernetUUID=bc85d78a-d9f0-4125-9a32-d60f32fce74cONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.137.129NETMARK=255.255.255.0\n\nDEVICE=eth1HWADDR=00:50:56:3F:D2:67TYPE=EthernetUUID=bc85d78a-d9f0-4125-9a32-d60f32fce74cONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.65.10NETMARK=255.255.255.0GATEWAY=192.168.65.2DNS1=192.168.65.2\n\n\n\n重启网络设置service network restart\nRAC2\nDEVICE=eth0HWADDR=00:50:56:3B:EC:60TYPE=EthernetUUID=5c01a2e3-e27f-45d5-bc2e-6476b6b8a49cONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.137.130NETMARK=255.255.255.0\n\nDEVICE=eth1HWADDR=00:50:56:24:12:AETYPE=EthernetUUID=5c01a2e3-e27f-45d5-bc2e-6476b6b8a49cONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.65.11NETMARK=255.255.255.0GATEWAY=192.168.65.2DNS1=192.168.65.2\n\n重启网络设置service network restart\n2.3 关闭防火墙重启后生效开启：chkconfig iptables on关闭：chkconfig iptables off及时生效，重启后失效开启：service iptables restart关闭：service iptables stop\n2.4 修改Linux系统的安全服务修改&#x2F;etc&#x2F;selinux&#x2F;config文件中设置SELINUX&#x3D;disabled，然后重启服务器\n2.5 Host文件配置&#x2F;etc&#x2F;hosts\n节点1和节点2相同#eth0 public （公网）192.168.65.10 rac1192.168.65.11 rac2#virtual    （vip-是虚拟的网）192.168.65.12 rac1-vip192.168.65.13 rac2-vip#private （私网-集群之间可相互连接）192.168.137.129 rac1-priv192.168.137.130 rac2-priv#scan     （这个是专门管理virtual）192.168.65.111 rac-scan\n\n注 vi &#x2F;etc&#x2F;sysconfig&#x2F;network,然后将HOSTNAME后面的值改为想要设置的主机名HOSTNAME&#x3D;rac1(根据实际情况修改)修改后查看下修改是否正确\nmore /etc/sysconfig/network\n\n\n\n\n\n\n","categories":["软件教程"],"tags":["技术","linux","心得","网络"]},{"title":"GitHub下载速度慢怎么办？","url":"/2020/03/29/tisuGithub/","content":"一招解决GitHub致命的下载速度\n\n\n通过码云来导入github，通过码云下载 \n\n第一步：找一个你需要下载的GitHub项目\n第二步：复制链接\n\n第三步：打开码云，然后选择从GitHub导入\n\n第四步：复制刚才的连接，起个名字，点击导入\n\n这个过程大概一两分钟\n\n导入完成：直接下载zip\n\n一个完整的过程动图\n\n","categories":["软件教程"],"tags":["软件","阅读","GitHub"]},{"title":"搭建个人博客图床","url":"/2020/02/03/tuchuang/","content":"Github+jsDelivr+PicGo 打造稳定快速、高效免费图床\n\n– 前言图床是个啥东西就不用过多介绍了，先来对比一下各路图床：\n\n微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉\nSM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧\n其他小众图床：随时有挂掉的风险\nImgur等国外图床：国内访问速度太慢，随时有被墙的风险\n大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）\n\n因此，GitHub图床是个不错的选择，利用jsDelivr CDN加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo工具一键上传，操作简单高效，GitHub和jsDelivr都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！\n\n– 新建GitHub仓库登录&#x2F;注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件\n\n\n– 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页\n\n\n\n\n– 配置PicGo前往下载PicGo，安装好后开始配置图床\n\n\n设定仓库名：按照【用户名 &#x2F; 图床仓库名】的格式填写\n\n设定分支名：【master】\n\n设定Token：粘贴之前生成的【Token】\n\n指定存储路径：填写想要储存的路径，如【ITRHX-PIC&#x2F;】，这样就会在仓库下创建一个名为 ITRHX-PIC 的文件夹，图片将会储存在此文件夹中\n\n设定自定义域名：它的作用是，在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为\n【 https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】，\n\n上传完毕后，我们就可以通过【 https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径 】\n\n加速访问我们的图片了，比如：https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.png\n\n\n\n\n– 进行高效创作   配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！\n","categories":["软件教程"],"tags":["图床工具","Windos","开源"]},{"title":"vmware共享磁盘挂载","url":"/2021/06/03/vmware%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/","content":"vmware挂载共享磁盘1.生成共享磁盘在C:\\Program Files (x86)\\VMware\\VMware Workstation 路径下打开DOS窗口运行如下命令：\nvmware-vdiskmanager.exe -c -s 2g -a lsilogic -t 2 J:\\vm\\cs\\rac-sharedisk\\ocr_voting_disk.vmdkvmware-vdiskmanager.exe -c -s 5g -a lsilogic -t 2 J:\\vm\\cs\\rac-sharedisk\\fra_arc_disk.vmdkvmware-vdiskmanager.exe -c -s 5g -a lsilogic -t 2 J:\\vm\\cs\\rac-sharedisk\\data_disk.vmdk\n\n2.编辑虚拟机配置文件添加共享文件夹然后关闭虚拟机,用记事本打开虚拟机名称.wmx （RAC 1.vmx&#x2F;RAC 2.vmx），添加以下内容：\ndisk.locking = &quot;FALSE&quot;diskLib.dataCacheMaxSise = &quot;0&quot;diskLib.dataCacheMaxReadAheadSise = &quot;0&quot;diskLib.dataCacheMinReadAheadSise = &quot;0&quot;diskLib.maxUnsyncedWrites = &quot;0&quot;scsi1.present = &quot;TRUE&quot;scsi1.virtualDev = &quot;lsilogic&quot;scsil.sharedBus = &quot;VIRTUAL&quot;scsi1:0.present = &quot;TRUE&quot;scsi1:0.mode = &quot;independent-persistent&quot;scsi1:0.fileName = &quot;J:\\vm\\cs\\rac-sharedisk\\ocr_voting_disk.vmdk&quot;scsi1:0.deviceType = &quot;disk&quot;scsi1:0.redo = &quot;&quot;scsi1:1.present = &quot;TRUE&quot;scsi1:1.mode = &quot;independent-persistent&quot;scsi1:1.fileName = &quot;J:\\vm\\cs\\rac-sharedisk\\data_disk.vmdk&quot;scsi1:1.deviceType = &quot;disk&quot;scsi1:1.redo = &quot;&quot;scsi1:2.present = &quot;TRUE&quot;scsi1:2.mode = &quot;independent-persistent&quot;scsi1:2.fileName = &quot;J:\\vm\\cs\\rac-sharedisk\\fra_arc_disk.vmdk&quot;scsi1:2.deviceType = &quot;disk&quot;scsi1:2.redo = &quot;&quot;\n\n修改添加好后，就可以正常打开虚拟机了，这时候就可以看到挂载好了共享磁盘\n\n","categories":["软件教程"],"tags":["技术","心得"]},{"title":"上传项目到GitHub","url":"/2022/03/06/%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0GitHub/","content":"linux上传项目到github，及一些git命令\n\n\n\n打开github，找到头像-&gt;setting-&gt;SSH and GPG keys-&gt;new SSH key创建一个新项目(名字和本地项目相同)，\n\n１．在github创建空仓库(如gitcode)．\n步骤一：首先在用户右侧的‘+’下选择新储存库新建项目。如图一：\n\n\n\n然后自定义新项目的名称和对新项目的描述，并确定新建该项目。如图二：\n\n\n步骤二：点击图三蓝色圈圈里的图标进行复制链接，并在Linux上执行git clone+链接（用shift+insert进行拷贝）。\n\n２．在linux上安装git：安装git：\nyum install git\n\n\n\n３．linux配置GitHub： 绑定GitHub用户：\ngit config --global user.name &quot;XXX&quot;git config --global user.email &quot;xxx@xxx.com&quot;\n\n查看git配置：\ngit config --list\n为GitHub账户设置SSH key\n（1）检查是否有SSH key：cd ~/.ssh（2）生成SSH key：ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;\n\nGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 默认回车Enter passphrase (empty for no passphrase):默认回车Enter same passphrase again: 默认回车Your identification has been saved in /home/XXX/.ssh/id_rsa. Your public key has been saved in /home/XXX/.ssh/id_rsa.pub.The key fingerprint is: XXX\n（3）添加SSH公钥到GitHub：在GitHub设置内找到添加SSH，将id_rsa.pub内容复制到key中【复制时注意空格】（4）测试是否连接成功ssh -T &#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;\n４．在linux创建和仓库同名的文件夹并初始化：进入你想要上传的目录，然后把这个目录变成git可以管理的仓库 git init\n  mkdir /gitcodecd /gitcodegit init\nGit仓库和本地仓库进行关联\n在本地仓库的命令行输入：\n   git remote add origin https://github.com/fgguo/gitcode.gitorigin后面为git项目的地址。\n\n５．添加文件  git add fdw_adapter src（如果是所有项目就是git add .）\n  将文件添加到仓库并查看当前工作区（相当于缓存区）的状态添加文件：git add XXX查看缓存区的内容：git status\n\n６．提交备注  git commit -m &#x27;first commit&#x27;这里提交备注\n７．推送本地项目到github  git push -u origin master\n\n由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了。上传项目的过程可能需要等一段时间.\n\n这里可能踩坑\n\n超时处理方法\n\n输入git密码不行，需要自己去生成token处理方法\n\n\n这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了：\n８．查看以前的commit  git log --oneline\n９．添加tag git tag -a v1.０.1 8a5cbc2 (commit的标识代码)\n１０．查看tag  git tag\n11．push 到github  git push origin tag名\n12．本地创建并切换分支  git checkout -b 本地分支\n13．push到远端与原来不同的新分支git push origin 本地分支:远端的分支如果是同名，则git push -u origin &lt;本地分支名&gt;\n\n到目前为止，你已经把你想上传的文件放到本地仓库上了，也已经把本地仓库和远程仓库连起来了，现在需要把文件从本地仓库push到远程仓库git push origin master\n\n\nTips1：通常在Linux上init后主分支是master，而GitHub上新建的仓库，默认主分支是main，所以直接push过去，会默认在GitHub远程仓库创建master分支解决办法：将本地的master分支改名为main分支；或 push的时候指明git push origin master:main\n\n\nTips2：查看目前已经关联的远程仓库：git remote\n\n\nTips3：通常在GitHub端创建好仓库后会有license和readme文件，这时如果直接将本地仓库push到远程仓库就会出问题，因为远程已经有东西了，而这个东西你本地还没有，所以你需要先把远程仓库先pull到本地，然后再一块push过去git pull origin maingit push origin main\n\n14．有大文件时，通过提示，先物理删除，然后git rm 在仓库删除，然后在git commit15．拉取远端代码：git  pull     从远程拉取最新版本 到本地  自动合并 merge            git pull origin mastergit  fetch   从远程获取最新版本 到本地   不会自动合并 merge    git fetch  origin master       git log  -p master ../origin/master     git merge orgin/master实际使用中  使用git fetch 更安全    在merge之前可以看清楚 更新情况  再决定是否合并\n\n\n\n上述都是基本操作，如果你需要更高级的操作或者对命令理解的更为透彻，建议看git教程参考：https://www.yiibai.com/git/git_remote.htmlhttps://blog.csdn.net/hxf0663/article/details/79527453https://www.jianshu.com/p/ad148fda5860https://blog.csdn.net/weixin_33755557/article/details/86217211ickoak/article/details/115579689\n\n","categories":["技术"],"tags":["技术","linux","GitHub"]},{"title":"关于Oracle及日常注意事项","url":"/2020/03/06/%E5%85%B3%E4%BA%8EOracle%E5%8F%8A%E6%97%A5%E5%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"MySQL数据库与Oracle 数据库有什么区别？1、 应用方面\n\nMySQL 是中小型应用的数据库。一般用于个人和中小型企业。Oracle 属于大型数据库，一般用于具有相当规模的企业应用。\n\n2、 自动增长的数据类型方面\n\nMySQL有自动增长的数据类型。Oracle 没有自动增长的数据类型。需要建立一个自增序列。\n\n3、 group by 用法\n\nMySQL 中group by 在SELECT 语句中可以随意使用，但在ORACLE 中如果查询语句中有组函数，那么其他列必须是组函数处理过的或者是group by子句中的列，否则会报错。\n\n4、 引导方面\n\nMySQL中可以用单引号、双引号包起字符串，Oracle 中只可以用单引号包起字符串\n\n什么是数据库？\n本质上是使用数据结构存储数据的仓库。\n\n什么是关系型数据库？\n使用关系模型存储数据的数据库。关系模型指表与表之间的关系，包含一对一、一对多、多读多。\n\n什么是非关系型数据库？\n使用非关系模型保存数据的数据库。例如列存储、键值对、文件形式。\n\n说一说数据库三大范式？\n第一范式，表中字段是原子的，不可再分；\n第二范式，表中字段必须依赖主键的全部字段，不能只依赖一部分；\n第三范式，表中字段必须直接依赖主键，不能存在传递依赖。\n\n\n其实真正的数据库设计并没有遵循三大范式，特别是OLAP型数据库\n\n事务的四大特性原子性：事务要么全做，要么全不做一致性：事务完成签后状态一致，不能产生错误结果隔离性：各个事务见状态不可见，且互补影响永久性：事务一旦完成，结果永远不会改变，即使机器故障，也能通过日志恢复\n\n\nORACLE数据库启动与关闭的步骤\n启动：启动实例—-加载数据库数据—–打开数据库关闭：关闭数据库—-卸载数据库数据—-关闭实例\n\n怎样将一个旧数据库数据移到一个新的数据库\n在旧数据库中，进入emap库查询默认表空间和临时表空间。\n进入新库，创建表空间。\n在新库创建用户和数据库\n从旧库里备份数据\n将备份的dump文件导入新库\n\n用命令创建表空间、用户，并为用户授权、收回权限。Create tablespace tabllespacenameDatafile ‘f:\\orcl\\user001.dbf size 20mDefault storage(Initial 512kNext 512kminextents 2pctincrease 50%maxExitnts 2048)minimum extent 512kloggingonlinepermanentextent management dictionary;回收权限： revoke privilege from user；create tablespace tablespace_namedatafile ‘’default storage(initial xxxkbnext yykbminextents 2pctincrease nnnnmaxextents mmm)loggingonlineextent management dictionary/local[autoallocate/uniform size xxxmb];create user user_nameidentified by passwore/identified externally/identified globally as ‘CN=user’default tablespace tablespace_nametemporary tablespace tablespace_name[account lock /unlock]grant connect to user_name;grant create table to suer_name;grant update on table_name to user_name;revoke create table from user_name;revoke update on table_name from user_name;\n\n表空间如何扩展?并用语句写出?两种扩展方式：\n增加数据文件alter tablespace tablespace_name add datafile ‘’ xxMB\n\n扩展数据文件大小alter database datafile ‘’ resize newMB\n\n用命令创建用户，并为用户授权。Create user user_nameidentified by password /identified externally/identified blobally as ‘CN=user’default tablespace tablespace_nametemporary tablespace tablespace_name;grant role/privilege to user_name;\n\n谈谈你对角色的理解，常用的角色有哪些?\n角色就是一组权限的数据库实体，它不属于任何模式或用户但是可以被授予任何用户。\n\n常用的角色有：\nCONNECT，DBA，RESOURCE，SELECT_CATALOG_ROLE（查询所有表视图权），DELETE_CATALOG_ROLE（删除权限）等。\n\n\n角色的创建和授权：和创建用户为用户授权差不多。\nCreate role role_name identified …grant 权限to role_name。\n\n\n在Oracle中查看当前用户，通常有哪些方式?show user;select username from user_users;\n\n\n简述oracle中 dml、ddl、dcl的使用DML包括：\nSELECT：用于检索数据；\nINSERT：用于增加数据到数据库；\nUPDATE：用于从数据库中修改现存的数据\nDELETE：用于从数据库中删除数据。\n\n\nDML（Data Manipulation Language，数据操作语言）：用于检索或者修改数据。\n\nDDL包括：\nCREATE 创建\nALTER 修改\nDROP 删除\n\n\nDDL（Data Definition Language，数据定义语言）： 用于定义数据的结构，比如 创建、修改或者删除数据库对象。\n\nDCL包括：\nGRANT  授权 \nREVOKE  回收权限 \ndeny   拒绝授予主体权限。防止主体通过其组或角色成员身份继承权限\n\n\nDCL（Data Control Language，数据控制语言）：用于定义数据库用户的权限。\n\noracle创建表的几种方式；应该注意些什么 ？建表方式：\n完全新建一张表\n\ncreate table emp(id integer)tablespace CICI;\n\n\n\n在原有表的基础上新建一张表\n\nCREATE TABLE EMP_TEMP TABLESPACE CICI AS( SELECT * FROM EMP) ;\n注意事项：表名和字段名的命名规则：必须以字母开头，可以含符号A-Z,a-z,0-9,_,$,#大小写不区分不用SQL里的保留字, 一定要用时可用双引号把字符串括起来．用和实体或属性相关的英文符号长度有一定的限制建表时可以用中文的字段名, 但最好还是用英文的字段名创建表时要把较小的不为空的字段放在前面, 可能为空的字段放在后面建表时如果有唯一关键字或者唯一的约束条件，建表时自动建了索引一个表的最多字段个数也是有限制的，254个.\n\n\ndelete 与Truncate区别？Truncate 是DDL 语句，DELETE 是DML语句。Truncate 的速度远快于DELETE；\n\n\n原因是： 当执行DELETE操作时所有表数据先被COPY到回滚表空间，数据量不同花费时间长短不一。而TRUNCATE 是直接删除数据不进回滚表空间。\n\n1、 delete 数据可以运行Rollback 进行数据回滚。而Truncate 则是永久删除不能回滚。2、 Truncate 操作不会触发表上的delete触发器，而delete 会正常触发。3、 Truncate 语句不能带where 条件意味着只能全部数据删除，而DELETE可带where 条件进行删除数据。4、 Truncate 操作会重置表的高水位线（High Water Mark）,而delete 不会。\n\n哪个后台进程刷新 materialized views?The Job Queue Processes.\n怎样创建一个触发器, 触发器的定义, 触发器的游标怎样定义CREATE [OR REPLACE] TIGGER触发器名 触发时间 触发事件　ON表名　[FOR EACH ROW]　BEGIN　　pl/sql语句CURSOR 游标名 is SELECT * FROM 表名 （定义游标）　　END\n\n其中：　触发器名：触发器对象的名称。　由于触发器是数据库自动执行的，因此该名称只是一个名称，没有实质的用途。\n触发时间：指明触发器何时执行，该值可取：\nbefore 表示在数据库动作之前触发器执行;\nafter 表示在数据库动作之后出发器执行。\n触发事件：指明哪些数据库动作会触发此触发器：\n　　 insert：数据库插入会触发此触发器;\n\noracle中存储过程，游标和函数的区别\n1、 游标类似指针，游标可以执行多个不相关的操作.如果希望当产生了结果集后,对结果集中的数据进行多 种不相关的数据操作。2、 函数可以理解函数是存储过程的一种； 函数可以没有参数,但是一定需要一个返回值，存储过程可以没有参数,不需要返回值；两者都可以通过out参数返回值, 如果需要返回多个。3、 参数则建议使用存储过程；在sql数据操纵语句中只能调用函数而不能调用存储过程。\n\n如何增加buffer cache的命中率？在数据库较繁忙时\n\n适用buffer cache advisory 工具，查询v$db_cache_advice . \n\n如果有必要更改，可以使用命令 \nalter system setdb_cache_size \n\n\n\nOracle中function和procedure的区别？\n1、 可以理解函数是存储过程的一种\n2、 函数可以没有参数,但是一定需要一个返回值，存储过程可以没有参数,不需要返回值\n3、 函数return返回值没有返回参数模式，存储过程通过out参数返回值, 如果需要返回多个参数则建议使用存储过程\n4、 在sql数据操纵语句中只能调用函数而不能调用存储过程\n\n怎样创建一个存储过程, 游标在存储过程怎么使用, 有什么好处?创建存储过程CREATE PROCEDURE user ()BEGIN -- 定义变量DECLARE i INT DEFAULT 100000;DECLARE p_telphone VARCHAR(20);DECLARE p_username VARCHAR(20);DECLARE p_authcode VARCHAR(20);DECLARE p_card VARCHAR(20);DECLARE p_password VARCHAR(20);WHILE i &lt; 150000 DO-- 对参数赋值SET p_telphone = CONCAT(&#x27;15410&#x27;,i);SET p_username = CONCAT(&#x27;张&#x27;,i);SET p_authcode = CONCAT(&#x27;&#x27;,i);SET p_card = CONCAT(&#x27;SN000&#x27;,i);SET p_password = CONCAT(&#x27;hnjb&#x27;,i);-- 创建数据INSERT INTO user ( telphone, username, authcode, card, password ) VALUES ( p_telphone, p_username, p_authcode, p_card, p_password );SET i=i+1;END WHILE;END\n使用存储过程访问数据库比直接用SQL语句访问有何优点？\n1、 存储过程是预编译过的，执行时不须编译，执行速度更快。2、 存储过程封装了多条SQL，便于维护数据的完整性与一致性。3、 实现代码复用。\n\n如何使用Oracle的游标？\n1、 oracle中的游标分为显示游标和隐式游标\n2、 显示游标是用cursor…is命令定义的游标，它可以对查询语句(select)返回的多条记录进行处理；隐式游标是在执行插入 (insert)、删除(delete)、修改(update)和返回单条记录的查询(select)语句时由PL&#x2F;SQL自动定义的。\n3、 显式游标的操作：打开游标、操作游标、关闭游标；PL&#x2F;SQL隐式地打开SQL游标，并在它内部处理SQL语句，然后关闭它\n\n使用游标好处使用游标可以执行多个不相关的操作.如果希望当产生了结果集后，对结果集中的数据进行多种不相关的数据操作 。使用游标可以提供脚本的可读性 。使用游标可以建立命令字符串，使用游标可以传送表名，或者把变量传送到参数中，以便建立可以执行的命令字符串。存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。可保证数据的安全性和完整性。通过存储过程可以使没有权限的用户在控制之下间接地存取数据库，从而保证数据的安全。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。 再运行存储过程前，数据库已对其进行了语法和句法分析，并给出了优化执行方案。这种已经编译好的过程可极大地改善SQL语句的性能。 由于执行SQL语句的大部分工作已经完成，所以存储过程能以极快的速度执行。可以降低网络的通信量, 不需要通过网络来传送很多sql语句到数据库服务器了 ，使体现企业规则的运算程序放入数据库服务器中，以便集中控制\n\n如何判断游标已经到最后一行?Cursor_name%notfound\n\n\n\n集合操作符\n1、 Union ： 不包含重复值，默认按第一个查询的第一列升序排列。2、 Union All : 完全并集包含重复值。不排序。3、 Minus 不包含重复值，不排序。\n\n怎样创建一个索引,索引使用的原则,有什么优点和缺点创建索引的方法：创建标准索引： CREATE  INDEX 索引名 ON 表名 (列名)  TABLESPACE 表空间名; 创建唯一索引: CREATE unique INDEX 索引名 ON 表名 (列名)  TABLESPACE 表空间名; 创建组合索引: CREATE INDEX 索引名 ON 表名 (列名1,列名2)  TABLESPACE 表空间名; 创建反向键索引: CREATE INDEX 索引名 ON 表名 (列名) reverse TABLESPACE 表空间名; \n索引使用的原则：1.搜索的索引列\n\n要建索引的列不一定是所要结果的列，简单的说就是where条件中出现的列需要索引，或者链接子句用到的列需要索引，而只在select中出现的列不需要索引。\n\n2.使用唯一索引\n\n考虑某列中值的分布，索引列的基数越大越好，例如存放出生日期的列具有不同的值，很容易区分各行;而存放性别的列，只有两个值，所以对这种列加索引也没有什么价值，不管搜哪个值，都是大约一半的数据量。\n\n3.使用短索引\n\n如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个char（200）的列，如果前10～20个字符内，多数值是唯一的，那么就不要对整个列进行索引（时刻考虑对资源的占用问题）\n\n4.利用最左前缀\n\n在创建一个n列的索引时，实际是创建了mysql可利用的n个索引。多列索引可以起几个索引的作用，因为可以利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。\n\n5.不要过度索引\n\n什么列都建索引是错误的，比如从来都不查询的列，建上索引后一次也不用没什么价值，反而占用了额外的资源。\n\n索引的优点：\n通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\n在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\n通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。\n\n索引的缺点：\n创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。\n索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\n当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n\n如何重构索引？ALTER INDEX &lt;index_name&gt; REBUILD;\n\nOracle中经常使用到的函数length 长度lower 小写upper 大写to_date 转化日期to_char 转化字符to_number 转化数字Ltrim 去左边空格rtrim 去右边空格substr 截取字符串add_month 增加或减掉月份\n\n1.数字函数\n\nNVL( string1, replace_with) ：如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。\nTRUNC(d,[fmt]) ：该函数用于截取日期时间数据.如果fmt指定年度，则结果为本年度的1月1日；如果fmt指定月，则结果为本月1日。\nMOTNS_BETWEEN(d1,d2)：该函数用于返回d1和d2之间相差的月数.如果d1小于d2，则返回负数；如果d1和d2的天数相同，或都是月底，则返回整数；否则Oracle以每月31天为准来计算结果的小数部分。\nNEXT_DAY(d,char)：该函数用于返回指定日期后的第一个工作日（由char指定）所对应的日期。\n\n转换函数\n\nTO_CHAR(data[,fmt[,nls_param]]) ：该函数用于将日期值转变为字符串，其中fmt用于指定日期格式，nls_param用于指定nls参数。\nTO_CHAR(n[,fmt[,nls_param]])：用于将数字值转换为VARCHAR2数据类型。\nTO_DATE(char[,fmt[,nls_param]])：该函数用于将符合指定日期的函数转变为DATE类型的数值\n\n解码函数\n\nDECODE函数为Oracle专属。\n\nDECODE(value, if1, then1, if2,then2, if3,then3, . . . else )\n\n\n\n数据库正常启动所经历的几种状态 ?STARTUP NOMOUNT 数据库实例启动STARTUP MOUNT 数据库装载STARTUP OPEN 数据库打开\n\n回滚段的作用是什么事务回滚：当事务修改表中数据的时候，该数据修改前的值(即前影像)会存放在回滚段中，当用户回滚事务(ROLLBACK)时，ORACLE将会利用回滚段中的数据前影像来将修改的数据恢复到原来的值。\n事务恢复：当事务正在处理的时候，例程失败，回滚段的信息保存在undo表空间中，ORACLE将在下次打开数据库时利用回滚来恢复未提交的数据。\n\n1、 读一致性：当一个会话正在修改数据时，其他的会话将看不到该会话未提交的修改。2、 当一个语句正在执行时，该语句将看不到从该语句开始执行后的未提交的修改(语句级读一致性)3、 当ORACLE执行Select语句时，ORACLE依照当前的系统改变号(SYSTEM CHANGE NUMBER-SCN)。4、 来保证任何前于当前SCN的未提交的改变不被该语句处理。可以想象：当一个长时间的查询正在执行时。5、 若其他会话改变了该查询要查询的某个数据块，ORACLE将利用回滚段的数据前影像来构造一个读一致性视图。\n\n你必须利用备份恢复数据库，但是你没有控制文件，该如何解决问题呢？\n重建控制文件，用带 backup control file 子句的recover 命令恢复数据库。\n\n如何变动数据文件的大小？ALTER DATABASE DATAFILE &lt;datafile_name&gt; RESIZE &lt;new_size&gt;;\n\n怎样创建一个视图,视图的好处, 视图可以控制权限吗?create view 视图名 asselect 列名 [别名]  …  from 表 [unio [all] select … ] ]\n\n\n好处：\n视图可以简化用户的操作；\n视图使用户能够多角度看待同一数据；\n视图对重构数据库提供了一定程度的逻辑独立性；\n视图能够对机密数据提供安全保护\n适当利用视图可以更清晰地表达查询\n可以简单的将视图理解为sql查询语句，视图最大的好处是不占系统空间\n一些安全性很高的系统，不会公布系统的表结构，可能会使用视图将一些敏感信息过虑或者重命名后公布结构\n\n视图可以控制权限吗：\n可以控制权限的，在使用的时候需要将视图的使用权限grant给用户\n\n哪个VIEW用来判断tablespace的剩余空间DBA_FREE_SPACE\n\n\n\n\n\n当用户进程出错，哪个后台进程负责清理它PMON\n\n\n\nORA-01555的应对方法?\n具体的出错信息是 snapshot too old within rollback seg , 通常可以通过增大 rollback seg来解决问题。当然也需要察看一下具体造成错误的SQL文本\n\ndata block , extent 和 segment的区别（这里建议用英文术语）\ndata block是数据库中最小的逻辑存储单元。当数据库的对象需要更多的物理存储空间时，连续的data block就组成了extent . 一个数据库对象拥有的所有extents被称为该对象的segment.\n\n冷备份和热备份的不同点以及各自的优点\n1.热备份针对归档模式的数据库，在数据库仍旧处于工作状态时进行备份。而冷备份指在数据库关闭后，进行备份，适用于所有模式的数据库。热备份的优点在于当备份时，数据库仍旧可以被使用并且可以将数据库恢复到任意一个时间点。\n2.冷备份的优点在于它的备份和恢复操作相当简单，并且由于冷备份的数据库可以工作在非归档模式下,数据库性能会比归档模式稍好。（因为不必将archive log写入硬盘）\n\n\n冷备份发生在数据库已经正常关闭的情况下，将关键性文件拷贝到另外位置的一种说法\n热备份是在数据库运行的情况下，采用归档方式备份数据的方法\n\n冷备的优缺点：\n是非常快速的备份方法（只需拷贝文件）\n容易归档（简单拷贝即可）\n容易恢复到某个时间点上（只需将文件再拷贝回去）\n能与归档方法相结合，作数据库“最新状态”的恢复。\n低度维护，高度安全。\n\n冷备份不足：\n单独使用时，只能提供到“某一时间点上”的恢复。\n在实施备份的全过程中，数据库必须要作备份而不能作其它工作。也就是说，在冷备份过程中，数据库必须是关闭状态。\n若磁盘空间有限，只能拷贝到磁带等其它外部存储设备上，速度会很慢。\n不能按表或按用户恢复。\n\n热备的优缺点\n可在表空间或数据文件级备份，备份时间短。\n备份时数据库仍可使用。\n可达到秒级恢复（恢复到某一时间点上）。\n可对几乎所有数据库实体作恢复。\n恢复是快速的，在大多数情况下在数据库仍工作时恢复。\n\n热备份的不足是：\n不能出错，否则后果严重。\n若热备份不成功，所得结果不可用于时间点的恢复。\n因难于维护，所以要特别仔细小心，不允许“以失败而告终”。\n\n解释什么是死锁，如何解决Oracle中的死锁？\n简言之就是存在加了锁而没有解锁，可能是使用锁没有提交或者回滚事务，如果是表级锁则不能操作表，客户端处于等在状态，如果是行级锁则不能操作锁定行\n\n解决办法：\n查找出被锁的表select b.owner,b.object_name,a.session_id,a.locked_modefrom v$locked_object a,dba_objects bwhere b.object_id = a.object_id;select b.username,b.sid,b.serial#,logon_timefrom vl o c k e d o b j e c t a , v locked_object a,vlocked objecta,vsession bwhere a.session_id = b.sid order by b.logon_time;\n杀进程中的会话alter system kill session “sid,serial#”;\n\n\n两个检查表结构的方法\n1、 DESCRIBE命令2、  DBMS_METADATA.GET_DDL 包\n\n内连接，左连接，右连接的区别\n1.内连接：指主表，从表中符合连接条件的记录全部显示\n2.左连接：外连接方式，主要是显示主表，从表中符合连接条件的记录，并且主表中所有不符合连接条件的记录也要显示。\n3.右连接：外连接方式，主要是显示主表，从表中所有符合连接条件的记录，并且从表中不符合的记录也要显示。\n\nOracle_Home和Oracle_Base的区别？\nORACLE_BASE是oracle的根目录，ORACLE_HOME是oracle产品的目录。\n\nOracle的导入导出有几种方式，有何区别？使用Oracle工具\n\n使用Oracle工具exp&#x2F;imp\n\ndmp文件方式\n\ndmp文件是二进制的，可以跨平台，并且包含权限，支持大字段数据，是用的最广泛的一种。\n\nsql文件方式\n\nSQL文件可用文本编辑器查看，有利于可读性，但效率不如dmp文件，适合小数据量导入导出。尤其注意的是表中不能有大字段 （blob,clob,long）\n\npde文件\n\npde格式是PL&#x2F;SQL 自带的文件格式，适用于PL&#x2F;SQL工具，编辑器无法查看。\n\n怎样优化Oracle数据库，有几种方式？\n数据库性能最关键的因素在于I&#x2F;O，优化数据库最关键的问题在于减少磁盘的I&#x2F;O，优化Oracle可以分为物理和逻辑两个方面。\n\n物理优化：\nOracle的运行环境（网络，硬件等）使用合适的优化器合理配置oracle实例参数建立合适的索引，减少IO将索引数据和表数据分开在不同的表空间上（降低IO冲突）建立表分区，将数据分别存储在不同的分区上（以空间换取时间，减少IO）\n\n逻辑优化\n可以对表进行逻辑分割如中国移动用户表，可以根据手机尾数分成10个表，这样对性能会有一定的作用对sql语句进行优化:Sql语句使用占位符语句，并且开发时候必须按照规定编写sql语句（如全部大写，全部小写等）oracle解析语句后会放置到共享池中如： select * from Emp where name=? 这个语句只会在共享池中有一条，而如果是字符串的话，那就根据不同名字存在不同的语句，所以占位符效率较好数据库不仅仅是一个存储数据的地方，同样是一个编程的地方，一些耗时的操作，可以通过存储过程等在用户较少的情况下执行，从而错开系统使用的高峰时间，提高数据库性能尽量不使用*号，如select * from Emp，因为要转化为具体的列名是要查数据字典，比较耗时选择有效的表名对于多表连接查询，可能oracle的优化器并不会优化到这个程度， oracle 中多表查询是根据FROM字句从右到左的数据进行的，那么最好右边的表（也就是基础表）选择数据较少的表，这样排序更快速，如果有link表（多对多中间表），那么将link表放最右边作为基础表，在默认情况下oracle会自动优化，但是如果配置了优化器的情况下，可能不会自动优化，所以平时最好能按照这个方式编写sqlWhere字句 规则Oracle 中Where字句时从右往左处理的，表之间的连接写在其他条件之前，能过滤掉非常多的数据的条件，放在where的末尾， 另外!=符号比较的列将不使用索引，列经过了计算（如变大写等）不会使用索引（需要建立起函数）， is null、is not null等优化器不会使用索引使用Exits Not Exits 替代 In Not in合理使用事务，合理设置事务隔离性\n\n数据库的数据操作比较消耗数据库资源的，尽量使用批量处理，以降低事务操作次数\n\n优化的策略一般包括:\n\n内存优化\n操作系统优化\n数据存储的优化\n网络优化等方法\n\n\n具体到不同的数据库涉及到要调整不同的数据库配置文件、不同的操作系统参数、网络参数等等, 不同的数据库不同.\n\nOracle中字符串用什么符号链接\n\n使用符号“||”\n使用CONCAT（）函数进行拼接，Oracle中的concat函数仅支持两个字符串进行拼接，如果要再多，可以嵌套使用。\n\n\nOracle分区是怎样优化数据库的?\nOracle的分区可以分为：列表分区、范围分区、散列分区、复合分区。\n\n增强可用性：如果表的一个分区由于系统故障而不能使用，表的其余好的分区仍可以使用；减少关闭时间：如果系统故障只影响表的一部份分区，那么只有这部份分区需要修复，可能比整个大表修复花的时间更少；维护轻松：如果需要得建表，独产管理每个公区比管理单个大表要轻松得多；均衡I/O：可以把表的不同分区分配到不同的磁盘来平衡I/O改善性能；改善性能：对大表的查询、增加、修改等操作可以分解到表的不同分区来并行执行，可使运行速度更快分区对用户透明，最终用户感觉不到分区的存在\nOracle是怎样分页的？\nOracle中使用rownum来进行分页, 这个是效率最好的分页方法，hibernate也是使用rownum来进行oralce分页的\n\nselect * from   ( select rownum r,a from tabName where rownum &lt;= 20 ) where r &gt; 10\n\nOralce怎样存储文件，能够存储哪些文件？Oracle 能存储 clob、nclob、 blob、 bfileClob 可变长度的字符型数据，也就是其他数据库中提到的文本型数据类型Nclob 可变字符类型的数据，不过其存储的是Unicode字符集的字符数据Blob 可变长度的二进制数据Bfile 数据库外面存储的可变二进制数据\n\n你在项目现场，用户要求你向正在运行的表中添加一个字段，你该怎么做?\n第一种方法：关闭数据库，然后使用受限模式打开，由sys/sysdba来进行\n第二种方法：不关闭数据库，将数据库置于静默状态在SYS/SYSDBA模式下用ALTER SYSTEM QUISCE RESTRICTED，这种状态下只有SYS/SYSDBA才可以对数据库进行操作，修改完毕之后再退出静默状态ALTER SYSTEM UNQUISCE\n在这里复习到了数据库的两种特殊状态：静默状态(QUISCE)和挂起状态\n静默状态就是只有特殊权限的SYS/SYSDBA才可以对数据库进行操作，使用ALTER SYSTEM QUISCE RESTRICTED以后系统将等候活动着的会话主动结束，同时阻止建立新的会话，系统挂起所有的SQL语句，等恢复以后再重新激活会话执行挂起的SQL。\n挂起状态就是系统将数据库所有对物理文件（数据文件，控制文件，日志文件）的I&#x2F;O操作都暂停，但是并不禁止非DBA用户对数据库进行操作。这种状态主要用于进行数据库备份。\n\nOracle中回滚的概念?回滚段有什么作用。\n回滚就是在事务提交之前将数据库数据恢复到事务修改之前数据库数据状态。\n回滚段就是为回滚提供依据，记录的是事务操作数据库之前的数据或者对应于以前操作的操作，这个内容要根据以前的操作而定。\n 比如说以前事务操作如果是UPDATE那么回滚段则存储UPDATE以前的数据，如果事务是DELETE操作那么存储的则是与之相对应的INSERT操作语句，相反如果事务操作是INSERT那么记录相应的则是DELETE操作了。\n\n\n\n执行COMMIT命令时，数据库将会发生什么改变，ROLLBACK呢?\ncommit 提交 时首先是与事务对应的重做日志信息将被写入到数据库物理文件中的重做日志文件中，至于是否会真正将事务操作的内容反映到数据文件还好看DBWR是否启动了。在完成数据库的插入，删除和修改操作时，只有当事务提交到数据库才算完成，有提交前只有操作数据库的本人才能看到，别人只有在最后提交完成才可以看到。ROLLBACK 回滚 当前尚未提交的事务，使数据库恢复到事务操作前的状态。\n\noracle中执行语句错误时去哪里查找错误信息?Select * from USER_ERRORS\n\noracle中有哪些类型的文件?\n数据文件，控制文件，日志文件和数据字典\n\n介绍一下oracle的体系结构?\n逻辑体系结构：块，区，段，表空间物理体系结构：表空间，三大文件软件体系结构：SGA,后台进程\n\n简述ORACLE中SGA的组成部分。\n系统全局区包括：共享池、重做日志缓存区、数据高速缓存区，大池，JAVA池。\n\n\n数据库缓冲区缓存（Database buffer cache）、重做日志缓冲区（redo buffer）、共享池（share pool）、大池（large pool）、Java池（Java pool）、流池（stream pool）\n\n共享池包含：库缓存（library cache）、数据字典缓存数据库缓冲区缓存：存储从数据文件中读取到的数据块重做日志缓冲区：保存重做日志库缓存：存储sql语句解析以及执行计划数据字典缓存：存储解析sql语句以及管理数据库的信息大池：并行操作时、数据库恢复时使用\n\n\n在Oracle表空间的分类和作用，如排序时数据将放在什么表空间?\n作用是为了突破存储容量的限制，是一个逻辑概念。排序数据放在临时表空间。\n\n关于RAC\nRAC集群分为高可用集群和负载均衡集群，下面我将不区分这两个概念，以防迷糊，我下面说的集群直接是指负载均衡集群。\n\n\n所谓集群就是通过配置搭建一个这样的环境，环境中有两个或两个以上的服务器（节点），这些节点上分别运行着同一个服务，对于服务请求，这些节点将均衡请求负载，\n而当一个节点down掉之后，原本在这个节点处理的请求会自动的转移到其他可用的节点上面。而对于用户而言，整个环境内部是透明的，就如同一台服务器一样。这就是集群的概念。\n\n\nGrid\n在oracle 10g中，grid方案的实现所需的软件包含在不同的地方，主要有clusterware集群软件，database中的RAC实现，以及database中dbca建库中的ASM的实现等。到了oracle  11g后，oracle公司讲实现grid的这些个组件整合到了一起，构成了Grid Infrastructure（GI），这样就像clusterware对于集群一样，GI就是用来实现grid的软件。这时候要注意，GI不等于grid。\n\n\nGI主要包括了两个主要部分，即clusterware和ASM，当然还有一些其他组件，比如grid control、data pump等。\n从11gR2开始，如果用户想使用clusterware或者ASM的话，则必须下载安装这个软件。\n\n谈谈对oracle的row_ id是否理解?请简述?\nORACLE的row_id是一个伪列，其个是为18个字节可将这18个字节用6363来划分，分别表示段编号，数据文件编号，数据块编号和记录编号。\nRow_id表示的是一个记录的物理存储地址。\n\ndata guard\nDATA GUARD的最主要的功能是冗灾。当然根据配置的不同,DATA GUARD还可以具备以下特点：高可用、性能提升、数据保护以及故障恢复等。\n\nData Guard运行要求:\n\n1.主机必需运行在归档模式下。2.主备数据库的版本必须一样，操作系统必须一样，版本可不同,主备机可使用不同的目录结构。3.主备机必须都要运行在32位或64位下。4.主库避免nologing的方式，这样会导致备机无法与主机同步。\n\noracle中如何删除用户?\nOracle中使用DROP USER来删除用户如果使用DROP USER CASCADE那么用户的对象也同时被删除掉。为了达到删除用户的效果而又不影响对用户下的对象的使用可以使用alter user username account lock将用户锁定。\n\n客户端对服务器端的oralce操作的流程是什么?专用模式下：用户通过应用程序进程试图去得到一个与ORACLE数据库服务器的连接客户端通过网络传递连接请求，ORACLE服务器则使用监听进程监听用户请求，并且来验证用户身份，通过验证则为用户分配一专用服务进程用户提交SQL语句专用服务进程则首先在SGA区的共享池中检查是否有与该SQL语句相似的已经被解析执行并且缓存的SQL语句，如果有则采用它的解析结果和执行计划执行SQL语句，如果没有则对SQL语句进行语法解析生成执行计划通过解析则执行操作获取数据将执行结果返回给客户。\n共享模式下：与专用模式不同在于当监听程序验证用户的合法性以后并不为它分配一个专用的服务进程，而是将该请求与响应的调度进程相联系起来，并将起放入到一个请求队列中，最终由响应的Dnnn来从调度队列中获取一个请求并为之分配一个空闲的服务进程，接下来有服务进程对该请求进行服务操作和专用方式下相同，处理完成之后由服务进程先将结果放入一个返回队列最后再由调度进程（Dnnn）将返回队列中的结果返回给对应的用户。\n写一个存储过程\n使employee(name,age,emp_no,salary)表中的salary值在0-1000之间的员工的工资上涨20%，（提示：要求用到游标）\n\nCteate or replace procedure emp_salV_name employee.name%type;V_emp_no employee.emp_no%type;V_salary employee.salary%type;Cursor cursor_sal isSelect name,emp_no,salary from employee where salary between 0 and 1000;BeginOpen cursor_sal;LoopFetch cursor_sal into v_name,v_emp_no,v_salary;Exit when cursor_sal%notfound;Update employee set salary=salary*1.2 where name=v_name and emp_no=v_emp_no;End loop;Close cursor_sal;Commit;End;\n\n\n##简述Oracle的归档与不归档工作模式，分别说明。\nOracle归档模式是指在创建数据库时指定了ARCHIVELOG参数，这种模式下，当重做日志文件写满的时候会将该重做日志文件的内容保存到指定的位置（由初始化文件中的参数ARCHIVE_LOG_DEST_n来决定）。并不是数据库在归档模式下工作的时候就可以自动完成归档操作，在归档模式下可以有两种归档方式：自动归档（在初始化文件中的参数ARCHIVE_LOG_START被设置为TRUE）和手动归档。如果归档模式下没有启动自动归档的话，而且又没有实行手动归档那么当LGWR进程将重做日志信息写入已经写满的重做日志文件时数据库将会被挂起直到进行了归档。可见归档是对重做日志文件信息的一种保护措施。Oracle非归档模式下当重做日志文件写满以后若是有LGWR进行重做日志信息的写入操作时，以前保存在重做日志文件中的重做日志信息就会被覆盖掉。\n\n\nOracle索引分为哪几类，说出唯一索引和位图索引的概念。\nOracle索引有B树索引，位图索引，函数索引，簇索引等。\n\n\n唯一索引也是B树索引的一种，它要求被索引的字段值不可以重复。在创建的时候使用B树算法创建。\n位图索引并不是采用象唯一索引那样存储（索引字段值，记录ROWID）来创建索引段的，而是为每一个唯一的字段值创建一个位图，位图中使用位元来对应一个记录的ROWID。位元到ROWID是通过映射的到的。\n\nSQL中，执行四舍五入的是哪个函数?\nRound（value，保留的小数位数）与只对应的还有一个特别相似的函数trunc（value，保留的小数位数）它的作用是根据要保留的小数位数来截取原数。\n\noracle数据库表存放到磁盘什么地方?数据文件\nORACLE数据库的表存放在物理文件中的数据文件中。\n\n当执行insert语句并提交后，这些提交的数据存储到什么地方??\n存储到了数据库的数据文件中。\n\nExits和in在ORALCE数据库中那个执行效率更高?\nEXITS执行效率要比使用IN要快。\n\nDecode函数的用法?DECODE的语法：\nDECODE(value,if1,then1,if2,then2,if3,then3,…,else)，表示如果value等于if1时，DECODE函数的结果返回then1,…,如果不等于任何一个if值，则返回else。\n\n初看一下，DECODE 只能做等于测试，但刚才也看到了，我们通过一些函数或计算替代value，是可以使DECODE函数具备大于、小于或等于功能。\n如何用decode进行大于小于的比较?利用sign()函数和DECODE和在一起用\nselect decode(sign(变量1-变量2),-1,变量1,变量2) from dual;\n\n\ndecode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)该函数的含义如下：\nIF 条件=值1 THENRETURN(翻译值1)ELSIF 条件=值2 THENRETURN(翻译值2)……ELSIF 条件=值n THENRETURN(翻译值n)ELSERETURN(缺省值)END IF\n使用方法：1、比较大小select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; –取较小值sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1\n\n\n例如：\n变量1=10，变量2=20则sign(变量1-变量2)返回-1，decode解码结果为“变量1”，达到了取较小值的目的。\n2、表、视图结构转化\n现有一个商品销售表sale，表结构为：month char(6) –月份sell number(10,2) –月销售金额\n\n现有数据为：200001 1000200002 1100200003 1200200004 1300200005 1400200006 1500200007 1600200101 1100200202 1200200301 1300\n想要转化为以下结构的数据：\nmonth1 number(10,2) –1月销售金额month2 number(10,2) –2月销售金额month3 number(10,2) –3月销售金额month4 number(10,2) –4月销售金额month5 number(10,2) –5月销售金额month6 number(10,2) –6月销售金额month7 number(10,2) –7月销售金额month8 number(10,2) –8月销售金额month9 number(10,2) –9月销售金额month10 number(10,2) –10月销售金额month11 number(10,2) –11月销售金额month12 number(10,2) –12月销售金额\n结构转化的SQL语句为：\ncreate or replace viewv_sale(year,month1,month2,month3,month4,month5,month6,month7,month8,month9,month10,month11,month12)asselectsubstrb(month,1,4),sum(decode(substrb(month,5,2),’01′,sell,0)),sum(decode(substrb(month,5,2),’02′,sell,0)),sum(decode(substrb(month,5,2),’03′,sell,0)),sum(decode(substrb(month,5,2),’04′,sell,0)),sum(decode(substrb(month,5,2),’05′,sell,0)),sum(decode(substrb(month,5,2),’06′,sell,0)),sum(decode(substrb(month,5,2),’07′,sell,0)),sum(decode(substrb(month,5,2),’08′,sell,0)),sum(decode(substrb(month,5,2),’09′,sell,0)),sum(decode(substrb(month,5,2),’10′,sell,0)),sum(decode(substrb(month,5,2),’11′,sell,0)),sum(decode(substrb(month,5,2),’12′,sell,0))from salegroup by substrb(month,1,4);\n\nCASE语句的用法?Oracle用法很简单：\nSELECT last_name, job_id, salaryCASE job_idWHEN ‘IT_PROG’ THEN 1.10salaryWHEN ‘ST_CLERK’ THEN 1.15salaryWHEN ‘SA_REP’ THEN 1.20*salaryELSE salary END “REVISED_SALARY”FROM employees\n\n排他锁(EXCLUSIVE)使用方法：SELECT * FROM order_master WHERE vencode=“V002”FOR UPDATE WAIT 5;LOCK TABLE order_master IN SHARE MODE;LOCK TABLE itemfile IN EXCLUSIVE MODE NOWAIT;\nORACLE锁具体分为以下几类：1.按用户与系统划分，可以分为自动锁与显示锁\n自动锁：当进行一项数据库操作时，缺省情况下，系统自动为此数据库操作获得所有有必要的锁。\n显示锁：某些情况下，需要用户显示的锁定数据库操作要用到的数据，才能使数据库操作执行得更好，显示锁是用户为数据库对象设定的。\n\n2 . 按锁级别划分，可分为共享锁与排它锁\n共享锁：共享锁使一个事务对特定数据库资源进行共享访问——另一事务也可对此资源进行访问或获得相同共享锁。共享锁为事务提供高并发性，但如拙劣的事务设计+共享锁容易造成死锁或数据更新丢失。\n排它锁：事务设置排它锁后，该事务单独获得此资源，另一事务不能在此事务提交之前获得相同对象的共享锁或排它锁。\n\n3.按操作划分，可分为DML锁、DDL锁DML锁又可以分为，行锁、表锁、死锁\n行锁：当事务执行数据库插入、更新、删除操作时，该事务自动获得操作表中操作行的排它锁。\n表级锁：当事务获得行锁后，此事务也将自动获得该行的表锁(共享锁),以防止其它事务进行DDL语句影响记录行的更新。事务也可以在进行过程中获得共享锁或排它锁，只有当事务显示使用LOCK TABLE语句显示的定义一个排它锁时，事务才会获得表上的排它锁,也可使用LOCK TABLE显示的定义一个表级的共享锁(LOCK TABLE具体用法请参考相关文档)。\n死锁：当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就出现死锁。\n\n如事务1在表A行记录#3中有一排它锁，并等待事务2在表A中记录#4中排它锁的释放，而事务2在表A记录行#4中有一排它锁，并等待事务; 1在表A中记录#3中排它锁的释放，事务1与事务2彼此等待，因此就造成了死锁。死锁一般是因拙劣的事务设计而产生。死锁只能使用SQL下:alter system kill session “sid,serial#”；或者使用相关操作系统kill进程的命令，如UNIX下kill -9 sid,或者使用其它工具杀掉死锁进程。\nDDL锁又可以分为：排它DDL锁、共享DDL锁、分析锁\n排它DDL锁：创建、修改、删除一个数据库对象的DDL语句获得操作对象的 排它锁。如使用alter table语句时，为了维护数据的完成性、一致性、合法性，该事务获得一排它DDL锁。\n共享DDL锁：需在数据库对象之间建立相互依赖关系的DDL语句通常需共享获得DDL锁。\n如创建一个包，该包中的过程与函数引用了不同的数据库表，当编译此包时，该事务就获得了引用表的共享DDL锁。\n分析锁：ORACLE使用共享池存储分析与优化过的SQL语句及PL&#x2F;SQL程序，使运行相同语句的应用速度更快。一个在共享池中缓存的对象获得它所引用数据库对象的分析锁。分析锁是一种独特的DDL锁类型，ORACLE使用它追踪共享池对象及它所引用数据库对象之间的依赖关系。当一个事务修改或删除了共享池持有分析锁的数据库对象时，ORACLE使共享池中的对象作废，下次在引用这条SQL&#x2F;PLSQL语句时，ORACLE重新分析编译此语句。\n\n内部闩锁内部闩锁：这是ORACLE中的一种特殊锁，用于顺序访问内部系统结构。当事务需向缓冲区写入信息时，为了使用此块内存区域，ORACLE首先必须取得这块内存区域的闩锁，才能向此块内存写入信息。\n使用oracle 伪列删除表中重复记录Delete table t where t.rowid!=(select max(t1.rowid) from table1 t1 where t1.name=t.name)\n\nOracle 分区在什么情况下使用\n1.当一张表的数据量到达上亿行的时候，表的性能会严重降低，这个时候就需要用到分区了，通过划分成多个小表，并在每个小表上建立本地索引可以大大缩小索引数据文件的大小，从而更快的定位到目标数据来提升访问性能。2.分区除了可以用来提升访问性能外，还因为可以指定分区所使用的表空间，因此也用来做数据的生命周期管理。当前需要频繁使用的活跃数据可以放到访问速度更快但价格也更贵的存储设备上，而2、3年前的历史数据，或者叫冷数据可以放到更廉价、速度更低的设备上。从而降低存储费用。\n\n分区技术有如下优点：\n1、分区技术使数据库的可管理性变得更加容易，如：用户可以往一个单独的分区中装载数据，而对其他分区没有任何影响；用户可以在单独的分区上创建索引等。\n2、分区可以提高表的查询性能，SQL语句的where子句会过滤掉不需要的分区，oracle不会再扫描那些不需要的分区。\n3、分区技术减少数据的不可用时间，用户可以单独维护一个分区中的数据，而不影响其他分区中数据的使用。\n4、分区技术在数据库级完成，几乎不需要对应用程序做任何修改。\n\nOracle提供的分区方法\n范围分区：根据表中列值的范围将整个表分成不同的部分，如按照时间进行范围分区。列表分区：使用列表值将表划分成几部分。散列分区：使用哈希函数把表分成几部分。复合分区：同时使用两种分区方法对表进行分区。\n\n1、范围分区\n就是根据数据库表中某一字段的值的范围来划分分区。\n数据中有空值，Oracle机制会自动将其规划到maxvalue的分区中。\n\n2、散列分区\n根据字段的hash值进行均匀分布，尽可能地实现各分区所散列的数据相等。\n散列分区即为哈希分区，Oracle采用哈希码技术分区，具体分区如何由Oracle说的算，也可能我下一次搜索就不是这个数据了。\n\n3、列表分区\n列表分区明确指定了根据某字段的某个具体值进行分区，而不是像范围分区那样根据字段的值范围来划分的。\n\n4、复合分区\n根据范围分区后，每个分区内的数据再散列地分布在几个表空间中，这样我们就要使用复合分区。复合分区是先使用范围分区，然后在每个分区同再使用散列分区的一种分区方法\n\nOracle创建分区\n既然，Oracle分区有如此好处，我们在这里通过一个例子来讲解如何创建分区。在我们的学生信息系统案例当中，学生成绩表（SCORE）会随着学生的增多和课程的增多，表中的数据量会越来越大，所以可以考虑创建分区表来解决这个问题。\n\nOracle分区也是通过create table命令组成，但是对表进行分区时，得考虑一个字段作为分区建，通常按值的范围来划分分区，所以这里考虑使用成绩的录入时间进行分区。具体代码如下：\n-- Create tablecreate table STUDENT.SCORE(  scoreid  VARCHAR2(18) not null,  stuid    VARCHAR2(11),  courseid VARCHAR2(9),  score    NUMBER,  scdate   DATE)partition by range(scdate)(partition p_score_2018 values less than (TO_DATE(&#x27;2019-01-01 00:00:00&#x27;,&#x27;yyyy-mm-ddhh24:mi:ss&#x27;)) TABLESPACE TS_2018,partition p_score_2019 values less than (TO_DATE(&#x27;2020-01-01 00:00:00&#x27;,&#x27;yyyy-mm-ddhh24:mi:ss&#x27;)) TABLESPACE TS_2019,partition p_score_2020 values less than (MAXVALUE) TABLESPACE TS_2020);-- Add comments to the table comment on table STUDENT.SCORE  is &#x27;学生成绩表&#x27;;-- Add comments to the columns comment on column STUDENT.SCORE.scoreid  is &#x27;学生成绩id&#x27;;comment on column STUDENT.SCORE.stuid  is &#x27;学生学号&#x27;;comment on column STUDENT.SCORE.courseid  is &#x27;课程id(年度+上下学期+课程序列)&#x27;;comment on column STUDENT.SCORE.score  is &#x27;成绩&#x27;;comment on column STUDENT.SCORE.scdate  is &#x27;成绩录入时间&#x27;;-- Create/Recreate primary, unique and foreign key constraints alter table STUDENT.SCORE  add constraint PK_SCORE primary key (SCOREID)  using index   tablespace USERS  pctfree 10  initrans 2  maxtrans 255  storage  (    initial 64K    next 1M    minextents 1    maxextents unlimited  );\n\n这里使用命令partition by range对成绩的录入日期（scdate）进行分区，如录入日期小于2019年的会被放入分区p_score_2018当中，2019年数据会被放入p_score_2019这个分区当中，大于2019年数据都会被放入到p_score_2020这个分区当中。\n\n这里不必为最后一个分区指定最大值，maxvalue关键字会告诉Oracle使用这个分区来存储前面几个分区当中不能存储的数据。\n上面实例展示的是Oracle按照值的范围进行分区，Oracle还支出散列分区，通过某一个字段，把表中的数据散列在各个分区中。可以通过关键字partition by hash，可以把分区散列到不同的表空间当中。\nOracle还支持列表分区（partition by list），它是通过按照指定分区建的值归并到各个分区，其实这里学生成绩表也可以考虑按照课程进行列表分区。\n\n总结：Oracle分区对大型表（数据量大）有重大的性能提升，所以在表结构设计时，需要提前按照相关业务需求进行相应的改进。\n\n","categories":["技术"],"tags":["技术","心得","oracle/mysql"]},{"title":"关于Oracle归档模式","url":"/2021/10/06/%E5%85%B3%E4%BA%8EOracle%E5%BD%92%E6%A1%A3%E6%A8%A1%E5%BC%8F/","content":"oracle11g查看开启归档,oracle11g 开启归档模式请按顺序进行\n1、查看是不是归档方式archive log list;\n\n2、关闭数据库shutdown immediate;\n3、启动数据库至mount状态这里不打开数据文件\nstartup mount;\n4、设置修改归档路径路径中的目录需要提前用mkdir命令创建\n# 创建归档目录mkdir -p /oracle/oradata/archchown -R oracle:oinstall /oracle/oradata/arch# 单个目录alter system set log_archive_dest=&quot;/oracle/oradata/arch&quot; scope=spfile;     --或者alter system set log_archive_dest_1=&quot;location=/oracle/oradata/arch&quot; scope=spfile;\n\n5、设置归档日记格式alter system set log_archive_format=&quot;arch_%d_%t_%s.arc&quot; scope=spfile;%s: 日志序列号:%S: 日志序列号(带有前导)%t: 重做线程编号.%T: 重做线程编号(带有前导)%a: 活动ID号%d: 数据库ID号%T 年月日格式(YYYYMMDD)\n\n6、归档进程数alter system set log_archive_max_processes = 5;\n\n7、将数据库切换为归档模式alter database archivelog;\n\n8、将数据文件打开alter database open;\n\n9、查看此时是否处于归档模式archive log list;\n\n10、切换在线日志，验证归档是否正常alter system switch logfile;\n\n进入linux操作系统，可以查找到归档日志文件\n\ncd /oracle/oradata/archlsarch_db216e6_1_1128542246_86.log\n\n\n11、可选项，可以防止数据库密码180失效alter profile default limit password_life_time unlimited;\n\n\n配置完归档模式以后我们可以立即执行归档重做日志：\n\n注意：\n1、如果没有重启数据库，归档日志的文件格式仍然会是默认的格式.dbf。\n2、alter system switch logfile 是强制日志切换，不一定就归档当前的重做日志文件(若自动归档打开，就归档前的重做日志，若自动归档没有打开，就不归档当前重做日志。\n3、alter system archive log current 是归档当前的重做日志文件，不管自动归档有没有打都归档。 主要的区别在于：alter system switch logfile 对单实例数据库或RAC中的当前实例执行日志切换；\n\nalter system archive log current --会对数据库中的所有实例执行日志切换。\n\n\n此时我们到刚才的 &#x2F;archive 路径下面去查看是否已经生成了归档日志：\n\n\n\n修改完所有参数后执行shutdown immediate;然后再startup;就可以投入生产了\n\n切换为非归档模式1、sql&gt; archive log list;  #查看是否是归档方式2、sql&gt; alter system set log_archive_start=false scope=spfile; #禁用自动归档3、sql&gt; shutdown immediate;4、sql&gt; startup mount;    #打开控制文件，不打开数据文件5、sql&gt; alter database noarchivelog; #将数据库切换为非归档模式6、sql&gt; alter database open;  #将数据文件打开7、sql&gt; archive log list;  #查看此时便处于非归档模式\n\n\n归档相关命令\narchive log stop;\narchive log start;\narchive log list;\nshow parameters;\nshow parameters log_archive_start;\nshow parameters log_archive_max_process; #归档进程数\nalter system set log_archive_max_process&#x3D;5; #将归档进程数改为5\nselect * from v$bgprocess;    #检察后台进程\n\n","categories":["技术"],"tags":["技术","linux","oracle","心得"]},{"title":"hexo介绍","url":"/2020/06/06/%E5%85%B3%E4%BA%8Ehexo/","content":"hexo介绍：Hexo 是一个快速、简洁且高效的博客框架Hexo官网文档：https://hexo.io/zh-cn/docs/configuration\n1、安装先安装 node.js和Git利用npm安装hexo \n$ npm install -g hexo-cli\n\n\n2、建站安装hexo之后，执行以下命令，hexo将会在指定的文件夹中新建所需的文件：\n$ hexo init &lt;blog&gt;  $ cd &lt;blog&gt;  $ npm install\n\n新建完成后，指定文件夹的目录如下：\n\n3、配置修改配置Config.yml参数：\n1.网站：\n\n\n参数\n描述\n\n\n\ntitle\n网站标题\n\n\nsubtitle\n网站副标题\n\n\ndescription\n网站描述（主要用于seo\n\n\nauthor\n您的名字\n\n\nlanguage\n网站使用的语言\n\n\ntimezone\n网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC\n\n\n2.网址：\n\n\n参数\n描述\n默认值\n\n\n\nurl\n网址\n\n\n\nroot\n网站根目录\n\n\n\npermalink\n文章的 永久链接 格式\n:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;\n\n\npermalink_defaults\n永久链接中各部分的默认值\n\n\n\n3.目录：\n\n\n参数\n描述\n默认值\n\n\n\nsource_dir\n资源文件夹，这个文件夹用来存放内容。\nsource\n\n\npublic_dir\n公共文件夹，这个文件夹用于存放生成的站点文件。\npublic\n\n\ntag_dir\n标签文件夹\ntags\n\n\narchive_dir\n归档文件夹\narchives\n\n\ncategory_dir\n分类文件夹\ncategories\n\n\ncode_dir\nInclude code 文件夹\ndownloads&#x2F;code\n\n\ni18n_dir\n国际化（i18n）文件夹\n:lang\n\n\nskip_render\n跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n\n\n4.文章：\n\n\n参数\n描述\n默认值\n\n\n\nnew_post_name\n新文章的文件名称\n:title.md\n\n\ndefault_layout\n预设布局\npost\n\n\nauto_spacing\n在中文和英文之间加入空格\nfalse\n\n\ntitlecase\n把标题转换为 title case\nfalse\n\n\nexternal_link\n在新标签中打开链接\ntrue\n\n\nfilename_case\n把文件名称转换为 (1) 小写或 (2) 大写\n0\n\n\nrender_drafts\n显示草稿\nfalse\n\n\npost_asset_folder\n启动 Asset 文件夹\nfalse\n\n\nrelative_link\n把链接改为与根目录的相对位址\nfalse\n\n\nfuture\n显示未来的文章\ntrue\n\n\nhighlight\n代码块的设置\n\n\n\n5.分类、标签\n\n\n参数\n描述\n默认值*\n\n\n\ndefault_category\n默认分类\nuncategorized\n\n\ncategory_map\n分类别名\n\n\n\ntag_map\n标签别名\n\n\n\n6.日期、时间格式：\n\n\n参数\n描述\n默认值\n\n\n\ndate_format\n日期格式\nYYYY-MM-DD\n\n\ntime_format\n时间格式\nH:mm:ss\n\n\n7.分页：\n\n\n参数\n描述\n默认值\n\n\n\nper_page\n每页显示的文章量 (0 &#x3D; 关闭分页功能)\n10\n\n\npagination_dir\n分页目录\npage\n\n\n8.扩展：\n\n\n参数\n描述\n\n\n\ntheme\n当前主题名称。值为false时禁用主题\n\n\ndeploy\n部署部分的设置\n\n\n4、指令\nnpm install hexo -g #安装Hexonpm update hexo -g #升级hexo init#初始化博客\n\n命令简写：\n// 新建文章 hexo new &quot;我的博客&quot; hexo n &quot;我的博客&quot; // 简写// 生成静态文件 hexo generatehexo g // 简写// 启动服务预览hexo server hexo s // 简写// 部署hexo deployhexo d // 简写\n\n\nhexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n\n5、Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: hello worlddate: 2020/3/12 10:10:19---\n\n\n在json也可以编写front-matter，只需要将—-改为；；；就即可：\n&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;;\n\n参数：\n\n\n\n参数\n描述\n默认值\n\n\n\nlayout\n布局\n\n\n\ntitle\n标题\n\n\n\ndate\n建立日期\n文件建立日期\n\n\nupdated\n更新日期\n文件更新日期\n\n\ncomments\n开启文章的评论功能\ntrue\n\n\ntags\n标签（不适用于分页）\n\n\n\ncategories\n分类（不适用于分页）\n\n\n\npermalink\n覆盖文章网址\n\n\n\n注意：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。例子：\ncategories:- Diarytags:- PS3- Games\n\n\n  categories:  - Diary  - Life\n\nCategories有层级之分，life成为diary的子分类，而不是同级\n6、标签插件\n7、资源文件夹资源asset代表source文件中除文章以外的所有文件。\n1.文件资源文件夹\nConfig.yml文件中的post-asset-folder选项设为true打开之后，则每一次新建文章时都会自动创建一个与文章名字相同的文件夹，可将所有与文章有关的资源放在此文件夹中，之后可通过相对路径来引用。\n\n2.相对路径引用的标签插件通过常规的markdown语法和相对路径引用图片和其他资源可能会导致它们在存档或者主页显示不正确。\n\n[图片上传失败…(image-914568-1585130729432)] 此种方式图片不会出现在首页。\n\n例子：通过这种方式图片将会同时出现在文章和主页以及归档页中\n&#123;% asset_img example.jpg This is an example image %&#125;\n\n8、数据文件当需要在主题中使用某些资料，而这些资料不在文章内，并且需要重复使用时可以使用hexo3.0新增的数据文件功能。此功能会载入source&#x2F;_data内的yml或json文件，如此便能在网站中复用这些文件。\n9、服务器1.Hexo-serverHexo3.0把服务器独立成了个别模块，必须先安装hexo-server才能使用。\n$ npm install hexo-server --save\n\n安装完成后输入以下命令以启动服务器，网站会在http://localhost：4000下启动。在服务器启动期间，hexo会监视文件变动并自动更新，无需重启服务器。\n$ hexo server\n\n如果想要修改端口，或是在执行时遇到看EADDRINUSE错误，可以在执行时使用-p选项指定其他端口，如下：\n$ hexo server -p 5000\n\n2.静态模式在静态模式下，服务器只处理public文件夹内的文件，而不会处理文件变动，在执行时，应该先执行hexo generate，此模式通常用于生产环境（production mode）下：\n$ hexo server -s\n\n3.自定义IP服务器默认运行在0.0.0.0，您可以覆盖默认的IP设置。指定这个参数后，您就只能通过该IP才能访问站点。如下：\n$ hexo server -i 192.168.1.1\n\n4.powpow是一个Mac系统上的零配置Rack服务器，它也可以作为一个简单易用的静态文件服务器来使用。\n$ curl get.pow.cx | sh\n\n设置：在~&#x2F;.pow文件夹建立链接（symlink）。\n$ cd ~/.pow$ ln -s /path/to/myapp\n\n网站将会在 http://myapp.dev 下运行，网址根据链接而定\n10、生成文件使用hexo生成静态文件快速而且简单：\n$ hexo generate\n\n\n1.监视文件变动Hexo能够监视文件变动并立即重新生成静态文件，在生成时会比对文件SHA1 checksum，只有变动文件才会写入。\n$ hexo generate --watch\n\n2、完成后部署$ hexo g -d$ hexo d -g\n\n11、部署1.Hexo提供了快速方便的一键部署功能，只需要一条命令就能将网站部署到服务器上：$ hexo deploy\n\n在开始之前，必须先在_config.yml中修改参数，一个正确的部署配置中至少要有type餐数，例如：可同时使用多个deployer，hexo会按顺序执行。\n deploy:- type: git repo:- type: heroku repo:\n2.Git安装hexo-deployer-git\n$ npm install hexo-deployer-git --save\n\n修改参数：\n deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] #published message: [message]\n\nrepo：库（Repository）地址；branch：分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测；\n3.heroku安装hexo-deployer-heroku：\n$ npm install hexo-deployer-heroku --save\n\n修改配置：\n deploy: type: heroku repo: &lt;repository url&gt; message: [message]\n\n\n4.Netlify\nNetlify是一个提供网络托管的综合平台。它集持续集成（CI）CDN自定义域名HTTPS持续部署（CD）等诸多功能于一身。\n\n通过以下两种方式将hexo站点部署到netlify：\n1、使用Netlify提供的网页端用户界面，前往新建一个网站页面，选择需要关联的Github&#x2F;BitBucket&#x2F;Gitlab库，然后遵循网站提示。2、使用Netlify提供的命令客户端工具Node based CLI管理和部署你的站点。\n\n此外还可以在项目的readme中增加一个部署至Netlify按钮，这样其他用户在fork或clone了你的项目之后可以方便快捷的一键部署。\n\n5.Rsync安装hexo-deployer-rsync\n$ npm install hexo-deployer-rsync --save\n\n修改配置\n deploy: type: rsync host: &lt;host&gt; user: &lt;user&gt; root: &lt;root&gt; port: [port] delete: [true|false] verbose: [true|false] ignore_errors: [true|false]\n\nhost：远程主机的地址user：使用者名称root：远程主机的根目录port：端口，默认值：22delete：删除远程主机上的旧文件，默认值：trueverbose：显示调试信息，默认值：trueignore_errors：忽略错误falsersync部署模块的工作方式：需要在远程的主机上为hexo站点建立一个用户，并允许其通过SSH登陆。\n6.openShift安装hexo-deployer-openshift\n$ npm install hexo-deployer-openshift --save\n\n修改配置\n deploy: type: openshift repo: &lt;repository url&gt; message: [message]\n \n7.FTPSync安装hexo-deployer-ftpsync\n$ npm install hexo-deployer-ftpsync --save\n\n修改配置\n deploy: type: ftpsync host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remote: [remote] port: [port] ignore: [ignore] connections: [connections] verbose: [true|false]\n\n\n\n\n\n\n\n参数\n描述\n默认值\n\n\n\nhost\n远程主机的地址\n\n\n\nuser\n使用者名称\n\n\n\npass\n密码\n\n\n\nremote\n远程主机的根目录\n&#x2F;\n\n\nport\n端口\n21\n\n\nignore\n忽略的文件或目录\n\n\n\nconnections\n使用的连接数\n1\n\n\nverbose\n显示调试信息\nfalse\n\n\nFTP部署可能出现的问题：需要预先通过其他方式将所有文件上传到远程主机中。否则初次使用ftpsync插件就可能出现报错。另外，由于ftp协议的特征，它每传送一个文件就需要一次握手，相对速度较慢。\n8.SFTP安装hexo-deployer-sftp\n$ npm install hexo-deployer-sftp --save\n\n修改配置：\n deploy: type: sftp host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remotePath: [remote path] port: [port] privateKey: [path/to/privateKey] passphrase: [passphrase] agent: [path/to/agent/socket]\n\n\n\n\n\n参数\n描述\n默认值\n\n\n\nhost\n远程主机的地址\n\n\n\nuser\n使用者名称\n\n\n\npass\n密码\n\n\n\nremotePath\n远程主机的根目录\n&#x2F;\n\n\nport\n端口\n22\n\n\nprivateKey\nssh私钥的目录地址\n\n\n\npassphrase\n（可省略）ssh私钥的密码短语\n\n\n\nagent\nssh套接字的目录地址\n$SSH_AUTH_SOCK\n\n\n","categories":["技术"],"tags":["技术","心得"]},{"title":"卸载rac重新安装","url":"/2021/06/07/%E5%8D%B8%E8%BD%BDrac%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/","content":"清除ocr and voting使用过的raw device  (bs的单位是字节)dd if=/dev/zero of=/dev/raw/raw1 bs=104857600 count=1dd if=/dev/zero of=/dev/raw/raw2 bs=104857600 count=1清除disk group使用的partitiondd if=/dev/zero of=/dev/sdb1 bs=1024k count=200dd if=/dev/zero of=/dev/sdc1 bs=1024k count=200dd if=/dev/zero of=/dev/sdd1 bs=1024k count=200rm  -rf -rf /home/oracle/oracle/*rm  -rf /etc/rc.d/rc5.d/S96init.crsrm  -rf /etc/rc.d/init.d/init.crsrm  -rf /etc/rc.d/rc4.d/K96init.crsrm  -rf /etc/rc.d/rc6.d/K96init.crsrm  -rf /etc/rc.d/rc1.d/K96init.crsrm  -rf /etc/rc.d/rc0.d/K96init.crsrm  -rf /etc/rc.d/rc2.d/K96init.crsrm  -rf /etc/rc.d/rc3.d/S96init.crsrm  -rf /etc/oracle/*rm  -rf /etc/oraInst.locrm  -rf /etc/oratabrm  -rf /usr/local/bin/coraenvrm  -rf /usr/local/bin/dbhomerm  -rf /usr/local/bin/oraenvrm -f /etc/init.d/init.cssdrm -f /etc/init.d/init.crsrm -f /etc/init.d/init.crsdrm -f /etc/init.d/init.evmdrm -f /etc/rc2.d/K96init.crsrm -f /etc/rc2.d/S96init.crsrm -f /etc/rc3.d/K96init.crsrm -f /etc/rc3.d/S96init.crsrm -f /etc/rc5.d/K96init.crsrm -f /etc/rc5.d/S96init.crsrm -f /etc/inittab.crsmv /etc/inittab /etc/inittab_bakcp /etc/inittab.orig /etc/inittabcd /opt/oracrsrm -rf ./*cd /opt/oraclerm -rf ./*rm -rf /etc/ora*--crs是crs的主目录，crs安装完以后，其owner被改成了root，重装的时候需要改成oraclechown oracle.oinstall /crs\n","categories":["软件教程"],"tags":["技术","linux","oracle","心得"]},{"title":"数仓分层思想和作用","url":"/2022/01/06/%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E5%92%8C%E4%BD%9C%E7%94%A8/","content":"数据仓库理论知识1.为什么要分层分层的主要原因是在管理数据的时候，能对数据有一个更加清晰的掌控，主要有下面几个原因：\n清晰的数据结构：\n每一个数据分层都有它的作用域，这样我们在使用表的时候能更方便地定位和理解\n\n数据血缘追踪：\n简单来说，我们最终给业务呈现的是一个能直接使用业务表，但是它的来源有很多，如果有一张来源表出问题了，我们希望能够快速准确地定位到问题，并清除它的危害范围。\n\n减少重复开发：\n规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算。\n\n把复杂问题简单化：\n将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。\n\n屏蔽原始数据的异常：\n屏蔽业务的影响，不必改一次业务就需要重新接入数据\n\n\n2.数仓分层思想\n数据分层每个企业根据自己的业务需求可以分成不同的层次，但是最基础的分层思想，理论上数据分为三个层，数据运营层、数据仓库层和数据服务层。基于这个基础分层之上添加新的层次，来满足不同的业务需求。\n\n数据运营层（ODS）Operate data store，操作数据存储，是最接近数据源中数据的一层，数据源中的数据，经过抽取、清洗、传输，也就是ETL之后，装入本层。本层的数据，总体上大多是按照源头业务系统的分类方式而分类的。\n\n例如: Mysql里面的一张表可以通过sqoop之间抽取到ODS层\n\nODS层数据的来源方式\n业务库\n经常会使用sqoop来抽取，比如我们每天定时抽取一次。在实时方面，可以考虑用canal监听mysql的binlog，实时接入即可。\n\n\n埋点日志\n线上系统会打入各种日志，这些日志一般以文件的形式保存，我们可以选择用flume定时抽取，也可以用spark streaming或者Flink来实时接入，当然Kafak也会是一个关键的角色。\n\n\n消息队列\n来自ActiveMQ Kafka的数据等\n\n\n\n\n数据仓库层（DW）\nData warehouse,数据仓库层。在这里，从ODS层中获得的数据按照主题建立各种数据模型。例如以研究人的旅游消费为主题的数据集中，便可以结合航空公司的登机出行信息，以及银联系统的刷卡记录，进行结合分析，产生数据集。在这里，我们需要了解四个概念：维（dimension）、事实（Fact）、指标（index）和粒度（Granularity）。\n\n应用层 （ADS）\n该层主要是提供数据产品和数据分析使用的数据，一般会存放在ES\\MYSQL等系统中供线上系统使用，也可能会存在Hive或者Druid中供数据分析和数据挖掘使用。例如： 我们经常说的报表数据，或者说那种大宽表，一般就放在这里。\n\n1. ODS 数据准备层功能：\n\nODS层是数据仓库准备区，为DWD层提供基础原始数据，可减少对业务系统的影响\n\n建模方式及原则：\n\n从业务系统增量抽取，保留时间由业务需求决定，可分表进行周期存储，数据不做清洗转换与业务系统数据模型保持一致，按主题逻辑划分。\n\n\n2. DWD 数据明细层功能：\n\n为DW层提供来源明细数据，提供业务系统细节数据的长期沉淀，为未来分析类需求的扩展提供历史数据支撑\n\n建模方式及原则：\n\n数据模型与ODS层一致，不做清洗转换处理，为支持数据重跑可额外增加数据业务日期字段，可按年月日进行分表，用增量ODS层数据和前一天DWD相关表进行merge处理\n\n\n3. DW(B&#x2F;S) 数据汇总层功能：\n\n为DW&#x2F;ST层提供细粒度数据，细化成DWB和DWS；\nDWB是根据DWD明细数据进行转换，如维度转代理键、身份证清洗、会员注册来源清晰、字段合并、空值处理、脏数据处理、IP清晰转换、账号余额清洗、资金来源清洗等；\nDWS是根据DWB层数据按各个维度ID进行高粒度汇总聚合，如按交易来源，交易类型进行汇合\n\n建模方式及原则：\n\n聚合汇总增加派生事实；\n\n关联其它主题的事实表，DW层可能会跨主题域；\n\nDWB保持低粒度汇总加工数据，DWS保持高粒度汇总数据；\n\n数据模型可能采用反范式设计，合并信息等。\n\n\n\n4. DM 数据集市层功能：\n\n可以是一些宽表，是根据DW层数据按照各种维度或多种维度组合把需要查询的一些事实字段进行汇总统计并作为单独的列进行存储；\n满足一些特定查询，数据挖掘应用；\n应用集市数据存储\n\n建模方式及原则：\n\n尽量减少数据访问时计算，优化检索；\n维度建模，星型模型；\n事实拉宽，度量预先计算；\n分表存储\n\n\n5. ST 数据应用层（ADS层）功能：\n\nST层面向用户应用和分析需求，包括前端报表、分析图表、KPI仪表盘、OLAP专题等分析，面向最终结果用户；\n适合作OLAP 报表模型，如ROLAP,MOLAP;\n根据DW层经过聚合汇总统计后的粗粒度事实表\n\n建模方式及原则：\n\n保持数据量小；\n维度建模，星型建模；\n各位维度代理键+度量；\n增加数据业务日期字段，支持数据重跑；\n不分表存储\n\n\n3.数仓中表的种类及其概念\n一般情况下，表分为两个类型，分别是维度表和事务表\n\n1. 维度表\n 维度表: 一般是指对应的一些业务状态，代码的解释表。也可以称之为码表。比如地区表，订单类型，支付方式，商品分类等等。\n\n\n维度表可以分为两类: 一般维度表和固定维度表\n一般维度表的数据是不断增加和变化的\n固定维度表的数据是不变的\n\n\n\n2. 事务表\n事务表分为两类：事务型事实表和周期型事实表\n事务型事实表：一般指随着业务发生不断产生的数据。特点是一旦发生不会再变化。一般比如，交易流水，操作日志，出库入库记录等等。\n周期型事实表，一般指随着业务发生不断产生的数据。与事务型不同的是，数据会随着业务周期性的推进而变化。比如订单，其中订单状态会周期性变化。再比如，请假、贷款申请，随着批复状态在周期性变化。\n\n\n\n\n4.数仓中表的同步策略1. 维度表\n可能会有变化的数据可以存储每日全量或者使用拉链表。（比如订单类型、审批状态、商品分类）\n\n2. 事实表事务型事实表\n每日增量：因为数据不会变化，而且数据量巨大，所以每天只同步新增数据即可；每日分区。\n\n周期型事实表\n每日全量：首先这类表从数据量的角度，存每日全量的话，数据量太大，冗余也太大\n每日增量：如果用每日增量的话无法反映数据变化；每日新增及变化量可以用，包括了当日的新增和修改。一般来说这个表，足够计算大部分当日数据的。但是这种依然无法解决能够得到某一个历史时间点(时间切片)的切片数据。\n拉链表：利用每日新增和变化表，制作一张拉链表，以方便的取到某个时间切片的快照数据。所以我们需要得到每日新增及变化量。\n\n","categories":["技术"],"tags":["技术","心得"]},{"title":"道德真经","url":"/2019/06/06/%E8%80%81%E5%AD%90%E4%BA%94%E5%8D%83%E6%96%87/","content":"老子\n《老子》，又称《道德真经》《道德经》《五千言》《老子五千文》，是中国古代先秦诸子分家前的一部著作，为其时诸子所共仰，传说是春秋时期的老子李耳(似是作者、注释者、传抄者的集合体)所撰写，是道家哲学思想的重要来源。道德经分上下两篇，原文上篇《德经》、下篇《道经》，不分章，后改为《道经》37章在前，第38章之后为《德经》，并分为81章。是中国历史上首部完整的哲学著作。 【国学经典】老子道德经全文翻译(全81章) \n\n\n【第一章】道可道，非常道。名可名，非常名。无名天地之始；有名万物之母。故常无，欲以观其妙；常有，欲以观其徼。此两者，同出而异名，同谓之玄。玄之又玄，众妙之门。　　\n\n【翻译】： 道可以说，但不是通常所说的道。名可以起，但不是通常所起的名。可以说他是无，因为他在天地创始之前;也可以说他是有，因为他是万物的母亲。所以，从虚无的角度，可以揣摩他的奥妙。从实有的角度，可以看到他的踪迹。实有与虚无只是说法不同，两者实际上同出一源。这种同一，就叫做玄秘。玄秘而又玄秘啊!宇宙间万般奥妙的源头。 　　\n\n【第二章】天下皆知美之为美，斯恶已。皆知善之为善，斯不善已。有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。恒也。是以圣人处无为之事，行不言之教；万物作而弗始，生而弗有，为而弗恃，功成而不居。夫唯弗居，是以不去。 　　\n\n【翻译】：1 天下的人都知道以美为美，这就是丑了。都知道以善为善，这就是恶了。2 有和无是相互依存的，难和易是相互促成的，长和短互为比较，高和下互为方向，声响和 回音相呼应，前边与后边相伴随。 　　3 所以，圣人从事的事业，是排除一切人为努力的事业;圣人施行的教化，是超乎一切言语 之外的教化。 他兴起万物却不自以为大，生养而不据为己有，施予而不自恃其能，成了也不自居其功。他不自居其功，其功却永恒不灭。 　　\n\n【第三章】不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。是以圣人之治，虚其心，实其腹，弱其志，强其骨。常使民无知无欲。使夫智者不敢为也。为无为，则无不治。　　\n\n【翻译】： 不崇尚贤能之辈，方能使世人停止争斗。不看重珍奇财宝，方能使世人不去偷窃。不诱发邪情私欲，方能使世人平静安稳。所以，圣人掌管万民，是使他们心里谦卑，腹里饱足，血气淡化，筋骨强壮。人们常常处于不求知、无所欲的状态，那么，即使有卖弄智慧的人，也不能胡作非为了。遵从无为之道，则没有不太平之理。 　　\n\n【第四章】道冲，而用之或不盈。渊兮，似万物之宗；湛兮，似或存。吾不知谁之子，象帝之先。　\n\n【翻译】： 道，空虚无形，其大能却无穷无尽，渊远深奥啊，像是万物的祖宗。放弃自以为是的锐气，摆脱纷纭万象的迷惑，和于你生命的光中，认同你尘土的本相，你 便能在幽幽之中，看到他那似有似无的存在。我不知道有谁产生他，他先于一切有形之帝。\n\n【第五章】天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。天地之间，其犹橐龠乎？虚而不屈，动而愈出。多言数穷，不如守中。　　\n\n【翻译】： 天地不理会世上所谓的仁义，在其看来，万物是祭神用的稻草狗。圣人也不理会世 上所谓的仁义，在他眼里，百姓是祭神用的稻草狗。 天地之间，不正像一个冶炼的风箱吗?虚静而不穷尽，越动而风越多。话多有失，辞不达意，还是适可而止为妙。 　　\n\n【第六章】谷神不死，是谓玄牝。玄牝之门，是谓天地根。绵绵若存，用之不勤。 　\n\n【翻译】：幽悠无形之神，永生不死，是宇宙最深远的母体。这个母体的门户，便是天地的根源。冥冥之中，似非而是，延绵不绝，用之不尽。 \n\n【第七章】天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先;外其身而身存。非以其无私邪?故能成其私。\n\n【翻译】： 天长地久。天地之所以能长久，因为它不自贪自益其生，所以能长生。同理，圣人把自己置于最后，他反而在前;把自身置之度外，他反而长存。这不正是由于他无私，反而成全了他的私吗? 　　\n\n【第八章】上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，政善治，事善能，动善时。夫唯不争，故无尤。 　　\n\n【翻译】： 最高的善像水一样。水善于滋养万物，而不与万物相争。它处身于众人所厌恶的地方，所以跟道很相近。居身，安于卑下;存心，宁静深沉;交往，有诚有爱;言语，信实可靠;为政，天下归 顺;做事，大有能力;行动，合乎时宜。唯有不争不竞，方能无过无失。 　　\n\n【第九章】持而盈之，不如其已；揣而锐之，不可长保。金玉满堂，莫之能守；富贵而骄，自遗其咎。功遂身退，天之道也。　\n\n【翻译】：抓在手里冒尖儿流，自满自溢，不如罢了吧。千锤百炼的锋芒，也长不了的。金玉满堂，你能守多久呢? 富贵而骄，是自取灾祸啊! 　　大功成了，名份有了，自己便隐去，这正是上天之道。 　　\n\n【第十章】载营魄抱一，能无离乎？专气致柔，能如婴儿乎？涤除玄鉴，能如疵乎？爱国治民，能无为乎？ 天门开阖，能为雌乎？明白四达，能无知乎？ 生之蓄之，生而不有，为而不恃，长而不宰，是谓玄德。　\n\n【翻译】： 谁能使灵魂与真道合一，毫无离隙呢?谁能使血气变得柔顺，像婴儿一样呢?谁能洗净内心的杂念，透亮如明镜呢? 爱民掌权，谁能舍己顺道、无为而治呢? 运用心智，谁能因应天意、如雌随雄呢?明白通达，谁能超越人智、摆脱知识呢?那创造并养育这个世界的，他创造养育并不强行占有，他无所不为却不自恃其能，他是万 物之主而不任意宰制。这真是深不可测的恩德啊! 　\n\n【第十一章】三十辐，共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。 　　\n\n【翻译】：三十根辐条集中在车轴穿过的圆木上，圆木有空的地方，才对车有用处(可行走)。揉合黏土制成器皿，上面有空的地方，才有器皿的用处(能容纳)。为房屋安窗户，窗户有空的地方，才对房屋有用处(取光亮)。有形者对人们有利益，是由于无形者的功用啊。\n\n【第十二章】五色令人目盲；五音令人耳聋；五味令人口爽；驰骋畋猎，令人心发狂；难得之货，令人行妨。是以圣人为腹不为目，故去彼取此。 　　\n\n【翻译】：缤纷的色彩使人眼睛昏花，变幻的音响使人耳朵发聋，丰腴的美食使人口味败 坏，驰骋打猎令人心意狂荡，珍奇财宝令人行为不轨。所以圣人掌管万民，是给他们内在的充实，不是给他们外在的愉悦。据此而取舍。\n\n【第十三章】宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患？故贵以身为天下，若可寄天下；爱以身为天下，若可托天下。　　\n\n【翻译】：得宠和受辱都会内心不安，最大的祸患是看重肉身性命。 　　为什么说得宠和受辱都会内心不安呢?宠是来自上面的，得到时吃惊，失去时也吃惊，所 以说得宠和受辱都会内心不安。为什么说最大的祸患是看重肉身性命呢?我有大祸患之忧虑，是因为我有肉身性命要保全;及至我把肉身性命置之度外，我还有什么祸患可忧虑呢? 所以，舍弃肉身性命去为天下的人，堪为普天下的寄托;舍弃肉身性命去爱天下的人，堪得普天下的信靠。 　　\n\n【第十四章】视之不见，名曰夷；听之不闻，名曰希；搏之不得，名曰微。此三者不可致诘，故混而为一。其上不曒，其下不昧。绳绳兮不可名，复归于物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随之不见其后。执古之道，以御今之有。能知古始，是谓道纪。　　\n\n【翻译】： 看见而不晓得，叫做”夷”;听到而不明白，叫做”希”;摸索而不可得，叫做 “微”。”夷希微”三者，不可思议，难究其竟，所以它们混而为一。在他之上不再有光明，在他之下不再有黑暗。难以言说的无限延绵啊，又复归于空虚无物。他是没有状态的状态，没有形象的形象，叫做恍惚。迎面看不见他的先头，追踪抓不著他的尾迹。秉持上古之道，可以把握当今万有，知道其由来始末，这便是大道的要领了。\n\n【第十五章】古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容：豫兮若冬涉川，犹兮若畏四邻，俨兮其若客；涣兮若冰之将释，敦兮其若朴，旷兮其若谷；混兮其若浊。 孰能浊以澄？静之徐清；孰能安以久？动之徐生。保此道者不欲盈。夫唯不盈，故能敝而新成。\n\n【翻译】：古时候善于行道的人，其微妙玄通，真是深不可识。由于深不可识，只好勉强来形容他： 其审慎好像冬天过江，谨守好像畏惧四邻，恭敬严肃如同作客，流逸潇洒如同化冰，纯朴得好像未经雕琢，旷达得好像高山空谷，敦厚得好像浑沌不清。谁能沉淀混浊的，使之渐渐清澈呢?谁能启动僵死的，使之徐徐复活呢? 持守此道的人，是不会自满自溢的。唯有不自满自溢，才能在凋敝死亡中成为新人。 　　\n\n【第十六章】致虚极，守静笃。万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，静曰复命。复命曰常，知常曰明。不知常，妄作凶。 知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。　　\n\n【翻译】： 内心虚化到极点，持守安静到纯一。我就能在万物的篷蓬勃勃中，看出其来龙去脉。万物纷纭百态，都复归其本根。回到本根就叫平静安息。平静安息便是复归了真生命。复归了真生命便是永恒。认识永恒便是光明。不认识永恒，就会任意妄为，后果凶险。认识了永恒，就能万事包容。万事包容，就能公义坦荡。公义坦荡，则为完全人。完全人，则与天同。与天同，就归入道了。归入道，可就长久了，即使肉身消失，依然平安无恙。 　　\n\n【第十七章】太上，不知有之；其次，亲而誉之；其次，畏之；其次，侮之。信不足焉，有不信焉。悠兮其贵言。功成事遂，百姓皆谓：「我自然」。　　\n\n【翻译】： 至高至善的掌权者，人们仿佛感觉不到其存在。次一等的，赢得人们的亲近赞 誉。再次的，使人们畏惧害怕。更次的，遭人们侮慢轻蔑。信实不足，才有不信。悠悠然大道之行，无须发号施令，大功告成之后，百姓都视之为自然而然的事，说：我们本来就是这样的啊! 　　\n\n【第十八章】大道废，有仁义；智慧出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。\n\n【翻译】：大道废弃了，才出现仁义。智慧出来了，才有大伪诈。六亲不和，才大讲孝慈。国家昏乱，才呼唤忠臣。 　　\n\n【第十九章】绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。此三者以为文，不足。故令有所属：见素抱朴，少思寡欲，绝学无忧。 　　\n\n【翻译】： 弃绝成功与智慧，对人民有百倍的好处。弃绝仁义的说教，人民就会复归孝慈。弃 绝技巧与功利，就不会有盗贼为患。然而，用这三者作诫律是不够的。一定要让人心有所归属才行，就是：认识生命的本根，持定存在的本原。使自我越来越少，使欲望越来越淡。拒绝人间的学问，保持无忧无虑的心。 　　\n\n【第二十章】唯之与阿，相去几何？美之与恶，相去若何？人之所畏，不可不畏。荒兮，其未央哉！ 众人熙熙，如享太牢，如春登台。我独泊兮，其未兆；沌沌兮，如婴儿之未孩； 累累兮，若无所归。众人皆有馀，而我独若遗。我愚人之心也哉！俗人昭昭，我独昏昏。俗人察察，我独闷闷。澹兮其若海，兮若无止。众人皆有以，而我独顽且鄙。我独异于人，而贵食母。 　　\n\n【翻译】： 恭维与呵斥，相差有多远?赞美与厌恶，区别在哪里?人所畏怕的，不能不畏怕啊。荒野啊，广漠无际! 众人熙熙攘攘，像是在享受盛大的宴席，像是登上了欢乐的舞台。唯独我浑然无觉，好像不曾开化的样子; 混混沌沌，像初生婴儿还不知嘻笑的时候; 疲惫沮丧，像是四处流浪无家可归的人。众人都自得自满流溢而出，唯独我仿佛遗失了什么。我真是愚笨人的心肠啊! 　　世俗的人个个明明白白，唯独我一个昏昏然然。世俗的人个个斤斤计较，唯独我一个马虎不清。大水荡荡淼如海，高风习习行无踪。众人都有一套本事，唯独我又没用又顽固。我这样与众不同，是把吃喝母亲，看得高于一切啊! 　\n\n【第二十一章】孔德之容，惟道是从。道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈兮冥兮，其中有精；其精甚真，其中有信。自今及古，其名不去，以阅众甫。吾何以知众甫之状哉？以此。　　\n\n【翻译】：最高的道德形态，是彻底顺从道。道作为存在物，完全是恍恍惚惚的。恍惚之中有形象，恍惚之中有实在。在他的深远幽暗中，有一个精神存在著。这个精神至真至切，充满了信实。从古到今，他的名字从不消失，好叫人们看到万物之父。我怎么晓得万物之父呢?就是由他而来。 　　\n\n【第二十二章】曲则全，枉则直，洼则盈，敝则新，少则多，多则惑。 是以圣人抱一为天下式。不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。夫唯不争，故天下莫能与之争。古之所谓「曲则全」者，岂虚言哉！诚全而归之。\n\n【翻译】：受屈辱的，可得成全;受冤枉的，可得伸直;低洼的得充满，将残的得新生，缺乏 的便获得，富有的便迷惑。 　　所以，圣人与道合一，做天下人认识上天的器具。不自以为能看见，所以看得分明。不自以为是，所以是非昭彰。不求自己的荣耀，所以大 功告成。不自以为大，所以为天下王。 　　正因为不争不竞，天下没有能与之争竞的。古人说”受屈辱必得成全”的话，岂是虚构的吗?那确实得成全者，天下便归属他。 　　\n\n【第二十三章】希言自然。故飘风不终朝，骤雨不终日。孰为此者？天地。天地尚不能久，而况于人乎？故从事于道者，同于道；德者，同于德；失者，同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐得之。信不足焉，有不信焉。　\n\n【翻译】：少说话，合乎自在本相。狂风刮不了一清晨，暴雨下不了一整天。兴起风雨的是谁呢?是天地。天地都不能长久， 何况人呢?所以，从事于道的人就认同道，有德的人就认同德，失丧的人就认同失丧。认同道的人，道便悦纳他;认同德的人，德便欢迎他;认同失丧的人，失丧便拥抱他。信心不足，才有不信。 　　\n\n【第二十四章】企者不立；跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。其在道也，曰：馀食赘形。物或恶之，故有道者不处。　　\n\n【翻译】：翘著脚就站立不住，蹦著高就走不成路。自以为能看见的是瞎子，自以为聪明的是傻子。自我夸耀的徒劳无功，自高自大的不能为首。从道的眼光来看，这些东西像多余的饭，累赘的事，只会让人厌恶。有道的人不会这样的。 　　\n\n【第二十五章】有物混成，先天地生。寂兮寥兮，独立而不改，周行而不殆，可以为天地母。吾不知其名，强字之曰道，强为之名曰大。大曰逝，逝曰远，远曰反。故道大，天大，地大，人亦大。域中有四大，而人居其一焉。人法地，地法天，天法道，道法自然。　　\n\n【翻译】：在产生天地之前，有一个混然一体的存在。寂静啊，空虚啊!独立自在，永不改变。普天运行，永不疲倦。称得上是天地万物的母亲。我不知道他的名字，姑且写作”道”，勉强起个名字叫”大”。大，便无限飞逝，飞逝而致远，至远而回返。所以道为大，天为大，地为大，人也为大。宇宙中四个为大的，人是其中之一。然而人要以地为法度，地以天为法度，天以道为法度，道以他自身为法度。 　　\n\n【第二十六章】重为轻根，静为躁君。是以君子终日行不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？ 轻则失根，躁则失君。 　　\n\n【翻译】：重是轻的根基，静是躁的主人。所以君子每天出行时都带著辎重。虽有荣华壮观，他却安然超脱。然而有的大国君主，只重自身，轻慢天下，以致灭亡。轻浮就会失根，骄躁就会失控。\n\n【第二十七章】善行无辙迹，善言无瑕谪；善数不用筹策；善闭无关楗而不可开，善结无绳约而不可解。是以圣人常善救人，故无弃人；常善救物，故无弃物。是谓袭明。故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。　　\n\n【翻译】：善于行走的不留踪迹，善于言辞的没有暇疵，善于计算的不用器具。善于关门的不用门插，却无人能开;善于捆绑的不用绳索，却无人能解。 圣人就是这样一直善于拯救世人，无人被弃之不顾;一直善于挽救万物，无物被弃之不顾。这就叫承袭、传递光明。所以说，善人是不善之人的老师，不善之人亦是善人的资财。如果不敬重老师，或者不爱惜其资财，那么，再有智慧也是大大地迷失了。这是一个至关重要的奥妙啊! 　　\n\n【第二十八章】知其雄，守其雌，为天下溪。为天下溪，常德不离，复归于婴儿。知其白，守其黑，为天下式。为天下式，常德不忒，复归于无极。知其荣，守其辱，为天下谷。为天下谷，常德乃足，复归于朴。朴散则为器，圣人用之，则为官长。故大智不割。　\n\n【翻译】： 知道其雄伟强壮，却甘守雌爱柔顺，而成为天下的溪流。作为天下的溪流，永恒的恩德与他同在，(使人)复归于纯洁的婴儿。知道其光明所在，却甘守暗昧，而成为世人认识上天的工具。作为世人认识上天的工具，永恒的恩德至诚不移，(使人)复归于无限的境界。知道其荣耀，却甘守羞辱，而成为天下的虚谷。作为天下的虚谷，永恒的恩德充足丰满，(使人)复归于存在的本原。这本原化散在不同的人身上，成为不同的器物。圣人使用他们，而成为掌权者。如此，至大的智慧是浑然为一、不可分割的。 　　\n\n【第二十九章】将欲取天下而为之，吾见其不得已。天下神器，不可为也，不可执也。为者败之，执者失之。是以圣人无为，故无败；无执，故无失。夫物或行或随；或嘘或吹；或强或羸；或载或隳。是以圣人去甚，去奢，去泰。　　\n\n【翻译】： 想用人为的努力去赢得天下，我看达不到目的。天下是神的器具，不是人为努力就能得著的。人为努力的，必然失败;人为持守的，必然丧失。世间是这样：有占先前行的，就有尾追不舍的;有哈暖气的，就有吹冷风的;有促其强盛的，就有令其衰弱的;有承载的，就有颠覆的。所以圣人摈弃一切强求的、奢侈的和骄恣的东西。 　　\n\n【第三十章】以道佐人主者，不以兵强天下。其事好远。师之所处，荆棘生焉。大军之后，必有凶年。善有果而已，不以取强。果而勿矜，果而勿伐，果而勿骄。果而不得已，果而勿强。物壮则老，是谓不道，不道早已。　　\n\n【翻译】：用道来行使主权的人，不靠武力而称强天下。用武力总是有报应的。军队进驻之地，荆棘便长出来;每逢大战之后，凶年接著来到。良善自会结果，无须强夺硬取。成了而不矜持，成了而不炫耀，成了而不骄傲，成了像是不得已，成了而不逞强。任何事物一逞强示壮就会老朽，这不是出于道。不是出于道的，是早已注定要死亡了。\n\n【第三十一章】兵者不祥之器，非君子之器。不得已而用之，恬淡为上，胜而不美。而美 之者，是乐杀人。夫乐杀人者，则不可得志于天下矣。夫兵者，不祥之器，物或恶之，故有道者不处。君子居则贵左，用兵则贵右。吉事尚左， 凶事尚右。偏将军居左，上将军居右，言以丧礼处之。杀人之众，以悲哀泣之，战胜以丧 礼处之。　　\n\n【翻译】：兵是不吉利的东西，不是君子所使用的。万不得已而用之，也是以恬淡之心，适可 而止，打胜了也不当成美事。以打胜仗为美事的人，就是以杀人为乐。以杀人为乐的人， 是绝不可能得志于天下的。所谓兵，是不吉利的东西，万物都厌恶，得道的人不用它。君子平时以左方为贵，战时以 右方为贵，因为左方表示吉祥，右方代表凶丧。偏将军在左边，上将军在右边，就是以凶 丧来看待战事。杀人多了，就挥泪哀悼;打了胜仗，也像办丧事一样。 \n\n【第三十二章】道常无名。朴虽小，天下莫能臣。侯王若能守之，万物将自宾。天地相合，以降甘露，民莫之令而自均。始制有名，名亦既有，夫亦将知止，知止可以不殆。譬道之在天下，犹川谷之于江海。　　\n\n【翻译】：道，通常不显露其名份。存在的本原即道的本体，虽然精渺微小，天下却没有什么能支配他。王侯若能持守他，万物会自动归顺。 　　天地相和，降下甘露，无人分配，自然均匀。宇宙一开始有秩序，就有了名份。既有了名份，人就该知道自己的限度，不可僭越。知道 人的限度而及时止步，就可以平安无患了。道，引导天下万民归向自己，就好像河川疏导诸水流向大海。　　\n\n【第三十三章】知人者智，自知者明。胜人者有力，自胜者强。知足者富。强行者有志。不失其所者久。死而不亡者寿。\n\n【翻译】： 能识透别人，算有智慧;能识透自己，才有光明。能战胜别人，算有力量;能战胜自己，才是真强。知足的人富有。攻克己身、顺道而行的人有志气。持守本相、不失不离的人可以长久。肉身虽死、生命活著的人才叫长生。\n\n【第三十四章】大道泛兮，其可左右。万物恃之以生而不辞，功成而不有。衣养万物而不为主，可名于小；万物归焉而不为主，可名为大。以其终不自为大，故能成其大。\n\n【翻译】：大道弥漫，无所不在，周流左右。万物都是籍著他生的，他不自夸自诩。大功都是由他而来的，他不彰明昭著。他爱抚滋养万物，却不以主宰自居，看起来微不足道的样子。当万物都依附归向他时，他 仍然不以主宰自居，这样，他的名份可就大了。由于他从始至终不自以为大，这就成就了他的伟大。\n\n【第三十五章】执大象，天下往。往而不害，安平泰。乐与饵，过客止。道之出口，淡乎其无味，视之不足见，听之不足闻，用之不足既。 　　\n\n【翻译】： 秉持大道之象者，普天下都前往归向他。普天下都归向他，也不会互相妨害，反而得享安息、平安、太平。人间的美乐佳宴，使匆匆过客们沉溺不前。大道出口成为话语，平淡无味，看起来不起眼，听起来不入耳，用起来却受益无穷。 　　\n\n【第三十六章】将欲歙之，必故张之；将欲弱之，必故强之；将欲废之，必故兴之；将欲取之，必故与之。是谓微明。柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。\n\n【翻译】： 要收敛的，必先张驰一下。要削弱的，必先加强一下。要废弃的，必先兴起一会儿。要夺取的，必先让与一点儿。这是微妙的亮光。柔弱的胜于刚强的。鱼不能离开水(而上岸)，国家的主权和势能也无法(离开道)向人展示清楚。 \n\n【第三十七章】道常无为而无不为。侯王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴。镇之以无名之朴，夫将不欲。不欲以静，天下将自正。　　\n\n【翻译】：道，通常看起来无所作为的样子，实际上没有一件事物不是他成就的。王侯若能持守他，就一任万物自己变化。变化中有私欲发作，我便用那无以名状的本原来镇住。在这个无以名状的本原里，欲望将 断绝。欲望断绝，人心平静了，天下自然便安稳了。 　　\n\n【第三十八章】上德不德，是以有德；下德不失德，是以无德。上德无为而无以为；下德无为而有以为。上仁为之而无以为；上义为之而有以为。上礼为之而莫之应，则攘臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。前识者，道之华，而愚之始。是以大丈夫处其厚，不居其薄；处其实，不居其华。故去彼取此。　\n\n【翻译】： 道德高尚的人，不必以道德诫命来自律，因为他内心自有道德。道德低下的人， 需要恪守道德诫命，因为他内心没有道德。道德高尚的人是无为的，其道德不是刻意为了实现什么。道德低下的人是在追求道德，其 道德是为了达到某种目的。有大仁爱的人，是在追求仁爱，却不是刻意实现某种目的。有大正义的人，是在追求正 义，而且其正义是为了实现某种目的。有大礼法的人，是在追求礼法，却没有人响应，就抡起胳膊去强迫人了。所以，丧失了大道，这才强调道德;丧失了道德，这才强调仁爱;丧失了仁爱，这才强调 正义;丧失了正义，这才强调礼法。所谓礼法，不过表明了忠信的浅薄缺乏，其实是祸乱的端倪了。所谓人的先见之明，不过采摘了大道的一点虚华，是愚昧的开始。所以，大丈夫立身于丰 满的大道中，而不站在浅薄的礼法上;立身于大道的朴实中，而不站在智慧的虚华上。据 此而取舍。 　　\n\n【第三十九章】昔之得一者：天得一以清；地得一以宁；神得一以灵；谷得一以生；侯得一以为天下正。其致之也，谓天无以清，将恐裂；地无以宁，将恐废；神无以灵，将恐歇；谷无以盈，将恐竭；万物无以生，将恐灭；侯王无以正，将恐蹶。故贵以贱为本，高以下为基。是以侯王自称孤、寡、不谷。此非以贱为本邪？非乎？故致誉无誉。是故不欲琭琭如玉，珞珞如石。　　\n\n【翻译】：古人所得的，是一(唯一者，原初者，化一者，即道)。天空得一而清虚，大地得一而安稳，神只得一而显灵，江河得一而流水，万物得一而生 长，王侯得一而天下归正。推而言之：天空若不清虚，恐怕要裂开了;大地若不安稳，恐怕要塌陷了;神祁若不显 灵，恐怕要消失了;江河若不流水，恐怕要干枯了;万物若不生长，恐怕要灭绝了;王侯 不能使天下归正，恐怕要跌倒了。贵是以贱为本体的，高是以低为基础的。所以王侯都自称孤家、寡人、不善。这不正是以 贱为本体吗?不是吗?所以最高的荣誉恰恰没有荣誉。所以不要追求晶莹如美玉，坚硬如顽石。 　　\n\n【第四十章】反者道之动；弱者道之用。天下万物生于有，有生于无。\n\n【注释】：反，有相反、返归二意。二意相通：反于世界，返归于道。详见第三部一章一则”反”。 　　\n【翻译】： 相反，是道的运动所在。柔弱，是道的力量所在。天下万物都生于实有，实有出自虚无。\n\n【第四十一章】上士闻道，勤而行之。中士闻道，若存若亡。下士闻道，大笑之。不笑不足以为道。故建言有之： 明道若昧，进道若退，夷道若类，上德若谷，大白若辱，广德若不足，建德若偷，质真若渝，大方无隅，大器晚成， 大音希声，大象无形。道隐无名。夫唯道，善贷且成。　　\n\n【翻译】： 优秀的人听了道之后，勤勉地遵行。一般的人听了道之后，仍是似懂非懂、若有若无的样子。俗陋的人听了道之后，大声嘲笑。若不被这种人嘲笑，那还叫真道吗?所以《建言书》上说：道是光明的，世人却以为暗昧。在道里长进，却似乎是颓废。在道里有平安，看起来却像是艰难。至高的道德却好像幽谷低下，极大的荣耀却好像受了侮辱，宽广之德却被视若不足，刚健之德视若苟且，实在的真理视若虚无，至大的空间没有角落，伟大的器皿成形在后，声音太大时，人在其中就听不到什么;形象太大时，人在其中就看不到什么。道是隐秘的;然而只有道，善施与、又能成全。 　　\n\n【第四十二章】道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。人之所恶，唯孤、寡、不谷，而王公以为称。故物或损之而益，或益之而损。人之所教，我亦教之：强梁者不得其死，吾将以为教父。 　　\n\n【翻译】： 道先于万物而自在，这是他的实在，称为一。道被言说为道，这是他的名份，称为 二。道的实在，能被言说为道的名份，是因为他有表象，称为三。三而一的道生养了万物。万物都有背道之阴和向道之阳，两者相互激荡以求平和。 人们所厌恶的，不就是孤、寡、不善吗?王公却用这些字眼儿自称。所以，有时求益反而受损，有时求损反而获益。先人教我的，我也用来教你们：自恃其强、偏行己路的人绝没有好下场。这句话，就作为教训的开始。\n\n【第四十三章】天下之至柔，驰骋天下之至坚。无有入无间。吾是以知无为之有益。不言之教，无为之益，天下希及之。 　　\n\n【翻译】：天下最柔弱的，驾御、驰骋于天下最坚强的。没有实体的，进入没有空隙的。我由此便知道无为的益处。这种无言的教化，无为的益处，天下很少有人能得著啊。 　　\n\n【第四十四章】名与身孰亲？身与货孰多？得与亡孰病？甚爱必大费；多藏必厚亡。故知足不辱，知止不殆，可以长久。　\n\n【翻译】：名声与生命，哪一样与你更密切呢?生命与财富，哪一样对你更重要呢?得著世界与丧失生命，哪一样是病态呢? 贪得无厌的人必有大损害，囤积财富的人必有大失丧。所以，知道满足，便不受困辱;知道停止，才能免除危险，可以得享长久的生命。 　　\n\n【第四十五章】大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈，大巧若拙，大辩若讷。静胜躁，寒胜热。清静，为天下正。　　\n\n【翻译】：那完善至极的，看起来却好像欠缺的样子，然而永不败坏。那丰盈四溢的，看起来 却好像虚无的样子，然而用之无穷。最正直的好像弯曲，最聪明的好像愚拙，最善辩的好象口讷。安静胜于躁动，一如寒冷抵御炎热。唯有清静，是天下的正道。 　　\n\n【第四十六章】天下有道，却走马以粪。天下无道，戎马生于郊。祸莫大于不知足；咎莫大于欲得。故知足之足，常足矣。　　\n\n【翻译】：天下有道的时候，最好的战马却用来种地。天下无道的时候，怀驹的母马也要上战 场。最大的祸害就是不知足，最大的罪过就是贪婪。所以，以知足为满足的人，其满足是永恒的。\n\n【第四十七章】不出户，知天下；不窥牖，见天道。其出弥远，其知弥少。是以圣人不行而知，不见而明，不为而成。　 　　\n\n【翻译】： 不出屋门便可知天下，不望窗外便可见天道。出去的越远，知道的越少。 所以圣人不必经历便知道，不必看见就明白，不靠努力而成就。\n\n【第四十八章】为学日益，为道日损。损之又损，以至于无为。无为而无不为。取天下常以无事，及其有事，不足以取天下。　\n\n【翻译】：追求知识会越来越膨胀自负，追求真道会越来越谦卑虚己。一直谦卑虚己下去，就 可以达到无为的境界了。在无为的境界里，便可以无所不为了。得天下常常是靠无事，倘若极尽其能事，便不能得天下了。 　　\n\n【第四十九章】圣人常无心，以百姓心为心。善者，吾善之；不善者，吾亦善之；德善。信者，吾信之；不信者，吾亦信之；德信。圣人在天下，歙歙焉，为天下浑其心，百姓皆注其耳目，圣人皆孩之。 　　\n\n【翻译】： 圣人没有一己之心，而是一心为了百姓的心。良善的人，以良善待他;不良善的人，也以良善待他，从而结出良善的果子。信实的人，以信实待他;不信实的人，也以信实待他，从而结出信实的果子。圣人在天下，以其气息使人心浑然纯朴。百姓们全神贯注，凝视凝听，圣人则把他们当婴 孩看待。 \n\n【第五十章】出生入死。生之徒，十有三；死之徒，十有三；人之生，动之于死地，亦十有三。夫何故？以其生之厚。盖闻善摄生者，路行不遇兕虎，入军不被甲兵；兕无所投其角，虎无所用其爪，兵无所容其刃。夫何故？以其无死地。　\n\n【翻译】： 人一生出来，就进入了死亡。人以四肢九窍活著，人以四肢九窍死去，人以这四肢九窍，将自己的生命送到死地。为什么会这样?因为世人太贪婪今生的享乐了。听说善于得到并持守真生命的人，行路不会遇到老虎，打仗不会受到伤害。在他面前，凶 牛不知怎么投射它的角，猛虎不知怎么扑张它的爪，敌兵不知怎么挥舞他的刀。为什么会这样?因为他已脱离了死亡的境地啊! \n\n【第五十一章】道生之，德畜之，物形之，势成之。是以万物莫不尊道而贵德。道之尊，德之贵，夫莫之命而常自然。故道生之，德畜之；长之育之；成之熟之；养之覆之。生而不有，为而不恃，长而不宰。是谓玄德。　　　\n\n【翻译】： 万物都是由道所生，又有恩德去蓄养，化育为物形，得势而成长。所以万物没有不敬畏大道、不珍惜恩德的。大道的可敬和恩德的可贵，在于他不是情动一时、令出一时，乃是自然而然、永恒如此。所以说，道生出万物，又以恩德去蓄养，使它们成长发育，给它们平安稳定，对它们抚爱 保护。然而他这样创造养育却不强行占有，他这样无所不为却不自恃己功，他是万物之主 却不任意宰制，这可真是深不可测的恩德啊! 　　\n\n【第五十二章】天下有始，以为天下母。既得其母，以知其子，复守其母，没身不殆。塞其兑，闭其门，终身不勤。开其兑，济其事，终身不救。见小曰明，守柔曰强。用其光，复归其明，无遗身殃；是为袭常。\n\n【翻译】： 世界有一个开始，那开始的，就是世界的母亲。既晓得有一位母亲，就知道我们是儿子。既知道我们是儿子，就应当回归守候母亲。若能这样，纵然身体消失，依旧安然无恙。塞住通达的感官，关闭认识的门户，你就终身不会有劳苦愁烦。敞开你的通达感官，极尽 你的聪明能事，你便终生不能得救了。能见著精微才叫明亮，能持守柔顺才叫强壮。藉著大道洒下的光亮，复归其光明之中，就不会留下身后的祸殃了。这就是承袭永恒、得 著永生的意思。\n\n【第五十三章】使我介然有知，行于大道，唯施是畏。大道甚夷，而人好径。朝甚除，田甚芜，仓甚虚；服文采，带利剑，厌饮食，财货有馀；是为盗夸。非道也哉！\n\n【翻译】： 这使我对大道确信不疑，行于其中，唯恐偏失。大道非常平安，世人却偏行险路。朝廷已很污秽，田园已很荒芜，粮仓已很空虚，却穿著华美的服饰，佩戴锋利的刀剑，吃腻佳肴美味，囤积金银财宝，这不就是强盗头子吗?这个背离大道的世代啊! 　　\n\n【第五十四章】善建者不拔，善抱者不脱，子孙以祭祀不辍。修之于身，其德乃真；修之于家，其德乃馀；修之于乡，其德乃长；修之于邦，其德乃丰；修之于天下，其德乃普。故以身观身，以家观家，以乡观乡，以邦观邦，以天下观天下。吾何以知天下然哉？以此。　\n\n【翻译】：完善的建造者，其建造的不能拔除。完善的保守者，其保守的不会失落。应当祭祀敬拜这完善者，子子孙孙永不停息。一个人若这样，他身上的恩德必真实无伪。一家若这样，这一家的恩德必充实有余。一乡 若这样，这一乡的恩德必深远流长。一国若这样，这一国的恩德必丰满兴隆。若以此教化 天下，其恩德必普行于天下。所以，将上面的道理用于一身，则知一身;用于一家，则知一家;用于一乡，则知一乡; 用于一国，则知一国;用于天下，则知天下。我从何知晓天下之事呢?就是从这里。 　　\n\n【第五十五章】含「德」之厚，比于赤子。毒虫不螫，猛兽不据，玃鸟不搏。骨弱筋柔而握固。未知牝牡之合而全作，精之至也。终日号而不嗄，和之至也。知和曰「常」，知常曰「明」。益生曰祥。心使气曰强。物壮则老，谓之不道，不道早已。\n\n【翻译】：含容道德深厚的人，得到道的呵护，与婴儿得到母亲的呵护一样。对于婴儿，有毒之虫类不来蜇害，凶猛的野兽不来扑捉，善抓善捕的鹰鸟不来攻击。他们筋骨柔弱却能把东西牢固地握住，不知道两性交合但是生殖器官却能自然兴奋起来，因为他们精气纯正。他们整天哭号却不会嗓音沙哑，因为他们与自然的呼吸一样和谐。知晓自然的和谐之气，也就理解了永恒不变之道。人们知道了永恒不变之道，就有可能达到明察的境界。但是，人们却想要增加自己的生机，认为这是可以达到长生目的的;然后，人们又根据自己的心愿而役使精气，认为这样可以变得更强大。看起来，从婴儿到成人，似乎是越来越强大了，但是，万事万物都是一旦强壮了就开始衰老了，追求强壮是不符合大道的，不符合大道就会提前导致死亡。也就是说，失去了自然之道而追求强壮，反而会加速死亡，不如复归于婴儿。 　　 　　\n\n【第五十六章】知者不言，言者不知。塞其兑，闭其门，挫其锐，解其纷，和其光，同其尘，是谓玄同。故不可得而亲，不可得而疏，不可得而利，不可得而害，不可得而贵，不可得而贱。故为 天下贵。 　　\n\n【 翻译】： 真正了解大道的人不去多加解说，一定要把大道解说清楚的人不是真正知道大道的人。因为大道是无法用语言文字解说清楚的。堵塞自己的口耳，关闭自己的眼鼻，不去受道听途说的干扰;解除自己的棱角，排除纷杂的头绪，让自己的心灵与自然之光相和谐，与大地尘土同在，也就是说物我合一而不强调自我的存在，这可以叫做与玄妙的的天道同一。能够与天道同一，那么，也就不必再求亲近，不必在乎疏远;谈不上对自己是否有利，也谈不上对自己是否有害;不必把什么看作是尊贵的，也不必把什么看作是卑贱的，这样才能成为天下真正最为尊贵的。 　　 　　\n\n【第五十七章】以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此：天下多忌讳，而民弥贫；人多利器，国家滋昏；人多伎巧，奇物滋起；法令滋彰，盗贼多有。故圣人云：「我无为，而民自化；我好静，而民自正；我无事，而民自富；我无欲，而民自朴。」　　\n\n【 翻译】：治理国家要用正道，用兵打仗要用奇变，治理天下要不有意做什么事。也就是要掌握正变与无为之道。我什么知道应该如此呢?根据我今日所见的情况。现在的天下充满着忌讳，有太多的教条，但是百姓却更加贫穷;百姓有太多的权谋计较，国家政治却更加昏暗;人们有太多的技能智巧，离奇古怪的东西却越来越多;法律命令越来越清楚，盗贼却照样非常众多。所以，圣人说：我不凭个人私心去做事，但百姓能自然生化;我喜欢清静虚灵，但百姓能自然按正道而行;我不有意去做事，但百姓能自然富裕起来，我没有个人欲望，但百姓能自然保持其质朴的本性。\n\n【第五十八章】其政闷闷，其民淳淳。其政察察，其民缺缺。祸兮福之所倚，福兮祸之所伏。孰知其极？ 正复为奇，善复为妖。人之迷，其日固久。是以圣人方而不割，廉而不刿，直而不肆，光而不耀。 　　\n\n【翻译】： 天下的政治好像不清楚，但是百姓能风俗淳朴;天下的政治好像明明白白，但是百姓却有太多的缺憾和疏懒。灾祸是福气产生的根源，福气是灾祸藏伏的处所。这样祸福相互交替，有谁知道何时是极限呢? 天子没有按正道去做，天下走正道的人也会变为追求奇变的人，善良的人也能变为妖孽。人们处在迷惑之中，时间本来就已经很久了。因此，圣人保持自我的方正，却不按唯一的标准去要求众人;保持自我的清廉寡欲，却不割裂伤害众人;保持自我的率直，却不随意做事;保持自我的明察，却不炫耀自我。 　　\n\n【第五十九章】治人事天，莫若啬。夫为啬，是谓早服；早服谓之重积德；重积德则无不克；无不克则莫知其极；莫知其极，可以有国；有国之母，可以长久；是谓深根固柢，长生久视之道。　\n\n【翻译】： 君王治理百姓、运用天道，没有比节制收敛更好的。所谓机制收敛，这就是说要早些按天道做事。早按天道做事，就是要不断积蓄道德;不断积蓄道德，就无所不胜;无所不胜，就没有人知晓道德的极限;没人知晓道德的极限，就可以拥有国家社稷。能够拥有了治理国家的根本道理–大道，就可以使国家更加长久，这叫做根深蒂固，是保持生命长久、保持明察的总原则。 \n\n【第六十章】治大国，若烹小鲜。以道莅天下，其鬼不神；非其鬼不神，其神不伤人；非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉 。　　\n\n【翻译】：治理大国，却像烹制小鱼一样，不须去肠去鳞等加工，只要直接烹制就可以了。这就是说要用无为的大道来作为治国的方法。根据大道来管理天下大事，鬼神也安于其所在，而不出来扰乱人世。其实不是鬼神不出来扰乱，而是即使出来也不伤人。不是鬼神出来之后不伤人，而是圣人在治理天下的时候也从不伤害人。神鬼和圣人都不相互伤害，所以，道德也就在圣人这里得到了结合与归宿。 　　\n\n【第六十一章】大国者若下流，天下之交，天下之牝。牝常以静胜牡，以静为下。故大国以下小国，则取小国。小国以下大国，则取大国。故或下以取，或下而取。大国不过欲兼蓄人，小国不过欲入事人。夫两者各得其所欲，大者宜为下。　　\n\n【翻译】：大国应当自己自愿处在小国的下面，使自己成为天下士民的交会之地，成为天下人的阴柔宁静的立身之处。阴性永远要用宁静来战胜阳性，也就是要把宁静表现为谦虚卑下。所以，大国用卑下谦虚的态度对待小国，那么，就能得到小国真正的拥护。小国能够用卑下谦虚的态度对待大国，那么，就能得到大国的信任。也就是说，国家不分大小，都应当以谦虚卑下自处。因此，或者表现为大国通过谦虚来得到小国的拥护，或者表现为小国通过谦虚来得到大国的信任。大国不过是想要兼容并蓄更多的人，小国不过是想要进入大国之中来做事。无论是大国还是小国，都能各自得到他们所想要的结果，这是很自然的事，但是，大国应该永远保持谦虚卑下的态度，而不能恃强大而自傲。 　　\n\n【第六十二章】道者万物之奥。善人之宝，不善人之所保。美言可以市尊，美行可以加人。人之不善，何弃之有？故立天子，置三公，虽有拱璧以先驷马，不如坐进此道。古之所以贵此道者何？不曰：求以得，有罪以免邪？故为天下贵。　　　\n\n【翻译】： 道是万物的主宰，善人的宝贝，罪人的中保。美好的言词固然可以博取尊荣，美好的行为固然使人得到敬重，然而人的不善怎能被剔除弃绝呢?所以，就是立为天子，封为三公(太师、太傅、太保)，财宝无数，荣华加身，还不如坐 进这大道里呢! 古时候为什么重视道呢?不就是因为在他里面，寻求就能得著，有罪能得赦免吗?所以道 是天下最尊贵的啊! 　　\n\n【第六十三章】为无为，事无事，味无味。大小多少，抱怨以德。图难于其易，为大于其细。天下难事，必作于易，天下大事，必作于细。是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难。是以圣人犹难之，故终无难矣。 　　\n\n【翻译】： 把清静无为当成作为，以平安无事作为事情，用恬淡无味当作味道。以小为大，以少为多，以德报怨。在容易之时谋求难事，在细微之处成就大事。天下的难事，必从容易时做起;天下的大 事，必从细微处著手。所以，圣人自始至终不自以为大，而能成就其伟大的事业。轻易的许诺，必不大可信;看起来容易的，到头来必难。所以，圣人犹有艰难之心，但终无难成之事。　　\n\n【第六十四章】其安易持，其未兆易谋。其脆易泮，其微易散。为之于未有，治之于未乱。 合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。 　　为者败之，执者失之。是以圣人无为故无败，无执故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货；学不学，复众人之所过。以辅万物之自然，而不敢为。　　\n\n【翻译】：安然平稳，便容易持守;未见兆端，可从容图谋。脆弱不支的，容易瓦解;细微不显时，容易消散。要趁事情未发生时努力，要趁世道未混乱时治理。合抱的粗木，是从细如针毫时长起来的;九层的高台，是一筐土一筐土筑起来的;千里的行程，是一步又一步迈出来的。人为努力的，必然失败;人为持守的，必然丧失。所以，圣人不是靠自己的作为，就不失败;不是自己努力去持守，就不丧失。世人行事，往往是几近成功的时候又失败了。到最后一刻还像刚开始时一样谨慎，就不会 有失败的事了。所以，圣人要世人所遗弃不要的，而不看重世人所珍惜看重的;圣人学世人以为愚拙而不学的，将众人从过犯中领回来。圣人这样做，是顺应万物的自在本相，而不是一己的作为 。 　　\n\n【第六十五章】古之善为道者，非以明民，将以愚之。民之难治，以其智多。故以智治国，国之贼；不以智治国，国之福。知此两者亦稽式。常知稽式，是谓「玄德」。「玄德」深矣，远矣，与物反矣，然后乃至大顺。　　\n\n【翻译】：古时善于行道的人，不是使世人越来越聪明，而是使世人越来越愚朴。世人所以难管理，就因为人的智慧诡诈多端。所以若以人的智慧治理国家，必然祸国殃 民;若不以人的智慧治理国家，则是国家的福气。要知道，这两条是不变的法则。能永远记住这个法则，就叫至高无上的恩德。这至高无上的恩德啊!多么奥妙，多么深远，与一般事理多么不协调，甚至大相径庭，然 而，唯此才是通向大顺的啊! 　　\n\n【第六十六章】江海之所以能为百谷王者，以其善下之，故能为百谷王。是以圣人欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。　　\n\n【翻译】： 大江大海能汇聚容纳百川流水，是因为它所处低下，便为百川之王。若有人想在万民之上，先得自谦为下;要为万民之先，先得自卑为后。圣人正是这样，他在上，人民没有重担;他在前，人民不会受害。所以普天下都热心拥戴 而不厌倦。他不争不竞，谦卑虚己，所以天下没有人能和他相争。\n\n【第六十七章】天下皆谓我道大，似不肖。夫唯大，故似不肖。若肖，久矣其细也夫！我有三宝，持而保之。一曰慈，二曰俭，三曰不敢为天下先。慈故能勇；俭故能广；不敢为天下先，故能成器长。今舍慈且勇；舍俭且广；舍后且先；死矣！ 夫慈以战则胜，以守则固。天将救之，以慈卫之。　　\n\n【翻译】：世人都说我的道太大，简直难以想像为何物。正因为他大，才不具体像什么。若具体像什么，他早就藐小了。我有三件宝贝，持守不渝。一是慈爱，二是俭朴，三是不敢在这世上争强好胜，为人之先。慈爱才能勇敢，俭朴才能扩增，不与人争强好胜，才能为人师长。当今之人，失了慈爱只剩下勇敢，失了俭朴只追求扩增，失了谦卑只顾去抢先，离死亡不远了! 慈爱，用它来征战就胜利，用它来退守必坚固。上天要拯救的，必以慈爱来护卫保守。 　　\n\n【第六十八章】善为士者，不武；善战者，不怒；善胜敌者，不与；善用人者，为之下。是谓不争之德，是谓用人之力，是谓配天古之极。　\n\n【翻译】： 真正的勇士不会杀气腾腾，善于打仗的人不用气势汹汹，神机妙算者不必与敌交锋，善于用人者甘居于人之下。这就叫不争不竞之美德，这就是得人用人之能力，这就算相配相合于天道。上古之时便如此啊! 　　\n\n【第六十九章】用兵有言：「吾不敢为主，而为客；不敢进寸，而退尺。」是谓行无行；攘无臂；扔无敌；执无兵。祸莫大于轻敌，轻敌几丧吾宝。故抗兵相若，哀者胜矣。　　\n\n【翻译】：用兵者有言：”我不敢主动地举兵伐人，而只是被动地起兵自卫;我不敢冒犯人 家一寸，而宁肯自己退避一尺。”这样，就不用列队，不必赤臂，不需武器，因为天下没 有敌人了。最大的祸害是轻敌，轻敌几乎能断送我的宝贝。 所以若两军对峙，旗鼓相当，那悲伤哀恸的一方必胜无疑。 　　\n\n【第七十章】吾言甚易知，甚易行。天下莫能知，莫能行。言有宗，事有君。夫唯无知，是以不我知。 知我者希，则我者贵。是以圣人被褐而怀玉。\n\n【翻译】： 我的话很容易明白，很容易实行。天下的人却不能明白，不能实行。(我的)话有根源，(我的)事有主人。你们自以为有知识，所以不认识我(的话和我的事)。明白我的人越是稀少，表明我所有的越是珍贵。所以圣人外表是粗麻衣，内里有真宝贝。 　　\n\n【第七十一章】知不知，尚矣；不知知，病也。圣人不病，以其病病。夫唯病病，是以不病。\n\n【翻译】： 知道自己无知，最好。无知却自以为知道，有病。只有把病当成病来看，才会不病。圣人不病，就是因为他知道这是病，所以不病。 　　\n\n【第七十二章】民不畏威，则大威至。 无狎其所居，无厌其所生。夫唯不厌，是以不厌。是以圣人自知不自见；自爱不自贵。故去彼取此。　\n\n【翻译】：当人民不再敬畏任何人的权威时，真正的大权威就来到了。不要妨害人们的安居，不要搅扰人们的生活。只要不令人们生厌，人们就不会厌恶权威。所以，圣人深知自己，却不自我炫耀;他珍爱自己，却不自我尊贵。\n\n【第七十三章】勇于敢则杀，勇于不敢则活。此两者，或利或害。天之所恶，孰知其故？ 天之道，不争而善胜，不言而善应，不召而自来，繟然而善谋。天网恢恢，疏而不失。\n\n【翻译】：有勇气自恃果敢，冒然行事的，必死。有勇气自认怯懦，不敢妄为的，得活。这两 种勇气，一个有利，一个有害。上天所厌恶的，谁晓得个中原委呢? 上天的道，总是在不争不竞中得胜有余，在无言无语中应答自如，在不期然时而至，在悠悠然中成全。上天的道，如同浩瀚飘渺的大网，稀疏得似乎看不见，却没有什么可以漏网逃脱。\n\n【第七十四章】民不畏死，奈何以死惧之？若使民常畏死，而为奇者，吾得执而杀之，孰敢？ 常有司杀者杀。夫代司杀者杀，是谓代大匠斲，夫代大匠斲者，希有不伤其手矣。　　\n\n【翻译】： 人民若不怕死，以死来恫吓他们又有什么用呢?如果先使人民惧怕死亡，有为非作歹的人再处死，这样谁还敢为非作歹呢? 冥冥永恒中，已有一位主宰生杀予夺的。企图取而代之去主宰生杀予夺的人，就好象外行 人代替木匠砍削木头。代替木匠砍削木头的人，少有不伤著自己手的。 　　\n\n【第七十五章】民之饥，以其上食税之多，是以饥。民之难治，以其上之有为，是以难治。民之轻死，以其上求生之厚，是以轻死。夫唯无以生为者，是贤于贵生。 \n\n【翻译】： 人民吃不饱，是因为统治者吃税太多，所以吃不饱。人民不好管，是因为统治者人为造事，所以不好管。人民不在乎死，是以为他们追求今生太过份，以致不在乎死。所以，唯有不执著于今生享乐的，比那些过份看重今生的人更高明。 　　\n\n【第七十六章】人之生也柔弱，其死也坚强。草木之生也柔脆，其死也枯槁。故坚强者死之徒，柔弱者生之徒。 是以兵强则灭，木强则折。强大处下，柔弱处上。 　\n\n【翻译】：人活著的时候，身体是柔弱的，一死就僵硬了。草木活著得时候，枝叶是柔脆的，一死就枯槁了。所以坚强的，属于死亡;柔弱的，属于生命。草木之生也柔脆，其死也枯槁。军队一强大就要被消灭了，树木一强盛就要被砍伐了。强大的处于下势，柔弱的处于上势。 　　\n\n【第七十七章】天之道，其犹张弓欤？高者抑之，下者举之；有馀者损之，不足者补之。天之道，损有馀而补不足。人之道，则不然，损不足以奉有馀。孰能有馀以奉天下？唯有道者。是以圣人为而不恃，功成而不处，其不欲见贤。　　\n\n【翻译】： 上天的道，不就像张弓射箭一样吗?高了向下压，低了向上举，拉过了松一松，不足时拉一拉。上天的道，是减少有余的，补给不足的。人间的道却不这样，是损害不足的，加给有余的。谁能自己有余而用来奉献给天下呢?唯独有道的人。所以，圣人做事不仗恃自己的能力，事成了也不视为自己的功劳，不让人称赞自己有才能。 　　\n\n【第七十八章】天下莫柔弱于水，而攻坚强者莫之能胜，以其无以易之。弱之胜强，柔之胜刚，天下莫不知，莫能行。是以圣人云：「受国之垢，是谓社稷主；受国不祥，是为天下王。」正言若反。　　\n\n【翻译】： 天下万物中，没有什么比水更柔弱了。然而对付坚强的东西，没有什么能胜过水了。这是因为水柔弱得没有什么能改变它。这个柔弱胜刚强的道理，天下的人没有不知道的，却没有能实行的。所以圣人说：那为国受辱的，就是社稷之主;那为国受难的，就是天下之王。这些正面肯定的话，听起来好像反话一样，不容易理解。 　　\n\n【第七十九章】和大怨，必有馀怨；报怨以德，安可以为善？ 是以圣人执左契，而不责于人。有德司契，无德司彻。天道无亲，常与善人。\n\n【翻译】：用调和的办法化解怨恨，怨恨并不能消失贻尽，这岂算得上良善呢? 所以，圣人掌握著欠债的存根，却不索取偿还。有德之人明潦欠债而已，并不追讨;无德 之人却是苛取搜刮，珠镏必较。上天之道，公义无私，永远与良善的人同在。 　　\n\n【第八十章】小国寡民。使有什伯之器而不用；使民重死而不远徙。虽有舟舆，无所乘之，虽有甲兵，无所陈之。使民复结绳而用之。甘其食，美其服，安其居，乐其俗。邻国相望，鸡犬之声相闻，民至老死，不相往来。 　　\n\n【翻译】： 国家小，人口少。即使有十倍百倍于人力的器具也不使用。人们畏惧死亡而不远 行迁徙。虽有车船，却没有地方使用;虽有军队，也没有地方部署。让人们再用结绳记事的办法，以其饮食为甘甜，以其服饰为美好，以其居处为安逸，以其 习俗为快乐。邻国的人们相互可以看见，鸡鸣狗叫声相互可以听到，但人民直到老死也不 相互往来。 　　\n\n【第八十一章】信言不美，美言不信。善者不辩，辩者不善。知者不博，博者不知。圣人不积，既以为人己愈有，既以与人己愈多。天之道，利而不害；圣人之道，为而不争。　　\n\n【翻译】： 可信的不华美，华美的不可信。良善的不巧辩，巧辩的不良善。真懂的不广博，广博的不真懂。圣人不为自己积攒什么：既然一切都是为了世人，自己就愈发拥有了;既然一切都已给了 世人，自己就愈发丰富了。上天的道，有利于天下，而不加害于天下。圣人的道，是为了世人，而不与世人相争。\n\n","categories":["阅读"],"tags":["心得","阅读","道经"]}]